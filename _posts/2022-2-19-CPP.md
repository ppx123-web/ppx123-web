---
layout: post
title: Cpp
description: >
    C++ programming tips
tags: [Programming]
author: author1
---

> From C++ Primer Plus

- [运算符()重载与仿函数](#head1)
- [hash_function](#head2)
- [C++函数](#head3)
	- [引用](#head4)
	- [默认参数](#head5)
	- [函数重载](#head6)
	- [模板](#head7)
		- [显式具体化](#head8)
		- [模板中的符号](#head9)
- [类](#head10)
	- [构造函数](#head11)
	- [转换函数](#head12)
	- [友元函数](#head13)
	- [Private,friend,public,protected](#head14)
	- [虚函数](#head15)
	- [类继承](#head16)


## <span id="head1">运算符()重载与仿函数</span>

运算符 ()

在stl queue等容器中，需要重载比较运算符()而不是 <

```c++
struct cmp {
    bool operator () (triple e1,triple e2) {
        return e1.dist > e2.dist;
    }
};
priority_queue<triple,vector<triple>,cmp> pq;
```

cmp中的()运算符重载是仿函数

既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息

```c++
class ShorterThan {
    public:
        explicit ShorterThan(int maxLength) : length(maxLength) {}
        bool operator() (const string& str) const {
            return str.length() < length;
        }
    private:
        const int length;
};

count_if(myVector.begin(), myVector.end(), ShorterThan(length))
//count_if规定了第三个参数只能接受一个参数，但要使得方便修改，利用仿函数即可
}
```

## <span id="head2">hash_function</span>

```C++
static size_t hash(const pair<int,int> & a) {
    return a.first * 3005 + a.second;
}
unordered_map<edge,int,size_t(*)(const pair<int,int> &)>es(n,hash);

unordered_map(size_type __n,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
: _M_h(__n, __hf, __eql, __a)
{ }
```

在上述中使用哈希表需要传递hash function，从声明中知有size和hasher，key_equal()使用==操作符，pair已经有重载

除了上述的直接构建实例(注意static，成员函数指针和静态函数指针不同)，还可以使用前面提到的仿函数

## <span id="head3">C++函数</span>

### <span id="head4">引用</span>

可以多层函数嵌套对对象进行修改，但是需要注意避免返回函数终止时不再存在的内存单元引用

同时可以进行赋值

```C++
type & function(type & arg)
function(arg) = newarg
```

当返回是引用时则可以这样，否则不行。或者返回使用const

```C++
const type & function(type & arg)
function(arg) = newarg (此时则不允许这样)
```

什么时候在函数调用时创建临时变量：

当实参与引用参数不匹配，C++将生成临时变量。目前当参数为const时：（1）实参的类型正确，但不是左值（可被引用的数据对象）（2）类型不正确，但可以转换为正确的类型

### <span id="head5">默认参数</span>

```C++
int function(int tk = 1,int m = 2,int n = 3)
```

有默认参数的右侧的参数也必须都有默认参数

### <span id="head6">函数重载</span>

函数重载的关键是特征标——函数的参数列表，而不是函数的返回类型。因此函数重载返回类型可以不同。

### <span id="head7">模板</span>

模板同样可以重载

#### <span id="head8">显式具体化</span>

函数有多个原型，则编译器在选择原型时，优先选择非模板版本，显式具体化优先于模板

```C++
void swap(job &, job &);

template <> void swap<job>(job &,job &);//显式具体化

template <typename T>
void swap(T &,T &);
```

显式具体化与显式实例化不同

```C++
template void swap<int>(int,int);      //显式实例化
//使用模板生成一个swap的实例

template <> void swap<int> (int ,int ) //显式具体化
template <> void swap (int ,int )      //显式具体化
template <>表示不要使用swap模板来生成一个使用int类型的实例
```

#### <span id="head9">模板中的符号</span>

使用decltype(arg)，用于模板中推断临时变量的类型

后置返回类型

```C++
template<typename T1,typename T2>
auto func(T1 x,T2 y) -> decltype(x + y) {
    return x + y;
}
```

## <span id="head10">类</span>

### <span id="head11">构造函数</span>

explicit 声明的构造函数不允许默认隐式转换和复制转换

```C++
class A {
    A(int) {} 
    A(int,int) {}
};
A a = 1;\\在没有explicit下允许
A a = {1,2};\\在没有explicit下允许
A b = A(a);\\拷贝构造函数，未重载时默认提供
```

只有接受一个参数的构造函数才能作为转换构造函数

### <span id="head12">转换函数</span>

```C++
operator typename();
```

### <span id="head13">友元函数</span>

非成员函数无法访问类的私有成员

类的友元函数是非成员函数，其访问权限与成员函数相同

```C++
friend func(args);\\声明在类中
```

友元函数不能继承

友元函数用于类继承时，因为友元不是成员函数，所以不能使用作用域解析运算符来指出要使用哪个函数，所以使用强制类型转换，使得匹配原型时能够选择正确的函数

### <span id="head14">Private,friend,public,protected</span>

friend的作用见上

protected用于类继承时，派生类对声明为protected的基类的成员可以直接访问

### <span id="head15">虚函数</span>

基类中对应的函数需要声明为virtual，派生类中对应的函数也许要声明

如何工作：维护一个虚函数表，查看派生类和基类的虚函数，如果在派生类中有对应的虚函数，则将派生类的虚函数填入表中，如果没有则将基类的虚函数填入表中

用虚函数实现多态，因为可以用基类的指针和引用指向派生类，这时候调用对应的函数，如果是虚函数中，则会根据对象实际的类型（编译器跟踪）选择实际调用的函数

编译：动态联编

析构函数通常是被成名为虚函数

### <span id="head16">类继承</span>

需要注意类复制构造函数，赋值运算符，特别是成员中含有指针，而指针需要使用new来分配空间，需要深拷贝

使用复制构造函数的情况：

1. 将新对象初始化为一个同类对象
2. 按值将对象传递给函数
3. 函数按值返回对象
4. 编译器生成临时对象

使用赋值运算符的情况：

1. 如果语句创建新的对象，则使用初始化；如果语句修改已有对象的值，则是赋值。


