<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/ppx123-web/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ppx123-web/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-02-26T09:37:40+08:00</updated><id>http://localhost:4000/ppx123-web/feed.xml</id><title type="html">Zhao Chaoyi</title><subtitle>Notes
</subtitle><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><entry><title type="html">Cpp</title><link href="http://localhost:4000/ppx123-web/2022/02/19/CPP/" rel="alternate" type="text/html" title="Cpp" /><published>2022-02-19T00:00:00+08:00</published><updated>2022-02-19T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/02/19/CPP</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/02/19/CPP/"><![CDATA[<ol class="no_toc" id="markdown-toc">
  <li><a href="#运算符重载与仿函数" id="markdown-toc-运算符重载与仿函数">运算符()重载与仿函数</a></li>
  <li><a href="#unordered_map等的hash_function" id="markdown-toc-unordered_map等的hash_function">unordered_map等的hash_function</a></li>
  <li><a href="#c函数" id="markdown-toc-c函数">C++函数</a>    <ol>
      <li><a href="#引用" id="markdown-toc-引用">引用</a></li>
      <li><a href="#默认参数" id="markdown-toc-默认参数">默认参数</a></li>
      <li><a href="#函数重载" id="markdown-toc-函数重载">函数重载</a></li>
      <li><a href="#模板" id="markdown-toc-模板">模板</a>        <ol>
          <li><a href="#显式具体化" id="markdown-toc-显式具体化">显式具体化</a></li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h2 id="运算符重载与仿函数">运算符()重载与仿函数</h2>

<p>运算符 ()</p>

<p>在stl queue等容器中，需要重载比较运算符()而不是 &lt;</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">cmp</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">triple</span> <span class="n">e1</span><span class="p">,</span><span class="n">triple</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">e1</span><span class="p">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">e2</span><span class="p">.</span><span class="n">dist</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">triple</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">triple</span><span class="o">&gt;</span><span class="p">,</span><span class="n">cmp</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>
</code></pre></div></div>

<p>cmp中的()运算符重载是仿函数</p>

<p>既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ShorterThan</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">explicit</span> <span class="n">ShorterThan</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxLength</span><span class="p">)</span> <span class="o">:</span> <span class="n">length</span><span class="p">(</span><span class="n">maxLength</span><span class="p">)</span> <span class="p">{}</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="nl">private:</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">count_if</span><span class="p">(</span><span class="n">myVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myVector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ShorterThan</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
<span class="c1">//count_if规定了第三个参数只能接受一个参数，但要使得方便修改，利用仿函数即可</span>
<span class="err">}</span>
</code></pre></div></div>

<h2 id="unordered_map等的hash_function">unordered_map等的hash_function</h2>

<pre><code class="language-C++">static size_t hash(const pair&lt;int,int&gt; &amp; a) {
    return a.first * 3005 + a.second;
}
unordered_map&lt;edge,int,size_t(*)(const pair&lt;int,int&gt; &amp;)&gt;es(n,hash);

unordered_map(size_type __n,
        const hasher&amp; __hf = hasher(),
        const key_equal&amp; __eql = key_equal(),
        const allocator_type&amp; __a = allocator_type())
: _M_h(__n, __hf, __eql, __a)
{ }
</code></pre>

<p>在上述中使用哈希表需要传递hash function，从声明中知有size和hasher，key_equal()使用==操作符，pair已经有重载</p>

<p>除了上述的直接构建实例(注意static，成员函数指针和静态函数指针不同)，还可以使用前面提到的仿函数</p>

<h2 id="c函数">C++函数</h2>

<h3 id="引用">引用</h3>

<p>可以多层函数嵌套对对象进行修改，但是需要注意避免返回函数终止时不再存在的内存单元引用</p>

<p>同时可以进行赋值</p>

<pre><code class="language-C++">type &amp; function(type &amp; arg)
function(arg) = newarg
</code></pre>

<p>当返回是引用时则可以这样，否则不行。或者返回使用const</p>

<pre><code class="language-C++">const type &amp; function(type &amp; arg)
function(arg) = newarg (此时则不允许这样)
</code></pre>

<p>什么时候在函数调用时创建临时变量：</p>

<p>当实参与引用参数不匹配，C++将生成临时变量。目前当参数为const时：（1）实参的类型正确，但不是左值（可被引用的数据对象）（2）类型不正确，但可以转换为正确的类型</p>

<h3 id="默认参数">默认参数</h3>

<pre><code class="language-C++">int function(int tk = 1,int m = 2,int n = 3)
</code></pre>

<p>有默认参数的右侧的参数也必须都有默认参数</p>

<h3 id="函数重载">函数重载</h3>

<p>函数重载的关键是特征标——函数的参数列表，而不是函数的返回类型。因此函数重载返回类型可以不同。</p>

<h3 id="模板">模板</h3>

<p>模板同样可以重载</p>

<h4 id="显式具体化">显式具体化</h4>

<p>函数有多个原型，则编译器在选择原型时，优先选择非模板版本，显式具体化优先于模板</p>

<pre><code class="language-C++">void swap(job &amp;, job &amp;);

template &lt;&gt; void swap&lt;job&gt;(job &amp;,job &amp;);//显式具体化

template &lt;typename T&gt;
void swap(T &amp;,T &amp;);
</code></pre>

<p>显式具体化与显式实例化不同</p>

<pre><code class="language-C++">template void swap&lt;int&gt;(int,int);      //显式实例化
//使用模板生成一个swap的实例

template &lt;&gt; void swap&lt;int&gt; (int ,int ) //显式具体化
template &lt;&gt; void swap (int ,int )      //显式具体化
template &lt;&gt;表示不要使用swap模板来生成一个使用int类型的实例
</code></pre>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="Programming" /><summary type="html"><![CDATA[C++ programming tips]]></summary></entry><entry><title type="html">Python</title><link href="http://localhost:4000/ppx123-web/2022/02/19/Python/" rel="alternate" type="text/html" title="Python" /><published>2022-02-19T00:00:00+08:00</published><updated>2022-02-19T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/02/19/Python</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/02/19/Python/"><![CDATA[]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="Programming" /><summary type="html"><![CDATA[Python programming]]></summary></entry><entry><title type="html">A Little</title><link href="http://localhost:4000/ppx123-web/2022/01/21/Django/" rel="alternate" type="text/html" title="A Little" /><published>2022-01-21T00:00:00+08:00</published><updated>2022-01-21T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/21/Django</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/21/Django/"><![CDATA[<blockquote>
  <p>How to use Django and config</p>

  <p>HTML CSS JS</p>
</blockquote>

<h1 id="一些常用的内容">一些常用的内容</h1>

<h2 id="html">HTML</h2>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span> — 文档类型。混沌初分，HTML 尚在襁褓（大约是 1991/92 年）之时，DOCTYPE 用来链接一些 HTML 编写守则，比如自动查错之类。DOCTYPE 在当今作用有限，仅用于保证文档正常读取。现在知道这些就足够了。
<span class="nt">&lt;html&gt;&lt;/html&gt;</span> — <span class="nt">&lt;html&gt;</span> 元素。该元素包含整个页面的内容，也称作根元素。
<span class="nt">&lt;head&gt;&lt;/head&gt;</span> — <span class="nt">&lt;head&gt;</span> 元素。该元素的内容对用户不可见，其中包含例如面向搜索引擎的搜索关键字（keywords）、页面描述、CSS 样式表和字符编码声明等。
<span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span> — 该元素指定文档使用 UTF-8 字符编码 ，UTF-8 包括绝大多数人类已知语言的字符。基本上 UTF-8 可以处理任何文本内容，还可以避免以后出现某些问题，没有理由再选用其他编码。
<span class="nt">&lt;title&gt;&lt;/title&gt;</span> — <span class="nt">&lt;title&gt;</span> 元素。该元素设置页面的标题，显示在浏览器标签页上，也作为收藏网页的描述文字。
<span class="nt">&lt;body&gt;&lt;/body&gt;</span> — <span class="nt">&lt;body&gt;</span> 元素。该元素包含期望让用户在访问页面时看到的内容，包括文本、图像、视频、游戏、可播放的音轨或其他内容。
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>图像，alt作为文字替换属性，只有当图像无法显示时出现
<span class="nt">&lt;img</span> <span class="na">src=</span><span class="s">"images/firefox-icon.png"</span> <span class="na">alt=</span><span class="s">"测试图片"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>标题</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;h1&gt;</span>主标题<span class="nt">&lt;/h1&gt;</span>
<span class="nt">&lt;h2&gt;</span>顶层标题<span class="nt">&lt;/h2&gt;</span>
<span class="nt">&lt;h3&gt;</span>子标题<span class="nt">&lt;/h3&gt;</span>
<span class="nt">&lt;h4&gt;</span>次子标题<span class="nt">&lt;/h4&gt;</span>
</code></pre></div></div>

<p>段落</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;p&gt;</span>content<span class="nt">&lt;/p&gt;</span>
</code></pre></div></div>

<p>字体</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;i</span> <span class="na">id=</span><span class="s">""</span><span class="nt">&gt;&lt;/i&gt;</span>斜体
<span class="nt">&lt;b</span> <span class="na">id=</span><span class="s">""</span><span class="nt">&gt;&lt;/b&gt;</span>粗体
<span class="nt">&lt;u</span> <span class="na">id=</span><span class="s">""</span><span class="nt">&gt;&lt;/u&gt;</span>下划线
</code></pre></div></div>

<p>class和id的区别，id在一个页面只能出现一次，而class可以出现多次</p>

<p>列表</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>无序列表<span class="nt">&lt;ul&gt;&lt;/ul&gt;</span>
有序了列表<span class="nt">&lt;ol&gt;&lt;/ol&gt;</span>
列表的每一个项目用一个列表项目元素<span class="nt">&lt;li&gt;&lt;/li&gt;</span>包围
</code></pre></div></div>

<p>链接</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"site"</span><span class="nt">&gt;</span>content <span class="nt">&lt;/a&gt;</span>
</code></pre></div></div>

<h2 id="css">CSS</h2>

<p>规则集</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">p</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="no">red</span>
<span class="p">}</span>
</code></pre></div></div>

<p>选择器（Selector）：HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素（在这个例子中就是 p 元素）。要给不同元素添加样式只需要更改选择器就行了。</p>

<p>声明（Declaration）：一个单独的规则，如 color: red; 用来指定添加样式元素的属性。</p>

<p>属性（Properties）：改变 HTML 元素样式的途径。（本例中 color 就是 &lt;p&gt; 元素的属性。）CSS 中，由编写人员决定修改哪个属性以改变规则。</p>

<p>属性的值（Property value）：在属性的右边，冒号后面即属性的值，它从指定属性的众多外观中选择一个值（我们除了 red 之外还有很多属性值可以用于 color ）。</p>

<p>注意其他重要的语法：</p>

<p>每个规则集（除了选择器的部分）都应该包含在成对的大括号里（{}）。</p>

<p>在每个声明里要用冒号（:）将属性与属性值分隔开。</p>

<p>在每个规则集里要用分号（;）将各个声明分隔开。</p>

<h3 id="链接">链接</h3>

<p>指明链接的文件以及在这个文件作为什么</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"file"</span> <span class="na">rel=</span><span class="s">""</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>style.css</p>

<p>CSS将HTML的元素作为盒子，对每一个元素的各个属性可以进行编辑如width,background-color,color,text-shadow,display,text-align等</p>

<h2 id="js">JS</h2>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="ArchLinux" /><summary type="html"><![CDATA[HTML CSS JS WEB]]></summary></entry><entry><title type="html">Archlinux install</title><link href="http://localhost:4000/ppx123-web/2022/01/15/Archlinux-install/" rel="alternate" type="text/html" title="Archlinux install" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/Archlinux-install</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/Archlinux-install/"><![CDATA[<blockquote>
  <p>Archlinux安装过程中的一些问题，后续配置需要注意的一些事项，以及linux中遇到的一些问题</p>
</blockquote>

<h2 id="list">List</h2>

<ol class="no_toc" id="markdown-toc">
  <li><a href="#list" id="markdown-toc-list">List</a></li>
  <li><a href="#archlinux的安装" id="markdown-toc-archlinux的安装">Archlinux的安装</a></li>
  <li><a href="#显卡驱动" id="markdown-toc-显卡驱动">显卡驱动</a></li>
  <li><a href="#独显下屏幕亮度调节" id="markdown-toc-独显下屏幕亮度调节">独显下屏幕亮度调节</a></li>
  <li><a href="#boot空间不足100m" id="markdown-toc-boot空间不足100m">boot空间不足（100M）</a></li>
  <li><a href="#选择kde" id="markdown-toc-选择kde">选择kde</a></li>
  <li><a href="#v2ray代理" id="markdown-toc-v2ray代理">v2ray代理</a></li>
  <li><a href="#pytorch的安装" id="markdown-toc-pytorch的安装">pytorch的安装</a></li>
</ol>

<h2 id="archlinux的安装">Archlinux的安装</h2>

<p>可以看这一篇：https://zhuanlan.zhihu.com/p/138951848 （注意：建议wiki，安装细节有可能随着更新改变）</p>

<ol>
  <li>
    <p>制作好镜像</p>
  </li>
  <li>
    <p>启动后，联网，更新，安装vim</p>
  </li>
  <li>
    <p>cfdisk分盘</p>
  </li>
  <li>
    <p>mount挂载，在有windows的情况下，分的硬盘挂到/mnt上，把efi挂载到/mnt/boot上，然后按照wiki开始安装</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> pacstrap /mnt base linux linux-firmware nano
</code></pre></div>    </div>
  </li>
  <li>
    <p>生成fstab文件</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> genfstab <span class="nt">-U</span> /mnt <span class="o">&gt;&gt;</span> /mnt/etc/fstab
</code></pre></div>    </div>
  </li>
  <li>
    <p>配置系统</p>
  </li>
  <li>
    <p>进入/mnt</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arch-root /mnt
</code></pre></div>    </div>
  </li>
  <li>
    <p>建议swap文件，用于休眠</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/swapfile <span class="nv">bs</span><span class="o">=</span>2048 <span class="nv">count</span><span class="o">=</span>1048576 <span class="nv">status</span><span class="o">=</span>progress
<span class="nb">chmod </span>600 /swapfile
mkswap /swapfile
swapon /swapfile
vim /etc/fstab 在文件末尾输入 /swapfile none swap defaults 0 0
</code></pre></div>    </div>
  </li>
  <li>
    <p>设置时区</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timedatectl set-timezone Asia/Shanghai
hwclock
</code></pre></div>    </div>
  </li>
  <li>
    <p>取消/etc/locale.gen文件中的en_US UTF-8和zh_CN UTF-8的注释</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>locale-gen
</code></pre></div>    </div>

    <p>创建/etc/locale.cong, 输入LANG=en_US.UTF-8</p>

    <p>创建/etc/hostname  $name</p>
  </li>
  <li>
    <p>修改/etc/hosts</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1	localhost
::1			localhost
127.0.1.1	<span class="nv">$name</span>.localdomain		<span class="nv">$name</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>root用户密码passwd</p>
  </li>
  <li>
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> grub efibootmgr networkmanager network-manager-applet dialog wireless_tools wpa_supplicant os-prober mtools dosfstools ntfs-3g base-devel linux-headers reflector git <span class="nb">sudo</span>
</code></pre></div>    </div>

    <p>使用grub作为启动器
安装intel-ucode或amd-ucode</p>
  </li>
  <li>
    <p>退出，取消挂载，重启,使用root账户登录</p>
  </li>
  <li>
    <p>登录后</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl <span class="nb">enable</span> <span class="nt">--now</span> NetworkManager
nmtui联网
</code></pre></div>    </div>
  </li>
  <li>
    <p>创建普通用户</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>useradd <span class="nt">-m</span> <span class="nt">-G</span> wheel <span class="nv">$user</span>
passwd <span class="nv">$user</span>
<span class="nv">EDITOR</span><span class="o">=</span>vim visudo
取消wheel <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span> ALL的注释
</code></pre></div>    </div>

    <p>安装显卡驱动</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> nvidia nvidia-util
pacman <span class="nt">-S</span> xf86-video-amdgpu
</code></pre></div>    </div>
  </li>
  <li>
    <p>安装</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> xorg
</code></pre></div>    </div>
  </li>
  <li>
    <p>桌面环境及后续</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> sddm
pacman <span class="nt">-S</span> plasma packagekit-qt5 kate git kconsole
</code></pre></div>    </div>
  </li>
  <li>
    <p>添加archlinuxcn源</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>archlinuxcn]
Server <span class="o">=</span> https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="nv">$arch</span>
并取消multilib的注释

pacman <span class="nt">-Syu</span> <span class="o">&amp;&amp;</span> pacman <span class="nt">-S</span> archlinuxcn-keyring
pacman <span class="nt">-S</span> ttf-sarasa-gothic noto-fonts-cjk
</code></pre></div>    </div>
  </li>
  <li>重启</li>
</ol>

<h2 id="显卡驱动">显卡驱动</h2>

<p>如果安装时使用核显，则后续怎么都转不了独显的驱动</p>

<p>所以建议直接从头到尾使用独显，驱动问题轻松解决</p>

<h2 id="独显下屏幕亮度调节">独显下屏幕亮度调节</h2>

<p>wiki Nvidia中</p>

<p>创建/etc/X11/xorg.conf.d/20-nvidia.conf</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Section "Device"
    Identifier   "Device0"
    Driver     "nvidia"
    VendorName   "NVIDIA Corporation"
    Option "RegistryDwords" "EnableBrightnessControl=1"
EndSection
</code></pre></div></div>

<p>然后更新grub</p>

<h2 id="boot空间不足100m">boot空间不足（100M）</h2>

<p>https://wusiyu.me/archlinux-remove-initramfs-linux-fallback-img/</p>

<p>删除fallback.img</p>

<p>然后在/etc/mkinitcpio.d/linux.preset中去掉fall back的部分</p>

<h2 id="选择kde">选择kde</h2>

<p>新的gnome十分难用，不建议使用</p>

<h2 id="v2ray代理">v2ray代理</h2>

<p>开启系统代理，命令行用proxychains</p>

<h2 id="pytorch的安装">pytorch的安装</h2>

<p>2021-1-16  python3.10好像有点问题，安装不了torch</p>

<p>yay安装python39</p>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="ArchLinux" /><summary type="html"><![CDATA[Install Archlinux]]></summary></entry><entry><title type="html">高级算法作业</title><link href="http://localhost:4000/ppx123-web/2022/01/15/advanced-alogrithm-A3/" rel="alternate" type="text/html" title="高级算法作业" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/advanced-alogrithm-A3</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/advanced-alogrithm-A3/"><![CDATA[<h1 id="高级算法第三次作业">高级算法第三次作业</h1>

<p>匡亚明学院 赵超懿 191870271</p>

<h2 id="第一题">第一题</h2>

<h3 id="1">(1)</h3>

<p>显然当$a\in A\wedge a\in B\Rightarrow$，这样的位置$F_C$和$A\cap B$的bloom filters是一样的。</p>

<p>当$a\in A\wedge a\notin B$时，只要$\exists b\in B\wedge b\notin A,\exists i,j,1\leq i,j\leq k,s.t.\quad h_j(b)=h_i(a)$，且对于$A\cap B$中的元素没有哈希到$h_j(b)$这个位置，则$A\cap B$的bloom filters至少有一位和$F_A\wedge F_B$不同</p>

<h3 id="2">(2)</h3>

<p>记$a_i,b_i$分别是A和B的bloom filters产生的m个bit的第i位,a,b为A,B中元素</p>

<p>$相同的bit数 = \sum\limits_{i=1}^m I(a_i=b_i) \Rightarrow E[same]=\sum\limits_{i=1}^mPr[a_i=b_i]</p>

<p>$</p>

<p>$E[differ] = n - E[same]$</p>

<p>$Pr[a_i=b_i] = Pr[\exists p,q,h_p(a)=i\wedge h_q(b) = i] + Pr[\forall p,q,h_p(a)\neq i \wedge h_q(b)\neq i]$</p>

<p>$Pr[\exists p,q,h_p(a)=i\wedge h_q(b) = i]\</p>

<p>= Pr[\exists p,q,h_p(a)=i\wedge h_q(b)=i|a=b]Pr[a=b] + Pr[\exists p,q,h_p(a)\wedge h_q(b)=i|a\neq b]Pr[a\neq b]\</p>

<p>=(1-(1-\dfrac{1}{m})^k)\dfrac{|A\cap B|}{n^2} + (1-(1-\dfrac{1}{m})^k-(1-\dfrac{1}{m})^k+(1-\dfrac{1}{m})^{2k})(1-\dfrac{|A\cap B|}{n^2})$</p>

<p>$Pr[\forall p,q,h_p(a)\neq i \wedge h_q(b)\neq i]\</p>

<p>=Pr[\forall p,q,h_p(a)\neq i \wedge h_q(b)\neq i | a\neq b]Pr[a\neq b]+Pr[\forall p,q,h_p(a)\neq i \wedge h_q(b)\neq i|a\neq b]Pr[a\neq b]\</p>

<p>=(1-\dfrac{1}{m})^k\dfrac{|A\cap B|}{n^2}+(1-\dfrac{1}{m})^{2k}(1-\dfrac{|A\cap B|}{n^2})$</p>

<p>$Pr[a_i=b_i] = 2((1-\dfrac{1}{m})^k-(1-\dfrac{1}{m})^{2k})\dfrac{\|A\cap B\|}{n^2}+1-2(1-\dfrac{1}{m})^k+2(1-\dfrac{1}{m})^{2k}$</p>

<p>$E[differ] = n - n(2((1-\dfrac{1}{m})^k-(1-\dfrac{1}{m})^{2k})\dfrac{\|A\cap B\|}{n^2}+1-2(1-\dfrac{1}{m})^k+2(1-\dfrac{1}{m})^{2k})$</p>

<h2 id="第二题">第二题</h2>

<p>对于$\dfrac{n}{2}$个球,uniformly at random的期望为$\Theta(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}})$,two choice $\dfrac{n}{2}$的期望为$\Theta(\log\log \dfrac{n}{2})$，当某一半是uniformly at random的时候，期望则为uniformly at random的期望，因为 $\log\log\dfrac{n}{2} = o(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}}))$</p>

<h3 id="1-1">(1)</h3>

<p>前一半随机选择仍为$\Theta(\dfrac{\log n/2}{\log\log\dfrac{n}{2}})=\Theta(\dfrac{\log }{\log\log n})$</p>

<h3 id="2-1">(2)</h3>

<p>$\Theta(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}}) + \Theta(\log\log \dfrac{n}{2}) = \Theta(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}}) = \Theta(\dfrac{\log }{\log\log n})$</p>

<h3 id="3">(3)</h3>

<p>将一个随机选取和two choice视为一个操作，共有$\dfrac{n}{2}$个操作，记第i个盒子的球的个数为$X_i$</p>

<p>$Pr[\max\limits_{1\leq i\leq n} X_i \geq L] \leq nPr[X_1\geq L]$</p>

<p>$Pr[X_i \geq L] \leq \sum\limits_{i=0}^{L}\tbinom{m/2}{i}\dfrac{1}{n^i}\tbinom{m/2}{L-i}(1-(1-\dfrac{1}{n})(1-\dfrac{1}{n}))^{L-i})\(至少i个uniform的操作选择第一个bin，至少L-i个two choice中有一个选择了第一个bins)\</p>

<p>\leq \sum\limits_{i=0}^{L}\tbinom{m/2}{i}\tbinom{m/2}{L-i}\dfrac{1}{n^i}(\dfrac{2}{n})^{L-i}\</p>

<p>= 2\tbinom{m}{L}\dfrac{1}{n^L} (范德蒙德卷积,此时情形和上课讲的一样，略去细节)\</p>

<p>\leq 2\dfrac{m^L}{L!n^L}\</p>

<p>\leq 2\dfrac{e^Lm^L}{L^Ln^L}$</p>

<p>当$m=\Theta(n)$时有$存在c，L=\dfrac{c\log n}{\log\log n}$</p>

<p>$Pr[X_i\geq L] \leq (\dfrac{e}{L})^L\leq \dfrac{1}{n^2}$</p>

<p>所以最大值大于L的概率为$Pr[\max X_i \geq L] \leq \dfrac{1}{n},L=\dfrac{c\log n}{\log\log n}$</p>

<p>下界显然是随机选取$\dfrac{n}{2}$的下界$\Theta(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}}) = \Theta(\dfrac{\log n}{\log\log n})$，所以结果仍为$L=\Theta(\dfrac{\log n}{\log\log n})$</p>

<h2 id="第三题">第三题</h2>

<p>设$Y_i=I[(1-\epsilon)Z\leq \hat{Z_i}\leq (1+\epsilon)Z]$,$E[Y_i]\geq \dfrac{3}{4}$</p>

<p>$Y=\sum\limits_{i=1}^sY_i,\mu = E[Y]\geq \dfrac{3}{4}s$</p>

<p>当$Y\geq \dfrac{1}{2}s$时，${\hat{Z_i}}$的中位数X一定满足$(1-\epsilon)Z\leq X\leq (1+\epsilon)Z$</p>

<p>所以只要$Pr[(1-\epsilon)Z\leq X\leq (1+\epsilon)Z]\geq Pr[Y\geq \dfrac{1}{2}s]\geq 1-\delta$,即$\delta\geq Pr[Y\leq \dfrac{1}{2}s]$</p>

<p>只要$Pr[Y\leq \dfrac{1}{2}s]\leq Pr[\sum\limits_{i=1}^sT_i\leq (1-\dfrac{1}{3})\mu]\leq e^{-\dfrac{\mu/9}{2}}(chernoff bound)\leq e^{-\dfrac{s}{24}}$</p>

<p>即$e^{-\dfrac{s}{24}\leq \delta}\Rightarrow S\geq 24\ln \dfrac{1}{\delta},S=\Omega(\log \dfrac{1}{\delta})$</p>

<h2 id="第四题">第四题</h2>

<h3 id="1-2">(1)</h3>

<p>$Pr[\|X\|\geq \delta]\leq \dfrac{\sum\limits_{k=1}^{+\infty}\dfrac{t^k}{k!}E[\|X\|^k]}{\sum\limits_{k=1}^{+\infty}\dfrac{t^k}{k!}\delta^k}$</p>

<p>记$a_k = \dfrac{t^k}{k!}E[\|X\|^k],b_k = \dfrac{t^k}{k!}\delta^k$</p>

<p>$m=\mathop{argmin}\limits_{k}\dfrac{a_k}{b_k},c = \dfrac{a_k}{b_k}$</p>

<p>$\forall i\in N,\dfrac{a_i}{b_i}\geq c\Rightarrow a_i\geq cb_i$</p>

<p>得到$\dfrac{\sum\limits_{k=1}^{+\infty}\dfrac{t^k}{k!}E[\</p>

<p>|X\|^k]}{\sum\limits_{k=1}^{+\infty}\dfrac{t^k}{k!}\delta^k} \geq \dfrac{\sum\limits_{i=1}^{+\infty}cb_i}{\sum\limits_{i=1}^{+\infty}b_i}= c = \dfrac{a_m}{b_m}=\dfrac{E[\|X\|^k]}{\delta^k}$</p>

<p>所以一定存在k阶矩强于chernoff bound</p>

<h3 id="2-2">(2)</h3>

<p>矩阵生成函数容易计算，而特定的k阶矩难以找到</p>

<h2 id="第五题">第五题</h2>

<h3 id="1-3">(1)</h3>

<p>记$h_k=\prod\limits_{i=1}^{k}f_i(X_i)$，显然$h_k$不减</p>

<p>$E[h_n]=E[h_{n-1}\cdot f_n(X_n)]\leq E[h_{n-1}]E[f_n(X_n)]]\leq ……\leq \prod\limits_{i=1}^{k}E[f_i(x_i)]$</p>

<h3 id="2-3">(2)</h3>

<p>$X=\sum\limits_{i=1}^nX_i,E[x]=\mu$</p>

<p>$Pr[X\geq (1+\delta)\mu]\leq Pr[e^{\lambda X}\geq e^{(1+\delta)\mu\lambda}]\leq \dfrac{E[e^{\lambda X}]}{e^{\lambda(1+\delta)\mu}}\leq \dfrac{\prod\limits_{i=1}^nE[e^{\lambda X_i}]}{e^{\lambda(1+\delta)\mu}}$,其余和独立的情形一致，$Pr[X\geq (1+\delta)\mu]\leq \dfrac{e^{(e^{(\lambda-1)\mu})}}{e^{\lambda(1+\delta)\mu}}$</p>

<p>$Pr[X\leq (1-\delta)\mu]\leq Pr[e^{\lambda X}\geq e^{(1-\delta)\mu\lambda}]\leq \dfrac{E[e^{\lambda X}]}{e^{\lambda(1-\delta)\mu}},(\lambda &lt; 0)$,应用后面提到的性质，$X_i$是负相关的$f=e^{\lambda X_i},\lambda &lt; 0$单调递减，满足性质Disjoint monotone aggregation，有$E[e^{\lambda X}]\leq \prod\limits_{i=1}^nE[e^{\lambda X_i}]$,则$Pr[X\leq (1-\delta)\mu]\leq \dfrac{\prod\limits_{i=1}^nE[e^{\lambda X_i}]}{e^{\lambda(1-\delta)\mu}}$,其余和独立的情形一致，$Pr[X\leq (1-\delta)\mu]\leq \dfrac{e^{(e^{(\lambda-1)\mu})}}{e^{\lambda(1-\delta)\mu}}$</p>

<p>Qed.</p>

<h3 id="3-1">(3)</h3>

<p>记$p=\|I\|,q=\|J\|$,记$X_i\in I,X_{i_1},X_{i_2},…,X_{i_p}$,记$X_j\in J,X_{j_1},X_{j_2},…,X_{j_q}$.$I$和$J$对应将$B_{i,k}$划分后的集合</p>

<p>注意到$\sum\limits_{i=1}^nB_{i,k}=1$有且仅有一个为1.</p>

<p>当$X_{i_m}=1$时，其余$X_{i_k},X_{j_k},k\neq m$均为0.</p>

<p>记$f(X_i,i\in I)$为$f_m，其中X_{i_m}=1,f_0表示X_{i_k}均为0,\forall 1\leq k\leq p$，</p>

<p>同理有$g_m$的定义,记$f(X_j,j\in J)$为$g_m，其中X_{j_m}=1,g_0表示X_{j_k}均为0,\forall 1\leq k\leq q$.</p>

<p>记$A=\sum\limits_{m=1}^{\|I\|}f_m,B=\sum\limits_{m=1}^{\|J\|}g_m$</p>

<p>$S_1 = E[f(X_i,i\in I)g(X_j,j\in J)] = \dfrac{1}{n}g_0A+\dfrac{1}{n}f_0B+\dfrac{n-\|I\|-\|J\|}{n}f_0g_0$</p>

<p>$S_2=E[f(X_i)]E[g(X_j)]=(\dfrac{1}{n}A+(1-\dfrac{p}{n})f_0)(\dfrac{1}{n}B+(1-\dfrac{q}{n})f_0)\</p>

<p>=\dfrac{1}{n^2}AB+\dfrac{1}{n}g_0A-\dfrac{q}{n^2}g_0A+\dfrac{1}{n}f_0B-\dfrac{p}{n^2}f_0B+f_0g_0(\dfrac{n-p-q}{n}+\dfrac{pq}{n^2})\</p>

<p>=S_1 + \dfrac{1}{n^2}(AB-qg_0A-pf_0B+pqf_0g_0)\</p>

<p>=S_1+\dfrac{1}{n^2}(A-pf_0)(B-qg_0)$</p>

<p>由于$f$是非减函数，所以$\dfrac{1}{n^2}(A-pf_0)(B-qg_0) \geq 0\Rightarrow S_1\leq S_2$,Qed.</p>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="Courses" /><summary type="html"><![CDATA[高级算法作业]]></summary></entry><entry><title type="html">数据库期末复习</title><link href="http://localhost:4000/ppx123-web/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/" rel="alternate" type="text/html" title="数据库期末复习" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/"><![CDATA[<blockquote>
  <p>主体来自于Maxwell：https://maxwell-lyu.github.io/，在其基础上简单修改</p>
</blockquote>

<h1 class="no_toc" id="list">List</h1>
<ol id="markdown-toc">
  <li><a href="#数据库概论期末复习" id="markdown-toc-数据库概论期末复习">数据库概论期末复习</a>    <ol>
      <li><a href="#样卷总结" id="markdown-toc-样卷总结">样卷总结</a>        <ol>
          <li><a href="#大题" id="markdown-toc-大题">大题</a></li>
        </ol>
      </li>
      <li><a href="#证明" id="markdown-toc-证明">证明：</a>        <ol>
          <li><a href="#冲突冲突可串行化冲突可串行化的判定定理-证明" id="markdown-toc-冲突冲突可串行化冲突可串行化的判定定理-证明">冲突，冲突可串行化，冲突可串行化的判定定理 证明：</a></li>
          <li><a href="#两阶段封锁协议与冲突可串行化的关系证明" id="markdown-toc-两阶段封锁协议与冲突可串行化的关系证明">两阶段封锁协议与冲突可串行化的关系证明：</a></li>
          <li><a href="#bcnf-3nf的证明" id="markdown-toc-bcnf-3nf的证明">BCNF-&gt;3NF的证明</a></li>
          <li><a href="#4nf与bcnf-证明" id="markdown-toc-4nf与bcnf-证明">4NF与BCNF 证明</a></li>
          <li><a href="#关系模型概念" id="markdown-toc-关系模型概念">关系模型（概念）</a></li>
          <li><a href="#关系的表示" id="markdown-toc-关系的表示">关系的表示</a></li>
          <li><a href="#关系模型与关系代数" id="markdown-toc-关系模型与关系代数">关系模型与关系代数</a></li>
          <li><a href="#关系代数中的扩充运算" id="markdown-toc-关系代数中的扩充运算">关系代数中的扩充运算</a></li>
          <li><a href="#关系代数的应用" id="markdown-toc-关系代数的应用">关系代数的应用</a></li>
          <li><a href="#关系演算" id="markdown-toc-关系演算">关系演算</a></li>
          <li><a href="#sql概貌" id="markdown-toc-sql概貌">SQL概貌</a></li>
          <li><a href="#sql数据定义功能" id="markdown-toc-sql数据定义功能">SQL数据定义功能</a></li>
          <li><a href="#sql数据操纵功能" id="markdown-toc-sql数据操纵功能">SQL数据操纵功能</a></li>
          <li><a href="#sql的更新功能" id="markdown-toc-sql的更新功能">SQL的更新功能</a></li>
          <li><a href="#视图" id="markdown-toc-视图">视图</a></li>
          <li><a href="#函数依赖fd" id="markdown-toc-函数依赖fd">函数依赖（FD）</a></li>
          <li><a href="#与函数依赖有关的范式" id="markdown-toc-与函数依赖有关的范式">与函数依赖有关的范式</a></li>
          <li><a href="#多值依赖与第四范式" id="markdown-toc-多值依赖与第四范式">多值依赖与第四范式</a></li>
          <li><a href="#关系代数" id="markdown-toc-关系代数">关系代数</a></li>
          <li><a href="#关系演算-1" id="markdown-toc-关系演算-1">关系演算</a></li>
          <li><a href="#函数依赖" id="markdown-toc-函数依赖">函数依赖</a></li>
          <li><a href="#能不能冲突串行" id="markdown-toc-能不能冲突串行">能不能冲突串行</a></li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h1 id="数据库概论期末复习">数据库概论期末复习</h1>

<h2 id="样卷总结">样卷总结</h2>

<h3 id="大题">大题</h3>

<p>关系代数与关系演算</p>

<p>SQL语言</p>

<p>关系规范化</p>

<p>数据库设计</p>

<p>事务处理</p>

<h2 id="证明">证明：</h2>

<h3 id="冲突冲突可串行化冲突可串行化的判定定理-证明">冲突，冲突可串行化，冲突可串行化的判定定理 证明：</h3>

<p>如果调度S的事务优先图中无环，则S是冲突可串行化调度。</p>

<p>归纳法：k-1时成立，k时，考虑没有入边的事务$T_i$，则$T_i$可非冲突交换到调度最前面，$T_i$，其他k-1个事务，由归纳假设Qed</p>

<p>如果调度S的事务优先图中有环，则S不是冲突可串行化调度。</p>

<p>反证法：假设存在一个冲突可串行化调度，冲突等价于串行调度$S={T_1,T_2,…,T_n}$，根据事务优先图$T_1$先于$T_2$,$T_2$先于$T_3$，$T_{n-1}$先于$T_n$，$T_n$先于$T_1$，产生矛盾</p>

<h3 id="两阶段封锁协议与冲突可串行化的关系证明">两阶段封锁协议与冲突可串行化的关系证明：</h3>

<p>归纳法：</p>

<p>k-1时成立，考虑k时，考虑第一个有解锁动作的事务$T_i$，则$T_i$可以冲突等价于$T_i$，和其他剩下的事务，后面k-1由归纳假设，也冲突等价于一个串行化调度，Qed</p>

<h3 id="bcnf-3nf的证明">BCNF-&gt;3NF的证明</h3>

<p>$R\in BCNF$,$R\notin 3NF$有三种情况</p>

<p>$R\notin 1NF$,显然不成立</p>

<p>$R\notin 2NF$,非主属性A部分依赖关键字$K\overset{p}{\to}A，W\overset{f}{\to}A,W\subset K$,则由BCNF，$W$包含关键字$K^{‘}\subset K$矛盾</p>

<p>$R\notin 3NF$,有传递函数依赖</p>

<h3 id="4nf与bcnf-证明">4NF与BCNF 证明</h3>

<p>4NF：函数依赖满足BCNF</p>

<p>不是函数依赖的多值依赖：只允许出现平凡多值依赖</p>

<p>第一章:数据库系统概述</p>

<p>===========================================================================================================================================================================================</p>

<p>基本概念</p>

<hr />

<ul>
  <li>
    <p><strong>数据库</strong>(DB): 是数据集合, 具有统一的结构形式并存放于统一的存储介质内, 它由多种应用数据集成, 并可被应用所共享</p>
  </li>
  <li>
    <p><strong>数据库管理系统</strong>(DBMS): 是管理数据库的系统软件</p>
  </li>
  <li>
    <p><strong>数据库系统</strong>(DBS): 是一个以对海量的、具有复杂数据结构的、可以持久保存的、可供多用户共享的数据进行统一管理为目标的计算机系统</p>
  </li>
  <li>
    <p><strong>数据库管理员</strong>(DBA): 对数据库进行规划、设计、维护、监视的专职人员</p>
  </li>
  <li>
    <p>相互之间的关系</p>
  </li>
</ul>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /></pre></td><td class="code"><pre><span class="line">数据库应用系统---+-[数据库系统]---+-[数据库] &lt;------------+---------------+</span><br /><span class="line">         |        |            |        |</span><br /><span class="line">         +-应用软件    +-[数据库管理系统] : 管理        |</span><br /><span class="line">         |        |                    |</span><br /><span class="line">         +-应用界面    +-[数据库管理员] : 规划, 设计, 维护, 监视</span><br /><span class="line">         |        |</span><br /><span class="line">         +-数据库用户   +-软件平台</span><br /><span class="line">                 |</span><br /><span class="line">                 +-硬件平台</span><br /></pre></td></tr></tbody></table>

<p>数据库系统的特点</p>

<hr />

<ul>
  <li>
    <p>数据<strong>集成化</strong>: 统一的数据结构/数据模式</p>
  </li>
  <li>
    <p>数据<strong>独立性</strong>: 数据或数据结构(物理, 逻辑) &lt;–&gt; 应用程序</p>
  </li>
  <li>
    <p>数据<strong>共享性</strong>: 高</p>
  </li>
  <li>
    <p>数据<strong>冗余性</strong>: 低</p>
  </li>
  <li>
    <p>数据的<strong>安全性，完整性和一致性</strong></p>
  </li>
  <li>
    <p><strong>并发控制和故障恢复</strong></p>
  </li>
</ul>

<p>数据库内部结构体系</p>

<hr />

<ul>
  <li>
    <p><strong>数据模式</strong>: 数据库中数据结构的具体表示与描述</p>
  </li>
  <li>
    <p>三级模式</p>
  </li>
  <li>
    <p><strong>概念模式</strong>: 整个数据库中数据的全局逻辑结构 -&gt; 概念数据库</p>
  </li>
  <li>
    <p><strong>外模式</strong>: 某个用户所需数据的逻辑结构 -&gt; 用户数据库</p>
  </li>
  <li>
    <p><strong>内模式</strong>: 物理存储结构和物理存取方法 -&gt; 物理数据库</p>
  </li>
  <li>
    <p>二级映射</p>
  </li>
  <li>
    <p><strong>概念-&gt;内</strong>: 全局逻辑结构 -&gt; 数据的物理存储结构</p>
  </li>
  <li>
    <p><strong>外-&gt;概念</strong>: 多个外模式 -&gt; 一个概念模式, 而每个外模式是概念模式的一个基本视图</p>
  </li>
  <li>
    <p>三级模式与数据独立性的关系</p>
  </li>
  <li>
    <p>概念-&gt;内: <strong>物理独立性</strong></p>
  </li>
  <li>
    <p>外-&gt;概念: <strong>逻辑独立性</strong></p>
  </li>
</ul>

<p>第二章:数据模型</p>

<p>==========================================================================================================================================================</p>

<p>数据模型的基本概念</p>

<hr />

<ul>
  <li>
    <p><strong>数据模型</strong>: 数据基本特征的抽象</p>
  </li>
  <li>
    <p>描述<strong>数据结构</strong>: 数据的类型, 内容, 性质, 数据间联系</p>
  </li>
  <li>
    <p>定义<strong>数据操作</strong>: 操作的类型, 方式</p>
  </li>
  <li>
    <p>定义<strong>数据约束</strong>: 数据间的相互关系: 语法语义联系, 制约与依存, 动态变化规则</p>
  </li>
  <li>
    <p>数据模型的<strong>核心</strong>: 数据结构</p>
  </li>
  <li>
    <p>不同类型数据模型的<strong>区分依据</strong>: 应用层次</p>
  </li>
  <li>
    <p>三个抽象层次</p>
  </li>
  <li>
    <p><strong>概念数据模型</strong>: 面向客观世界, 面向用户; 客观对象的数据特征及相互关系</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; E-R模型, EE-R模型; 面向对象模型; 谓词模型
</code></pre></div></div>

<ul>
  <li><strong>逻辑数据模型</strong>: 面向数据库系统; 事物及关系在选定的DBMS中的实现结构</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 层次, 网状模型; 关系, 面向对象, 谓词模型; 对象关系模型
</code></pre></div></div>

<ul>
  <li><strong>物理数据模型</strong>: 面向计算机物理表示; 数据模型的物理表示</li>
</ul>

<p>数据模型的四个世界</p>

<hr />

<ul>
  <li>
    <p><strong>现实世界</strong>: 客观世界中的应用环境</p>
  </li>
  <li>
    <p><strong>概念世界</strong>: 基于现实世界, 进一步的抽象而形成</p>
  </li>
  <li>
    <p><strong>信息世界</strong>: 基于概念世界, 用特定的DBMS构造而成的逻辑数据模型</p>
  </li>
  <li>
    <p><strong>计算机世界</strong>: 逻辑数据模型在计算机中的物理实现</p>
  </li>
</ul>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /></pre></td><td class="code"><pre><span class="line">现实世界              用户1  ...  用户n</span><br /><span class="line"> |                 |       |</span><br /><span class="line">概念世界------&gt;概念模型       |       |   </span><br /><span class="line"> |       |          |       |</span><br /><span class="line"> |       |      +---&gt;外模式1  ... 外模式n   </span><br /><span class="line">信息世界------&gt;逻辑模型-------|   |       |</span><br /><span class="line"> |       |      +---&gt;概念模式---------+</span><br /><span class="line"> |       |          | </span><br /><span class="line">计算机世界----&gt;物理模型-----------&gt;内模式</span><br /></pre></td></tr></tbody></table>

<p>概念世界与概念模型</p>

<hr />

<ul>
  <li>
    <p>E-R模型与E-R图（包括扩充E-R模型）</p>
  </li>
  <li>
    <p>实体: 客观存在且又能相互区别的事物</p>
  </li>
  <li>
    <p>属性: 实体所具有的某种特性或特征</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  多值属性: 一个实体, 多个取值(例如爱好, 可有多个)

*  组合属性: 一个性质, 多个属性(名字 &lt;-&gt; 姓, 名, 中间名)
</code></pre></div></div>

<ul>
  <li>
    <p>联系: 不同实体集中, 实体间的对应关系</p>
  </li>
  <li>
    <p>联系上的函数对应关系: 一一, 一多/多一, 多多</p>
  </li>
  <li>
    <p>参与方式</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  参与方式标一个数, 参与基数标范围

*  考虑一个实体e, 在关系R的函数对应关系中, 有x条线与他相连, 则其参与基数为x

*  考虑实体集E, min-card(E,R): 其中实体参与基数最小值, max-card(E,R)同理
</code></pre></div></div>

<ul>
  <li>
    <p>IS-A联系: 实体间可以有继承关系，由子集指向超集</p>
  </li>
  <li>
    <p>弱实体: 依赖于其他某个实体, 多个弱实体依赖一个实体, 从弱实体到依赖联系的有向箭头</p>
  </li>
  <li>
    <p>面向对象模型</p>
  </li>
  <li>
    <p>对象: 客观世界中能够相互区别开来的事物</p>
  </li>
  <li>
    <p>对象标识符: OID: 每对象有仅有一个, 用以相互区别</p>
  </li>
  <li>
    <p>类: 具有相同属性, 方法的对象集合</p>
  </li>
  <li>
    <p>方法: 施加在对象上的程序, 可审视或改变属性值</p>
  </li>
  <li>
    <p>超类和子类: 类的子集叫做子类, 原来的类叫做超类</p>
  </li>
  <li>
    <p>聚合: 若干个简单类聚合成一个复杂的类的过程</p>
  </li>
  <li>
    <p>分解: 复杂类分解成若干层次上的简单类的过程</p>
  </li>
  <li>
    <p>继承: (超类与子类)单向不循环的层次结构, 共享实现和定义</p>
  </li>
  <li>
    <p>合成: (聚合与分解)</p>
  </li>
</ul>

<p>信息世界和逻辑模型</p>

<hr />

<ul>
  <li>
    <p>关系模型</p>
  </li>
  <li>
    <p>关系: 由行和列组成的二维表格(表框架 + 元组*n)</p>
  </li>
  <li>
    <p>属性: 表框架中的每一列</p>
  </li>
  <li>
    <p>值域(域): 元组在某一属性下的取值范围</p>
  </li>
  <li>
    <p>元组: 关系中的每一行</p>
  </li>
  <li>
    <p>关系模式：一个关系的关系名及其属性名的集合构成该关系 的关系模式</p>
  </li>
  <li>
    <p>关系数据库模式: 该关系数据库中所有关系的关系模式的集合</p>
  </li>
  <li>
    <p>关键字: 能唯一标识关系中的一个元组, 且又不含多余的属性值的属性集，（一个关系可以有多个关键字）关键字也被称为候选关键字</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  主关键字：可以从关系的候选关键字中选取一个作为该关系 的主关键字

*  外关键字：设关系R中的属性集F，其取值来自于关系S中的主关键字K，则称属性集F是关系R的外关键字。（S和R可以是同一个关系）
</code></pre></div></div>

<p>计算机世界与物理模型</p>

<hr />

<ul>
  <li>
    <p>逻辑模型的物理存储</p>
  </li>
  <li>
    <p>项: 文件系统中最小基本单位, 项内符号是不能继续分割</p>
  </li>
  <li>
    <p>记录: 由若干项组成, 有内在语义联系</p>
  </li>
  <li>
    <p>文件: 记录的集合</p>
  </li>
  <li>
    <p>提高文件访问效率的常用方法</p>
  </li>
  <li>
    <p>索引: 将文件中的记录与其物理地址(即磁盘块)间建立一张对应关系表</p>
  </li>
  <li>
    <p>集簇: 将具有相同或相邻项值的记录聚集在相同磁盘块内或圆柱体内以减少读盘次数</p>
  </li>
  <li>
    <p>HASH: 通过一个hash函数, 将要查找的记录转换成该记录所在的物理地址</p>
  </li>
</ul>

<p>第三章:关系数据库系统</p>

<p>===========================================================================================================================================================================================</p>

<p>关系数据库系统概述</p>

<hr />

<p>关系数据库系统的衡量准则</p>

<hr />

<ul>
  <li>完全关系型的十二条衡量准则</li>
</ul>

<ol>
  <li>信息准则: 逻辑一级</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  所有信息 -&gt; 表中的值, 唯一且显式地表示

*  结构描述信息 -&gt; 组织成关系形式
</code></pre></div></div>

<ol>
  <li>确保访问准则</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  表名+关键字值+列名 -&gt; 访问到每一个原子数据
</code></pre></div></div>

<ol>
  <li>空值的关系处理准则</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  空值: 无意义/当前未知

*  系统应当可以处理有空值参与的: 比较运算, 表达式运算, 统计运算
</code></pre></div></div>

<ol>
  <li>基于资源管理的动态联机目录</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  数据库的描述信息(数据字典) 与 用户数据 有 相同的表示形式和操作方式

*  被授权用户可对 数据库的描述信息 进行 查询与扩充
</code></pre></div></div>

<ol>
  <li>统一易用的数据子语言: 至少一种子语言支持以下功能</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  数据定义

*  视图(view)定义

*  数据操纵

*  完整性约束能力

*  授权机制

*  事务处理能力
</code></pre></div></div>

<ol>
  <li>
    <p>视图更新准则: 视图除查询外, 还可增加, 删除, 修改数据</p>
  </li>
  <li>
    <p>高级的插入、删除及修改操作: 一条命令可以插入、删除及修改操作多条元组</p>
  </li>
  <li>
    <p>物理数据独立性</p>
  </li>
  <li>
    <p>逻辑数据独立性</p>
  </li>
  <li>
    <p>数据完整性准则: 提供三类数据完整性约束的定义功能</p>
  </li>
  <li>
    <p>分布独立性: 数据分布的改变不影响原有的应用程序</p>
  </li>
  <li>
    <p>无损害原则: 对提供低级数据子语言的要求</p>
  </li>
</ol>

<ul>
  <li>空值（NULL）的定义: 无意义/当前未知的值</li>
</ul>

<p>关系模型数学理论—关系代数</p>

<hr />

<h3 id="关系模型概念">关系模型（概念）</h3>

<ul>
  <li>
    <p>关系数据结构</p>
  </li>
  <li>
    <p>表结构（表头）:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  表框架: 属性组成表框架

*  表的元数: n个属性&lt;-&gt;表的元数

*  表的基数: m个元组&lt;-&gt;表的基数
</code></pre></div></div>

<ul>
  <li>关系：关系的性质</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  元组: 个数有限, 唯一, 次序无关, 分量原子性, 分量值域同一

*  属性: 名称唯一, 次序无关
</code></pre></div></div>

<ul>
  <li>关键字：候选关键字，主关键字，外关键字</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  关键字: 唯一最小标识元组的属性集, 每张表至少一个

*  主关键字: 被选中的关键字

*  superkey: 可以唯一确定一个元组的属性的集合

*  候选关键字: 一个关系中可以有多个关键字，都是候选关键字

*  外关键字: 如果表A中的属性集F是表B的关键字, 则称该属性集F为表A的外关键字
</code></pre></div></div>

<ul>
  <li>
    <p>关系数据库：关系子模式-视图（view）</p>
  </li>
  <li>
    <p>关系操纵</p>
  </li>
  <li>
    <p>数据查询：步骤</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  两个关系的合并: 有多张表, 先合并为单个关系

*  单个关系内的元组选择: 选择符合条件的元组(行指定)

*  单个关系内的属性指定: 执行属性(列指定)
</code></pre></div></div>

<ul>
  <li>元组: 单个关系内的操作</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  删除: 确定被删除的元组-&gt;执行删除

*  插入: 添加元组

*  修改: 删旧-&gt;插新
</code></pre></div></div>

<ul>
  <li>空值的处理</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  主键不允许空值

*  算数表达式: 含空值, 结果为空值

*  逻辑表达式: 含空值, 结果为false

*  统计计算: 空值不计入(视而不见)
</code></pre></div></div>

<ul>
  <li>
    <p>关系中的数据约束</p>
  </li>
  <li>
    <p>实体完整性约束: 主关键字属性不为空值</p>
  </li>
  <li>
    <p>参照完整性约束: 外键要么取空值, 要么是被引用表中的主键值</p>
  </li>
  <li>
    <p>用户定义的完整性: 用户自己定义的属性取值约束</p>
  </li>
</ul>

<h3 id="关系的表示">关系的表示</h3>

<ul>
  <li>关系的表示</li>
</ul>

<p>设属性域为$D_1,D_2,⋯,D_n$</p>

<p>关系$R\subseteq D_1\times D_2\times \cdots \times D_n$</p>

<ul>
  <li>迪卡尔乘积</li>
</ul>

<p>$D_1,D_2,\cdots,D_n$是$n$个集合</p>

<p>$D_1\times D_2\times\cdots\times D_n={(d_1,d_2,\cdots,d_n):d_i\in D_i,i\in (1,2,\cdots,n)}$</p>

<table>
  <tbody>
    <tr>
      <td>$</td>
      <td>D_1\times D_2\times \cdots\times D_n</td>
      <td>=\prod\limits_{i=1}^{n}</td>
      <td>D_i</td>
      <td>$</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>关系代数中的五种基本运算：选择，投影，笛卡儿积，并，差（请注意每个运算符的执行条件和结果关系的关系模式）</p>
  </li>
  <li>
    <p>投影运算: $\pi_A(R)$</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  略去某些列, 重排剩余列的次序

  关系R有属性$\{A_1,A_2, \cdots, A_n\}$, 在其中$m$个属性上的投影运算如下

  $\pi_{B_1, B_2, \cdots, B_n}(R), B_i\in\{A_1,A_2, \cdots, A_n\}$

*  注意消除可能出现的重复元组
</code></pre></div></div>

<ul>
  <li>选择运算: $\sigma_F(R)$</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  关系模式不变, 由属于$R$且满足条件$F$的元组构成
</code></pre></div></div>

<ul>
  <li>笛卡尔乘积 - 关系的合并: 交换律, 结合律</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  若有相同的属性名, 必须在结果关系中对其中一个换名

  注意：交运算: 同类关系

*  用$R\cap S = R-(R-S)$代替, 不是基本运算
</code></pre></div></div>

<ul>
  <li>并运算: $R\cup S$同类关系</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  关系模式不变, 属于$R$或者$S$
</code></pre></div></div>

<ul>
  <li>差运算: $R-S$同类关系</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  关系模式不变, 属于$R$且不属于$S$
</code></pre></div></div>

<ul>
  <li>
    <p>基本运算的应用</p>
  </li>
  <li>
    <p>插入: $R^*=R\cup R_{new}$</p>
  </li>
  <li>
    <p>删除: $R^* = R-R_{old}$</p>
  </li>
  <li>
    <p>修改: $R^* = (R-R_{old})\cup R_{new}$</p>
  </li>
  <li>
    <p>查询: $\pi_A(\sigma_B(R))$简写为$\pi_A\sigma_B(R)$: 不能交换位置</p>
  </li>
</ul>

<h3 id="关系模型与关系代数">关系模型与关系代数</h3>

<ul>
  <li>
    <p>关系: n元有序组的集合</p>
  </li>
  <li>
    <p>关系操纵: 关系上的集合运算</p>
  </li>
  <li>
    <p>关系代数: 关系集合AAA及5种基运算构成的代数</p>
  </li>
  <li>
    <p>关系模型</p>
  </li>
  <li>
    <p>关系模型的数据结构</p>
  </li>
  <li>
    <p>关系模型上的数据操纵</p>
  </li>
  <li>
    <p>关系模型上的数据约束</p>
  </li>
</ul>

<h3 id="关系代数中的扩充运算">关系代数中的扩充运算</h3>

<ul>
  <li>
    <p>交运算: 同类关系</p>
  </li>
  <li>
    <p>$R\cap S = R-(R-S)$</p>
  </li>
  <li>
    <p>关系模式不变, 既属于R也属于S的元组组成的集合</p>
  </li>
  <li>
    <p>除运算:$\textrm{Head}(S)\subset \textrm{Head}(R)$</p>
  </li>
  <li>
    <p>关系模式:$\textrm{Head}(T)=\textrm{Head}(R) - textrm{Head}(S)$</p>
  </li>
  <li>
    <p>设$x\in T$, 则$\forall y\in S$, $(x,y)\in R$, 所有满足条件的$x$构成结果</p>
  </li>
  <li>
    <p>如果$R=Ttimes S$, 则$T=R\div S, S=R\div T$; 如果T=R\div S, 则$T\times S\subseteq R$</p>
  </li>
  <li>
    <p>联接运算</p>
  </li>
  <li>
    <p>根据联接条件合并: $R\mathop\bowtie\limits_F S=\sigma_F(R\times S)$</p>
  </li>
  <li>
    <p>自然联接: $R\bowtie S$所有同名属性上的取值都一样, 就联接元组, 同名属性保留一份</p>
  </li>
  <li>
    <p>外联接: 有”外”的一侧, 其所有元组均出现, 另一侧无匹配元组就用null代替</p>
  </li>
  <li>
    <p>扩充运算与基本运算之间的关系</p>
  </li>
  <li>
    <p>交: 可由差运算实现: $R\cap S=R-(R-S)=S-(S-R)$</p>
  </li>
  <li>
    <p>除:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  $\textrm{Head}(R) = \{A_1, \cdots, A_n, B_1, \cdots, B_m\}$

*  ${Head}(S) = {B_1, \cdots, B_m}$

*  $R\div S=\pi_{A_1,\cdots A_n}(R)-\pi_{A_1,\cdots A_n}((\pi_{A_1,\cdots A_n}(R)\times S)-R)$
</code></pre></div></div>

<ul>
  <li>扩充运算的应用实例</li>
</ul>

<h3 id="关系代数的应用">关系代数的应用</h3>

<blockquote>
  <p>写在后面的大题部分</p>
</blockquote>

<blockquote>

</blockquote>

<blockquote>
  <ul>
    <li>综合的关系代数应用表示，复杂查询的关系代数表达式</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>关系代数的应用</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>单个关系上的选择与投影</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>两个关系的并、交、差</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>两个关系的迪卡尔乘积、自然联接、θ-联接</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>两个关系的除法</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>难点</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>查询条件带有‘否定’语义：‘不等’比较 &amp; 减法运算</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>使用表联接查询，还是使用除法?</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>正确使用自然连接运算 和 除法运算</li>
  </ul>
</blockquote>

<blockquote>
  <ul>
    <li>表的自联接</li>
  </ul>
</blockquote>

<h3 id="关系演算">关系演算</h3>

<ul>
  <li>
    <p>原子公式</p>
  </li>
  <li>
    <p>谓词是原子公式</p>
  </li>
  <li>
    <p>$u(i) \theta v(j)$是原子公式, 其中$u(i), v(j)$是元组中属性的值, $\theta$是比较运算符</p>
  </li>
  <li>
    <p>$u(i) \theta a$是原子公式, 其中$a$是常量</p>
  </li>
  <li>
    <p>公式的定义: 以下三种方式, 有限次数组合构成</p>
  </li>
  <li>
    <p>原子公式是公式</p>
  </li>
  <li>
    <p>公式的与, 或, 蕴含, 非 均为公式</p>
  </li>
  <li>
    <p>量词约束一个公式, 构成新公式</p>
  </li>
  <li>
    <p>基于关系演算的数据查询表示</p>
  </li>
  <li>
    <p>投影</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$\pi_{A_{1},A_{2},\cdots,A_{k}}(R)=\exists x_{k+1},x_{k+2},\cdots ,x_n(R(x_1,x_2,\cdots,x_n))$
</code></pre></div></div>

<ul>
  <li>选择</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$\sigma_F(R)=R(x_1,x_2,\cdots,x_n)\wedge F$

*  相等比较可以直接用常量代替: $\sigma_{x_1=’a’}(R)=R('a’,x_2,\cdots,x_n)\wedge F$
</code></pre></div></div>

<ul>
  <li>笛卡尔积</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\times S = R(p)\wedge S(q)$
</code></pre></div></div>

<ul>
  <li>$\theta$-联接</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\underset{F}{\bowtie} S = R(p)\wedge S(q)\wedge F$
</code></pre></div></div>

<ul>
  <li>自然联接</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\bowtie S = R(x,y,z)\wedge S(t,u,v)$
</code></pre></div></div>

<ul>
  <li>自联接, 重命名</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R(x, g_1)\wedge R(x, g_2)$
</code></pre></div></div>

<ul>
  <li>除法</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\div S=\forall y(S(y)\rightarrow R(x,y))$
</code></pre></div></div>

<ul>
  <li>删除</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R-S = R(u)\wedge \neg S(u)$
</code></pre></div></div>

<ul>
  <li>插入</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\cup S = R(t)\vee S(t)$
</code></pre></div></div>

<ul>
  <li>
    <p>修改 = 删除再插入</p>
  </li>
  <li>
    <p>公式的表示</p>
  </li>
  <li>
    <p>$\phi_1\wedge\phi_2$</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  有公共变元, 等价于自然联接$R_1\bowtie R_2$

*  无公共变元, 等价于笛卡尔乘积$R_1\times R_2$
</code></pre></div></div>

<ul>
  <li>
    <p>$\phi_1\vee\phi_2: R_1\cup R_2$</p>
  </li>
  <li>
    <p>$\phi_1\rightarrow\phi_2$: $R_2\div R_1$</p>
  </li>
  <li>
    <p>$\neg\phi: (\prod^nD_i)-R, D_i$为第$i$个自由变元的值域</p>
  </li>
  <li>
    <p>$\exists r(\phi)$: $\pi_{A_1,A_2,\cdots,A_k}(R)$</p>
  </li>
  <li>
    <p>$\forall r(\phi):R\div S$</p>
  </li>
</ul>

<p>关系数据库语言SQL’92</p>

<hr />

<h3 id="sql概貌">SQL概貌</h3>

<ul>
  <li>
    <p>SQL的基本概念: 结构化查询语言</p>
  </li>
  <li>
    <p>使用方式</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  自含式: 独立的交互式命令行语言

*  嵌入式: 嵌入到某种高级语言当中
</code></pre></div></div>

<ul>
  <li>
    <p>基表: 关系</p>
  </li>
  <li>
    <p>虚表(视图): 关系子模式</p>
  </li>
  <li>
    <p>行: 元组</p>
  </li>
  <li>
    <p>列: 属性</p>
  </li>
</ul>

<h3 id="sql数据定义功能">SQL数据定义功能</h3>

<blockquote>
  <p>啥也没有?怎么回事啊, 算了写一点乱七八糟的吧</p>
</blockquote>

<blockquote>

</blockquote>

<blockquote>
  <ul>
    <li>创建基表</li>
  </ul>
</blockquote>

<blockquote>

</blockquote>

<blockquote>
  <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tabname {</span><br /><span class="line"> colname datatype <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br /><span class="line"> colname2 datatype2</span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table>
</blockquote>

<blockquote>

</blockquote>

<ul>
  <li>修改基表</li>
</ul>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="keyword">ADD</span> colname datatype</span><br /><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="keyword">DROP</span> colname</span><br /></pre></td></tr></tbody></table>

<ul>
  <li>删除基表</li>
</ul>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tabname</span><br /></pre></td></tr></tbody></table>

<h3 id="sql数据操纵功能">SQL数据操纵功能</h3>

<ul>
  <li>
    <p>SQL语言与关系代数的关系</p>
  </li>
  <li>
    <p>映像语句（select statement）的结构</p>
  </li>
  <li>
    <p>目标子句: <code class="language-plaintext highlighter-rouge">SELECT * | colname { , colname ... }</code></p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 最后执行, 有排序时倒数第二执行
</code></pre></div></div>

<ul>
  <li>范围子句: <code class="language-plaintext highlighter-rouge">FROM tabname { , tabname ... }</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 在SQL中, 这些表相当于被笛卡尔乘积连接, 因此联结时需要在where中给出条件
</code></pre></div></div>

<ul>
  <li>
    <p>条件子句: <code class="language-plaintext highlighter-rouge">[ WHERE search_condition ]</code></p>
  </li>
  <li>
    <p>分组子句: <code class="language-plaintext highlighter-rouge">[ GROUP BY colname { , colname ... }</code></p>
  </li>
  <li>
    <p>分组查询子句: <code class="language-plaintext highlighter-rouge">[ HAVING group_condition ]</code></p>
  </li>
  <li>
    <p>排序输出子句: <code class="language-plaintext highlighter-rouge">[ ORDER BY colname [ ASC | DESC ] { , colname [ ASC | DESC ] ... } ]</code></p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 最后执行

&gt;

&gt; *  两个必须的子句: `select`/`from`

&gt; *  having子句的前面必须有group by子句
</code></pre></div></div>

<ul>
  <li>
    <p>基本查询功能</p>
  </li>
  <li>
    <p>distinct谓词: <code class="language-plaintext highlighter-rouge">DISTINCT colname</code> 统计查询使用, 去重统计</p>
  </li>
  <li>
    <p>LIKE: <code class="language-plaintext highlighter-rouge">colname [NOT] LIKE val1 [ESCAPE val2]</code></p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  `val1`是模板, 其中`_`匹配任意一个字符, `%`匹配任意一个字符串

*  `val2`定义转义指示字符, 跟在其后的, `val1`中的通配符和转义字符将表示原义
</code></pre></div></div>

<ul>
  <li>
    <p>IS NULL谓词: <code class="language-plaintext highlighter-rouge">colname IS [NOT] NULL</code>判断是否为NULL</p>
  </li>
  <li>
    <p>多表联接查询: <code class="language-plaintext highlighter-rouge">WHERE</code>当中, 通过属性的相等, 实现表与表之间的连接</p>
  </li>
  <li>
    <p>表的自联接查询: <code class="language-plaintext highlighter-rouge">tabname [[AS] alias]</code> 给表起别名</p>
  </li>
  <li>
    <p>嵌套查询</p>
  </li>
  <li>
    <p>IN: <code class="language-plaintext highlighter-rouge">expr [NOT] IN (subquery)</code>标量与集合量之间的属于比较</p>
  </li>
  <li>
    <p>SOME/ANY/ALL: <code class="language-plaintext highlighter-rouge">expr θ SOME|ANY|ALL (subquery)</code>标量与集合中元素之间的量化比较</p>
  </li>
  <li>
    <p>EXISTS: <code class="language-plaintext highlighter-rouge">[NOT] EXIST</code>是否为空集的判断谓词</p>
  </li>
  <li>
    <p>相关子查询与独立子查询: 子查询内部引用了外部查询的表或元组变量, 因此每当外部取值变化, 都要再运行子查询</p>
  </li>
  <li>
    <p>子查询的合并: 带<code class="language-plaintext highlighter-rouge">ALL</code>意为允许重复</p>
  </li>
  <li>
    <p>UNION: <code class="language-plaintext highlighter-rouge">(subquery) UNION [ALL] (subquery)</code>并</p>
  </li>
  <li>
    <p>INTERSECT: <code class="language-plaintext highlighter-rouge">(subquery) INTERSECT [ALL] (subquery)</code>交</p>
  </li>
  <li>
    <p>EXCEPT: <code class="language-plaintext highlighter-rouge">(subquery) EXCEPT [ALL] (subquery)</code>减</p>
  </li>
  <li>
    <p>复杂数据查询</p>
  </li>
  <li>
    <p>统计查询</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  `COUNT(colname)`: 计数, 空值忽略

  &gt; `COUNT(DISTINCT colname)`: 计数互不相同的值, 空值忽略

*  `SUM(colname)`: 求和, 空值忽略

*  `AVG(colname)`: 求平均, 空值忽略

*  `MIN(colname)`: 求最小, 空值忽略

*  `MAX(colname)`: 求最大, 空值忽略
</code></pre></div></div>

<ul>
  <li>分组统计查询: <code class="language-plaintext highlighter-rouge">GROUP BY colname {, colname}</code>按照<code class="language-plaintext highlighter-rouge">colname</code>的取值不同, 分组统计</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; `SELECT`当中必须包括`GROUP BY`当中的属性
</code></pre></div></div>

<ul>
  <li>
    <p>分组选择统计查询: <code class="language-plaintext highlighter-rouge">HAVING group_cond</code>必须先分组, 之后满足<code class="language-plaintext highlighter-rouge">group_confd</code>的组才会被保留</p>
  </li>
  <li>
    <p>关系代数中的除法运算功能在SQL中的表示方法</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>待构造的除法: $\pi_{sno, cno}(SC)\div \pi_{cno}(C)$

&gt; 语义: 对于符合要求的SC中sno, (对于任意的C中cno, 都有sno选修过cno的记录)

&gt; 等价于: 对于符合要求的SC中元组S, 对于任意C中元组x, 都能找到元组y,使得y.sno=S.sno and y.cno=x.cno

&gt;

&gt; 任意-&gt;不存在不满足-&gt;不存在(不存在):

&gt;

&gt; &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;对SC中S, 不存在 &lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt; 对C中x, 不存在&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  SC中的S-x元组y, 即y.sno=S.sno and y.cno=x.cno&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;&lt;span class="keyword"&gt;SELECT&lt;/span&gt; &lt;span class="keyword"&gt;DISTINCT&lt;/span&gt; SC.sno            &lt;span class="comment"&gt;# &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;span class="keyword"&gt;FROM&lt;/span&gt; SC S                   &lt;span class="comment"&gt;# 被除数当中的元组, 作为目标元组, 将目标属性传入(S.sno)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;span class="keyword"&gt;WHERE&lt;/span&gt; &lt;span class="keyword"&gt;NOT&lt;/span&gt; &lt;span class="keyword"&gt;EXISTS&lt;/span&gt; (              &lt;span class="comment"&gt;# 不存在不满足条件的元组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  &lt;span class="keyword"&gt;SELECT&lt;/span&gt; *                 &lt;span class="comment"&gt;# &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  &lt;span class="keyword"&gt;FROM&lt;/span&gt; C x                 &lt;span class="comment"&gt;# 除数当中的元组, 被要求对任意S.sno全都有&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  &lt;span class="keyword"&gt;WHERE&lt;/span&gt; &lt;span class="keyword"&gt;NOT&lt;/span&gt; &lt;span class="keyword"&gt;EXISTS&lt;/span&gt; (            &lt;span class="comment"&gt;# 为了表示"不满足", 构造对S.sno不含有, 即不存在满足的元组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;    &lt;span class="keyword"&gt;SELECT&lt;/span&gt; *               &lt;span class="comment"&gt;# &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;    &lt;span class="keyword"&gt;FROM&lt;/span&gt; SC y               &lt;span class="comment"&gt;# 被除数元组的任意元组, 寻找满足的元组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;    &lt;span class="keyword"&gt;WHERE&lt;/span&gt; y.sno = S.sno &lt;span class="keyword"&gt;AND&lt;/span&gt; y.cno = x.cno &lt;span class="comment"&gt;# 一个[除数,被除数]的元组, 两组相等关系, 分别约束: (对被除数进行查询), (对除数进行查询)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  )                     &lt;span class="comment"&gt;# 这个子查询可以由NOT IN代替, 表示不含有&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;)                       &lt;span class="comment"&gt;# &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre></div></div>

<ul>
  <li>在FROM子句中嵌入子查询: <code class="language-plaintext highlighter-rouge">FROM (subquery) [[AS] alias]</code></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!– + 查询结果输出
</code></pre></div></div>

<ul>
  <li>
    <p>结果元组去重：distinct</p>
  </li>
  <li>
    <p>结果元组排序：order by –&gt;</p>
  </li>
</ul>

<h3 id="sql的更新功能">SQL的更新功能</h3>

<ul>
  <li>
    <p>元组删除: <code class="language-plaintext highlighter-rouge">DELETE FROM tabname [WHERE cond]</code></p>
  </li>
  <li>
    <p>元组插入:</p>
  </li>
</ul>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tabname [(colname {,colname})]</span><br /><span class="line"><span class="keyword">VALUES</span> (expr | <span class="literal">NULL</span> {,expr | <span class="literal">NULL</span>}) | (subquery)</span><br /></pre></td></tr></tbody></table>

<ul>
  <li>元组修改:</li>
</ul>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tabname </span><br /><span class="line"><span class="keyword">SET</span> colname=expr | <span class="literal">NULL</span> | subquery, ...</span><br /><span class="line">[<span class="keyword">WHERE</span> cond]</span><br /></pre></td></tr></tbody></table>

<h3 id="视图">视图</h3>

<ul>
  <li>
    <p>视图概念: 若干张表经映像语句构筑而成的表(导出表)</p>
  </li>
  <li>
    <p>视图与基表的区别: 同样有构造信息, 但视图不存储(虚表)</p>
  </li>
  <li>
    <p>创建: <code class="language-plaintext highlighter-rouge">CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt;{, &lt;列名&gt;})] AS &lt;映像语句&gt; [WITH CHECK OPTION]</code></p>
  </li>
</ul>

<blockquote>
  <p>映像语句实际上就是子查询, CHECK OPTICON 不知道什么意思</p>
</blockquote>

<ul>
  <li>
    <p>删除: <code class="language-plaintext highlighter-rouge">DROP VIEW &lt;视图名&gt;</code></p>
  </li>
  <li>
    <p>视图的嵌套定义</p>
  </li>
  <li>
    <p>视图删除中的连锁反应: 视图的删除操作时，将连带删除定义在该视图上的其它视图</p>
  </li>
  <li>
    <p>可更新视图的判断准则: 视图每一行对应基表每一行, 视图每一列对应基表每一列</p>
  </li>
  <li>
    <p>视图的作用: 提高数据独立性, 简化用户观点, 自动的安全保护</p>
  </li>
</ul>

<p>第四章:数据库的安全性与完整性保护</p>

<p>=============================================================================================================================================================================================================================================================</p>

<p>数据库的安全性保护</p>

<hr />

<ul>
  <li>
    <p>数据库安全的基本概念: 防止非法使用数据库(规定的途径和规则)</p>
  </li>
  <li>
    <p>主体: 数据访问者</p>
  </li>
  <li>
    <p>客体: 数据及其载体</p>
  </li>
  <li>
    <p>身份标识与鉴别: 主体具有标识符和口令</p>
  </li>
  <li>
    <p>自主访问控制: 基于存取矩阵的安全控制模型(用户给定权限, 访问时检查权限)</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 客体所有者(创建者)自动拥有全部权限, 有权限的可授予他人权限, 权限仅限这两种方法获得

&gt; 登陆时检查: 是不是管理员-&gt;是不是所有者-&gt;有没有被授权

&gt; 存储矩阵: 行标签: 客体; 列标签: 主体
</code></pre></div></div>

<ul>
  <li>审计: 跟踪记录用户对数据的访问操作</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 时间, 内容, 用户名, 终端名, 操作类型, 操作结果; 给出报警信息
</code></pre></div></div>

<ul>
  <li>
    <p>SQL对数据库安全的支持</p>
  </li>
  <li>
    <p>SQL中的存取权限</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 权限: SELECT INSERT DELETE UPDATE REFERENCE EXECUTE USAGE

&gt; 对象: 表/视图 属性 域(数据类型) 存储过程/函数/触发器
</code></pre></div></div>

<ul>
  <li>
    <p>授权命令: <code class="language-plaintext highlighter-rouge">GRANT &lt;权限列表&gt; ON &lt;对象&gt; TO &lt;用户名列表&gt; [WITH GRANT OPTION]</code></p>
  </li>
  <li>
    <p>回收命令: <code class="language-plaintext highlighter-rouge">REVOKE &lt;权限列表&gt; ON &lt;对象&gt; FROM &lt;用户名列表&gt; [RESTRICT | CASCADE]</code></p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; CASCADE连锁回收; RESTRICT不连锁才回收, 否则拒绝回收
</code></pre></div></div>

<p>数据库的完整性保护</p>

<hr />

<ul>
  <li>
    <p>数据库完整性保护: 对数据库中数据的正确性和一致性的维护</p>
  </li>
  <li>
    <p>功能: 设置功能; 检查功能; 处理功能</p>
  </li>
  <li>
    <p>目的: 及时发现错误-&gt;防止错误的蔓延-&gt;恢复到正确状态</p>
  </li>
  <li>
    <p>常用实现措施</p>
  </li>
  <li>
    <p>完整性约束条件的定义及检查</p>
  </li>
  <li>
    <p>触发器</p>
  </li>
  <li>
    <p>并发控制技术</p>
  </li>
  <li>
    <p>实体完整性: 关键字不为空</p>
  </li>
  <li>
    <p>参照完整性: 不能引用不存在的实体(外关键字要么与被引相同, 要么为空值)</p>
  </li>
  <li>
    <p>用户定义完整性: 用户自己定义</p>
  </li>
  <li>
    <p>完整的CREATE TABLE命令</p>
  </li>
  <li>
    <p>基表的创建</p>
  </li>
  <li>
    <p>完整性约束的定义：主关键字，外关键字，CHECK约束，UNIQUE，NOT NULL, DEFAULT</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;{ NOT NULL  |&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt; [ CONSTRAINT constraint_name ] &lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;span class="comment"&gt;# 给约束起名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  UNIQUE&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  | PRIMARY KEY&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  | &lt;span class="keyword"&gt;CHECK&lt;/span&gt; ( search_condition )&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  | &lt;span class="keyword"&gt;REFERENCES&lt;/span&gt; table_name [ ( column_name ) ]&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  [ &lt;span class="keyword"&gt;ON&lt;/span&gt; &lt;span class="keyword"&gt;DELETE&lt;/span&gt; &lt;span class="keyword"&gt;CASCADE&lt;/span&gt; | RESTRICT | &lt;span class="keyword"&gt;SET&lt;/span&gt; &lt;span class="literal"&gt;NULL&lt;/span&gt; ]&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  [ &lt;span class="keyword"&gt;ON&lt;/span&gt; &lt;span class="keyword"&gt;UPDATE&lt;/span&gt; &lt;span class="keyword"&gt;CASCADE&lt;/span&gt; | RESTRICT | &lt;span class="keyword"&gt;SET&lt;/span&gt; &lt;span class="literal"&gt;NULL&lt;/span&gt; ] &lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre></div></div>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /></pre></td><td class="code"><pre><span class="line">FOREIGN KEY ( colname { , colname ... } ) </span><br /><span class="line"><span class="comment"># 定义主外键的引用关系</span></span><br /><span class="line"> REFERENCES table_name [ ( colname { ,colname... } ) ] </span><br /><span class="line">  </span><br /><span class="line"><span class="comment"># 当在被引用表中删除元组或修改主键值时，需要维护引用表中外键值的正确性</span></span><br /><span class="line">  [ ON <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span> ]</span><br /><span class="line">  [ <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span> ]  }</span><br /><span class="line">  </span><br /><span class="line"><span class="comment"># CASCADE 同步改变 | RESTRICT 拒绝(默认模式) | SET NULL 外键设为空</span></span><br /></pre></td></tr></tbody></table>

<ul>
  <li>
    <p>触发器: 在数据库系统中，一个事件的发生会导致另外一些事件的发生，这样的功能被称为触发器</p>
  </li>
  <li>
    <p>创建命令</p>
  </li>
</ul>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /><span class="line">11</span><br /><span class="line">12</span><br /><span class="line">13</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name { <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span> } </span><br /><span class="line"><span class="comment"># 定义时机</span></span><br /><span class="line">{ <span class="keyword">INSERT</span> | <span class="keyword">DELETE</span>               </span><br /><span class="line"><span class="comment"># 触发事件</span></span><br /><span class="line"> | <span class="keyword">UPDATE</span> [ <span class="keyword">OF</span> colname { , colname ... } ] }</span><br /><span class="line">  <span class="keyword">ON</span> table_name </span><br /><span class="line"> [ <span class="keyword">REFERENCING</span> corr_name_def { , ...... } ]</span><br /><span class="line"> [ <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> | <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span> ]    </span><br /><span class="line"><span class="comment"># 执行方式</span></span><br /><span class="line"> [ <span class="keyword">WHEN</span> ( search_condition ) ]</span><br /><span class="line"> { <span class="keyword">statement</span>                 </span><br /><span class="line"><span class="comment"># 结果事件</span></span><br /><span class="line"> | BEGIN ATOMIC statement; { statement; ... } END</span><br /></pre></td></tr></tbody></table>

<p>第五章:事务处理并发控制与故障恢复技术</p>

<p>===================================================================================================================================================================================================================================================================================</p>

<p>事务处理（概念）</p>

<hr />

<ul>
  <li>
    <p>事务的定义: 某个用户所执行的一个不能被打断的对数据库的操作序列</p>
  </li>
  <li>
    <p>ACID性质</p>
  </li>
  <li>
    <p>A原子性: 不可分割的操作序列, 要么全部, 要么不执行</p>
  </li>
  <li>
    <p>C一致性: 执行前后都满足一致性</p>
  </li>
  <li>
    <p>I隔离性: 并发结果与某种串行执行结果相同, 即相互独立</p>
  </li>
  <li>
    <p>D持久性: 事务完成，它对数据库的所有更新应永久地反映在数据库中</p>
  </li>
  <li>
    <p>事务活动图</p>
  </li>
</ul>

<p><img src="https://maxwell-lyu.github.io/2019/12/19/Learn-DB-20191219-DB-FIN/01.png" alt="image" /></p>

<ul>
  <li>状态转换图</li>
</ul>

<p><img src="https://maxwell-lyu.github.io/2019/12/19/Learn-DB-20191219-DB-FIN/02.png" alt="image" /></p>

<ul>
  <li>
    <p>事务控制语句</p>
  </li>
  <li>
    <p>commit transaction</p>
  </li>
  <li>
    <p>rollback transaction: 可以恢复到存在的保存点, 或者回到事务起点</p>
  </li>
  <li>
    <p>savepoint: 设置保存点</p>
  </li>
  <li>
    <p>相关的参数设置语句</p>
  </li>
  <li>
    <p>自动提交: <code class="language-plaintext highlighter-rouge">SET AUTOCOMMIT ON|OFF</code></p>
  </li>
  <li>
    <p>读写: <code class="language-plaintext highlighter-rouge">SET TRANSACTION READONLY|READWRITE</code></p>
  </li>
  <li>
    <p>隔离级别: <code class="language-plaintext highlighter-rouge">SET TRANSACTION ISOLATION LEVEL READUNCOMMITTED|READCOMMITTED| READREPEATABLE|SERIALIZABLE</code></p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; READUNCOMMITTED无封锁; READCOMMITTED读加共享锁到读完; READREPEATABLE读加共享锁到事务结束; SERIALIZABLE串行化调度执行
</code></pre></div></div>

<ul>
  <li>事务的语句组成成分: 开始, 结束(正常结束-&gt;提交事务, 非正常结束-&gt;回滚)</li>
</ul>

<p>并发控制技术（概念）</p>

<hr />

<ul>
  <li>
    <p>事务</p>
  </li>
  <li>
    <p>事务的并发性: 数据库是一个多用户共享系统, 以事务为单位访问</p>
  </li>
  <li>
    <p>并发控制: 实现多个用户事务的并发执行的技术</p>
  </li>
  <li>
    <p>调度: DBMS中事务执行的操作序列, 按时间排序</p>
  </li>
  <li>
    <p>串行调度: 做完一个接下一个事务(首先是一个事务的所有操作，然后是另一个事务的所有操作, 原句真啰嗦)</p>
  </li>
  <li>
    <p>可串行化调度: 一个调度对数据库状态的影响和某个串行调度相同</p>
  </li>
  <li>
    <p>冲突: 调度中一对相邻操作, 交换顺序，涉及的事务中至少有一个的行为会改变</p>
  </li>
  <li>
    <p>冲突可串行化(可串行化的充分条件): 冲突可串行化调度”冲突等价”于一个串行调度</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 冲突等价: 如果通过一系列相邻操作的非冲突交换能够将一个调度转换为另一个调度，则我们称这两个调度是冲突等价的
</code></pre></div></div>

<ul>
  <li>视图可串行化: 视图可串行化调度”视图等价”于一个串行调度</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 视图等价

&gt; [视图等价]相同的一组事务，两个不同的调度S与H。S和H被称为“视图等价”当且仅当满足下列三个条件：

&gt; 对每一个数据项D

&gt; 如果在调度S中事务$T_k$读到D的初始值，则在调度H中事务$T_k$也必须读到D的初始值；

&gt; 如果在调度S中事务$T_k$执行了rk(D)，并且读到的是由事务$T_j$写入的D的值，则在调度H中事务$T_k$的rk(D)读到的也必须是由事务$T_j$ 所写入的D的值；

&gt; 如果在调度S中是由事务$T_k$来执行最后一条关于D的写操作wk(D)，则在调度H中也一定是事务$T_k$执行最后一条关于D的写操作wk(D)。
</code></pre></div></div>

<ul>
  <li>冲突可串行化的判定方法: 事务优先图没环 &lt;-&gt; 是冲突可串行化</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 事务优先图

&gt; 优先: 给出的调度H中, 两个动作来自不同事务, 若其涉及同一个数据库对象且至少一个为写, 则这两个事务不可交换, 定义了优先关系

&gt; 优先关系画出有向图

&gt; 盲写: 没读就写
</code></pre></div></div>

<ul>
  <li>不正确的事务并发所导致的数据不一致现象</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>不一致现象</td>
      <td>描述</td>
      <td>原因</td>
    </tr>
  </tbody>
</table>

<p>| — | — | — |</p>

<table>
  <tbody>
    <tr>
      <td>丢失修改</td>
      <td>一个修改破坏另一个修改结果</td>
      <td>多个事务并发修改同一个数据</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>脏读</td>
      <td>读到错误的数据</td>
      <td>其他事务未提交的修改</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>不可重复读</td>
      <td>前后两次读不一致</td>
      <td>其他事务已提交的写操作</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>幻像读</td>
      <td>一个事务中, 执行相同的查询多次, 结果不同</td>
      <td>其他事务已提交的插入操作</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>封锁</p>
  </li>
  <li>
    <p>排它锁（X锁）: 一个对象同时只能上一次, 维持到事务结束</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 自己可以读写, 别人啥也不行
</code></pre></div></div>

<ul>
  <li>共享锁（S锁）: 可以与其他S锁并存</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 全员只读
</code></pre></div></div>

<ul>
  <li>
    <p>锁申请: 能锁就锁, 锁了就睡, 被叫醒且能锁就锁</p>
  </li>
  <li>
    <p>锁释放: 解锁, 唤醒</p>
  </li>
  <li>
    <p>基于封锁技术的并发控制实现方法</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  过程: 访问发给调度器-&gt;调度器申请锁, 封锁管理器-&gt;管理器返回结果-&gt;(成功, 操作发给执行引擎; 失败, 进队列)

*  三级封锁协议

  *  一级: 写之前加X锁, 事务结束释放

  *  二级: 一级 + 读前加S锁, 读完释放

  *  三级: 二级 + 读前加S锁, 事务结束释放

*  三级封锁协议防止的不一致

  *  一级: 丢失修改

  *  二级: 丢失修改, 脏读

  *  三级: 丢失修改, 脏读, 不可重复读

*  两阶段封锁协议

  *  在一个事务T中，如果它的所有封锁请求都先于它的所有解锁请求，则该事务被称为‘两阶段封锁事务’ ，简称‘2PL事务’

  *  一阶段: 申请整个过程需要的锁

  *  二阶段: 释放所有锁, 不能再申请

*  两阶段封锁协议与冲突可串行化的关系: 两阶段任意合法调度S都是冲突可串行化的
</code></pre></div></div>

<ul>
  <li>
    <p>多粒度封锁</p>
  </li>
  <li>
    <p>封锁粒度/并发度/并发控制实现开销 之间的关系</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  锁粒度大, 并发度低, 控制开销小

*  锁粒度小, 并发度高, 控制开销大
</code></pre></div></div>

<ul>
  <li>
    <p>多粒度封锁: 同时支持多种封锁粒度供事务选择</p>
  </li>
  <li>
    <p>多粒度树: 按照封锁粒度的大小构造出一棵 ‘多粒度树’，以树中的每个结点作为封锁对象，可以构成一个‘多粒度封锁协议’</p>
  </li>
  <li>
    <p>基于意向锁的多粒度封锁协议</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  意向锁: 节点加意向锁, 其下层节点正被加锁(必须上层先加意向锁, 才能给下层加锁)

  *  IS: 下层打算加S

  *  IX: 下层打算加X

  *  SIX: 当前加S, 下层加X

*  意向锁锁相容矩阵

*  意向锁锁申请算法，意向锁锁释放算法: 对任何一个节点加锁, 必须先对其父节点加意向锁(也就是从根开始加)
</code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>已经有的锁</td>
      <td>S</td>
      <td>X</td>
      <td>IS</td>
      <td>IX</td>
      <td>SIX</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>| — | — | — | — | — | — | — |</p>

<table>
  <tbody>
    <tr>
      <td>已经持有S</td>
      <td>✔</td>
      <td> </td>
      <td>✔</td>
      <td> </td>
      <td> </td>
      <td>S加了, 当前及其下层没有X</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>已经持有X</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>X排他, 加了别的都没有</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>已经持有IS</td>
      <td>✔</td>
      <td> </td>
      <td>✔</td>
      <td>✔</td>
      <td>✔</td>
      <td>IS加了, 当前没X</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>已经持有IX</td>
      <td> </td>
      <td> </td>
      <td>✔</td>
      <td>✔</td>
      <td> </td>
      <td>IX加了, 当前没S没X</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>已经持有SIX</td>
      <td> </td>
      <td> </td>
      <td>✔</td>
      <td> </td>
      <td> </td>
      <td>SIX加了, 相当于同时S和IX</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>死锁的检测与预防</p>
  </li>
  <li>
    <p>死锁: 每个事务持有部分锁, 循环等待</p>
  </li>
  <li>
    <p>活锁: 有部分事务长期等待锁, 其他事务可以继续运行</p>
  </li>
  <li>
    <p>死锁的检测及其处理办法</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  等待图法

*  超时死锁检测法

  *  锁申请等待超时

  *  事务执行超时

*  时间戳死锁检测法: (时间戳反映事务已经执行的时间)当T要等待U持有的锁

  *  等待-死亡方案: T比U老, T等待; U比T老, 则T被回滚

  *  伤害-等待方案: T比U老, U回滚; U比T老, T等待
</code></pre></div></div>

<p>数据库恢复技术</p>

<hr />

<ul>
  <li>
    <p>数据库恢复的含义: 在数据库遭受破坏后及时进行恢复的功能</p>
  </li>
  <li>
    <p>方法: 不同介质上冗余存储，利用冗余信息恢复</p>
  </li>
  <li>
    <p>常用措施: 数据转储, 日志, 数据库镜像</p>
  </li>
  <li>
    <p>数据库故障的分类</p>
  </li>
  <li>
    <p>小型: 事务内部故障, 不影响系统</p>
  </li>
  <li>
    <p>中型: 系统停止, 磁盘不坏, 重启靠日志能恢复</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  系统故障

*  外部影响
</code></pre></div></div>

<ul>
  <li>大型: 内存磁盘严重破坏, 需要彻底恢复</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  磁盘故障

*  计算机病毒

*  黑客入侵
</code></pre></div></div>

<ul>
  <li>
    <p>数据库故障恢复三大技术</p>
  </li>
  <li>
    <p>数据转储: 定期将数据库中的内容复制到其它存储设备中去的过程</p>
  </li>
  <li>
    <p>日志: 自动记载数据库中修改型操作的数据更新情况的文件</p>
  </li>
  <li>
    <p>数据库镜像: 整个数据库中的数据实时复制到另一个磁盘</p>
  </li>
  <li>
    <p>数据转储</p>
  </li>
  <li>
    <p>静态转储</p>
  </li>
  <li>
    <p>动态转储: 修改前记录原值</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; 需要结合日志恢复(记录转储开始和结束点, 事务更新的对象和前后值, 事务结束状态)
</code></pre></div></div>

<ul>
  <li>
    <p>海量转储</p>
  </li>
  <li>
    <p>增量转储</p>
  </li>
  <li>
    <p>日志：</p>
  </li>
  <li>
    <p>内容: 事务标识、更新对象、更新前的值 和/或 更新后的值; 每个事务执行情况; 其他</p>
  </li>
  <li>
    <p>组成: 日志记录 的序列, 并发时, 各个事务的日志是交错的</p>
  </li>
  <li>
    <p>作用: 确保原子性, 实现增量转储, 实现故障恢复</p>
  </li>
  <li>
    <p>记载原则: 操作执行的先后次序, 先写日志, 后修改数据库</p>
  </li>
  <li>
    <p>在日志中设置检查点的作用: 降低数据库故障恢复的开销, 到<code class="language-plaintext highlighter-rouge">&lt;CKPT&gt;</code>就可以结束恢复过程</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  停止接收新任务 -&gt; 等待当前所有事物提交或终止 -&gt; 刷新日志到磁盘

*  写入`&lt;CKPT&gt;` -&gt; 刷新日志到磁盘

*  继续接收新事务
</code></pre></div></div>

<ul>
  <li>
    <p>事务的撤销（UNDO）与重做（REDO）</p>
  </li>
  <li>
    <p>UNDO日志</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  UNDO日志的内容

  *  开始事务: `&lt;Start T&gt;`

  *  提交事务: `&lt;Commit T&gt;`

  *  放弃事务: `&lt;Abort T&gt;`

  *  更新记录: `&lt;T, X, V&gt;`事务T修改了X, 原值是V

*  记载规则: 更新记录 先于 更新操作; 事务提交 先于 提交日志

*  作用: 用于被放弃事务(故障时中断的事务)的撤消工作

*  基于UNDO日志的故障恢复流程

  *  从后向前扫, 对每一个`&lt;T, X, V&gt;`:

    *  若`&lt;Commit T&gt;`被扫到过, 则继续扫

    *  否则将X改成V

  *  日志尾部为所有未结束事务写入`&lt;Abort T&gt;`, 刷新日志
</code></pre></div></div>

<ul>
  <li>REDO日志</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  REDO日志的内容: 跟UNDO一样, 唯一不同: 更新记录`&lt;T, X, V&gt;`中记载的是更新后的值

*  记载规则: 修改前, 必须有更新记录和事务提交记录

*  作用: 已提交事务的重做工作

*  基于REDO日志的故障恢复流程

  *  确定所有已提交的事务

  *  从前向后扫, 对每条更新

    *  如果未提交, 继续扫

    *  如果提交了, 写入新值

  *  日志尾部为所有未结束事务写入`&lt;Abort T&gt;`, 刷新日志
</code></pre></div></div>

<ul>
  <li>UNDO/REDO日志</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  UNDO/REDO日志的内容: 跟UNDO一样, 唯一不同: 更新记录`&lt;T, X, V, W&gt;`中记载前与后的值

*  记载规则: 修改前需要有更新记录

*  作用: 兼有两者

*  基于UNDO/REDO日志的故障恢复流程

  *  根据提交记录, 确定事务是否被提交

    *  按照从后往前的顺序，撤消(undo)所有未提交的事务

    *  按照从前往后的顺序，重做(redo)所有已提交的事务
</code></pre></div></div>

<ul>
  <li>
    <p>恢复策略</p>
  </li>
  <li>
    <p>小型: 未结束的事务的undo</p>
  </li>
  <li>
    <p>中型: 非正常终止: undo; 完成提交: redo</p>
  </li>
  <li>
    <p>大型: 先用后备副本恢复, 之后用日志undo + redo</p>
  </li>
</ul>

<p>第六章&amp;第七章</p>

<p>===================================================================================================================================================</p>

<ul>
  <li>
    <p>游标管理</p>
  </li>
  <li>
    <p>游标的作用: 集合量逐个取出后送入应用程序变量内供其使用</p>
  </li>
  <li>
    <p>定义: 查询结果为多个元组时, 必须使用游标获取每个元组</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;EXEC SQL &lt;span class="keyword"&gt;DECLARE&lt;/span&gt; &lt;span class="keyword"&gt;cursor&lt;/span&gt;-&lt;span class="keyword"&gt;name&lt;/span&gt; &lt;span class="keyword"&gt;CURSOR&lt;/span&gt; &lt;span class="keyword"&gt;FOR&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;	subquery&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;	[ &lt;span class="keyword"&gt;ORDER&lt;/span&gt; &lt;span class="keyword"&gt;BY&lt;/span&gt; ...... ]&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;	[ &lt;span class="keyword"&gt;FOR&lt;/span&gt; { &lt;span class="keyword"&gt;READ&lt;/span&gt; &lt;span class="keyword"&gt;ONLY&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;		  &lt;span class="keyword"&gt;UPDATE&lt;/span&gt; [ &lt;span class="keyword"&gt;OF&lt;/span&gt; columnname, ...... ] } ] ;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre></div></div>

<ul>
  <li>
    <p>打开: <code class="language-plaintext highlighter-rouge">EXEC SQL OPEN agent_dollars</code></p>
  </li>
  <li>
    <p>使用</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;while (TRUE) {		/* loop to fetch rows */&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  exec sql fetch agent_dollars&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;           into :agent_id, :dollar_sum;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  printf("%s %11.2fn", agent_id, dollar_sum);&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;}				/* end fetch loop */&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre></div></div>

<ul>
  <li>
    <p>关闭: <code class="language-plaintext highlighter-rouge">exec sql whenever not found goto finish</code>定义结束, <code class="language-plaintext highlighter-rouge">exec sql close agent_dollars</code>关闭游标</p>
  </li>
  <li>
    <p>可滚动游标的定义</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;EXEC SQL &lt;span class="keyword"&gt;DECLARE&lt;/span&gt; cursor_name&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt; [ INSENSITIVE ] [ &lt;span class="keyword"&gt;SCROLL&lt;/span&gt; ]&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt; &lt;span class="keyword"&gt;CURSOR&lt;/span&gt; [ &lt;span class="keyword"&gt;WITH&lt;/span&gt; HOLD ] &lt;span class="keyword"&gt;FOR&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  subquery { &lt;span class="keyword"&gt;UNION&lt;/span&gt; subquery }&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  [ &lt;span class="keyword"&gt;ORDER&lt;/span&gt; &lt;span class="keyword"&gt;BY&lt;/span&gt; ...... ]&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt; [ &lt;span class="keyword"&gt;FOR&lt;/span&gt; &lt;span class="keyword"&gt;READ&lt;/span&gt; &lt;span class="keyword"&gt;ONLY&lt;/span&gt; |&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  &lt;span class="keyword"&gt;FOR&lt;/span&gt; &lt;span class="keyword"&gt;UPDATE&lt;/span&gt; &lt;span class="keyword"&gt;OF&lt;/span&gt; columnname ...... ];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre></div></div>

<ul>
  <li>在数据更新命令中的使用</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class="gutter"&gt;&lt;pre&gt;&lt;span class="line"&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;pre&gt;&lt;span class="line"&gt;EXEC SQL FETCH&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt; [ { NEXT | PRIOR | FIRST | LAST |&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt;  { ABSOLUTE | RELATIVE } value_spec } FROM ]&lt;/span&gt;&lt;br&gt;&lt;span class="line"&gt; cursor_name INTO ......;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</code></pre></div></div>

<ul>
  <li>
    <p>索引 (index)</p>
  </li>
  <li>
    <p>B+索引的数据结构: 定义秩为n</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  结点: 取$m\leq n$, 结点含有m个键$K_i$和m+1个指针$P_i$, 五花肉式存放,

*  约束

  *  叶节点: $\lfloor (n+1)/2\rfloor\leq m\leq n, P_i$指向$K_i$, $P_{m+1}$指向下一个叶子

  *  根结点: $1\leq m\leq n$; 内部结点: $\lceil (n-1)/2\rceil\leq m\leq n, P_i$均指向子树根节点

*  性质

  *  非叶节点, 在$P_i$所指子树的任意关键字K, 有$K_{i-1}\leq K&lt; K_i$

  *  只有一个结点, 则根节点也是叶节点; 否则, 根节点跟内部节点类似
</code></pre></div></div>

<ul>
  <li>搜索算法</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  随机查找

  *  结点上的关键字划分了值域, 层层向下在相应区间中搜索合适的叶节点, 最后在叶结点遍历搜索

*  区间查找

  *  先找区间下限a, 之后在叶节点(类似链表)中遍历, 直到超过上限b
</code></pre></div></div>

<p>第八章:关系数据库规范化理论</p>

<p>============================================================================================================================================================================================================================</p>

<p>概述</p>

<hr />

<ul>
  <li>
    <p>模式设计质量的评价指标</p>
  </li>
  <li>
    <p>数据冗余度: 合理的数据冗余度</p>
  </li>
  <li>
    <p>插入/删除等更新异常: 没有插入和删除操作异常</p>
  </li>
  <li>
    <p>关系的规范化</p>
  </li>
  <li>
    <p>按照给定范式要求设计关系模式</p>
  </li>
  <li>
    <p>范式: 对一个关系中允许存在的函数依赖的要求</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>规范化理论

---------------------------------------------------------------------------------------------------------------------------------
</code></pre></div></div>

<h3 id="函数依赖fd">函数依赖（FD）</h3>

<ul>
  <li>
    <p>函数依赖: 一个关系中 两组属性之间的 取值约束</p>
  </li>
  <li>
    <p>表示: $X\to Y$: Y函数依赖于X</p>
  </li>
  <li>
    <p>直观: 在关系$R$中, 每个$X$的值都有唯一的一个$Y$值与之对应</p>
  </li>
  <li>
    <p>定义: 关系模式$R(U)$中, 关系$r$中元组$r_i$在$X$中的取值确定后, $Y$中取值必被确定, 则$X\to Y$</p>
  </li>
  <li>
    <p>$X$决定因素, $Y$依赖因素</p>
  </li>
  <li>
    <p>发现函数依赖</p>
  </li>
  <li>
    <p>直接根据语义</p>
  </li>
  <li>
    <p>根据取值对应关系</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  一一对应: $X\to Y, Y\to X$

*  一多对应/多一对应: $Y\to X, X\to Y$

*  多多对应: 没有
</code></pre></div></div>

<ul>
  <li>
    <p>平凡函数依赖</p>
  </li>
  <li>
    <p>非平凡函数依赖: $X\to Y, Y\not\subseteq X$, 默认是这个</p>
  </li>
  <li>
    <p>平凡函数依赖: 反之</p>
  </li>
  <li>
    <p>完全函数依赖</p>
  </li>
  <li>
    <p>完全函数依赖: $X\to Y, \forall X’\subset X, X’\not\to Y$, 则$X\overset{f}{\to}Y$</p>
  </li>
  <li>
    <p>部分函数依赖: $X\to Y, \exists X’\subset X, X’\to Y$, 则$X\overset{p}{\to}Y$</p>
  </li>
  <li>
    <p>传递函数依赖</p>
  </li>
  <li>
    <p>$X\to Y, Y\not\subset X, Y\not\to X, Y\to Z$, 则 $X\to Z$为传递函数依赖</p>
  </li>
  <li>
    <p>Armstrong公理系统</p>
  </li>
  <li>
    <p>基本规则</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  自反规则: $Y\subseteq X$, 则$X\to Y$

*  增广规则: $X\to Y$, 则$XZ\to YZ$

*  传递规则: $X\to Y\wedge Y\to Z$, 则$X\to Z$
</code></pre></div></div>

<ul>
  <li>扩充规则</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  分解规则: $X\to YZ$, 则$X\to Y\wedge X\to Z$

*  合并规则: $X\to Y\wedge X\to Z$则$X\to YZ$

*  伪传递规则:$X\to Y\wedge WY\to Z$, 则$WX\to Z$
</code></pre></div></div>

<ul>
  <li>
    <p>函数依赖的逻辑蕴含概念</p>
  </li>
  <li>
    <p>F为关系模式R(U)的一个函数依赖集</p>
  </li>
  <li>
    <p>从已有的函数依赖出发, 利用公理系统可以推导出$X\to Y$, 则$F\vDash X\to Y$</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>函数依赖集F的闭包$F^+$: $F^+={X\to Y</td>
          <td>F\vDash X\to Y}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>函数依赖集的等价</p>
  </li>
  <li>
    <p>可以互相推导出其中的函数依赖</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>属性集X在函数依赖集$F^+$上的闭包$X_F^+$: $X_F^+={A</td>
          <td>F\vDash X\to A}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>[解题] 计算闭包</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  $X^+=X$

*  不断重复: 对每一个F中的依赖$Y\to Z$, 若$Y\subseteq X^+$, 则$X^+ = X^+ \cup Z$

*  直到不再变化
</code></pre></div></div>

<ul>
  <li>
    <p>关键字</p>
  </li>
  <li>
    <p>若$K\subseteq U$, $K\overset{f}{\to}U$, 则K是R的关键字</p>
  </li>
  <li>
    <p>主属性集: 所有关键字中的属性构成的集合</p>
  </li>
  <li>
    <p>非主属性集: 不属于任何一个关键字的属性构成的集合</p>
  </li>
  <li>
    <p>关键字与闭包: $K_F^+=U, \forall Z\subset F, Z_F^+\ne U$</p>
  </li>
  <li>
    <p>[解题] 寻找关键字</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  计算最小依赖集

*  不断重复从U中删除属性, 直到其闭包不等X于U

*  将得到一个关键字

*  技巧

  *  只在左边出现过的属性 属于 每一个关键字

  *  只在右边出现过的属性 不属于 任何一个关键字

  *  只需要对两边都有的属性尝试删除即可
</code></pre></div></div>

<h3 id="与函数依赖有关的范式">与函数依赖有关的范式</h3>

<ul>
  <li>
    <p>模式分解</p>
  </li>
  <li>
    <p>分解结果: 子关系模式, 满足</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  $\textrm{Head}(R)=\bigcup^n\textrm{Head}(R_i)$

*  $F_i=\{X\to Y|X\to Y\in F^+ \wedge (X\cup Y)\in \textrm{Head}(R_i)\}$
</code></pre></div></div>

<ul>
  <li>分解方法</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  找出所有不满足范式的依赖

*  选择一个依赖, 设$X\overset{f}{\to}Y$为这个依赖, 则将这个依赖所在的关系R分解为

  *  $R_1=\{X\cup Y, {X\to Y}\}$

  *  $R_2=\{\textrm{Head}(R)-Y, F_2\}$

  *  其中$F_2=\{A\to B|A\to B\in F^+\wedge (A\cup B)\subseteq \textrm{Head}(R_2)\}$
</code></pre></div></div>

<ul>
  <li>
    <p>1NF: 属性值不可分割, 全都满足</p>
  </li>
  <li>
    <p>2NF: 满足1NF, 每个非主属性都完全依赖于关键字</p>
  </li>
  <li>
    <p>检查:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  找到所有非主属性和所有候选关键字

*  检查每一个非主属性A和每一个候选关键字K之间的函数依赖, 看看有没有部分依赖
</code></pre></div></div>

<ul>
  <li>
    <p>3NF: 满足2NF, 每个非主属性都不传递依赖于关键字</p>
  </li>
  <li>
    <p>检查: 不满足3NF, 则必然存在下列情况之一, 其中$X\overset{f}{\to} Y$,$Y$是非主属性</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  X是某个关键字的真子集

*  X不是关键字
</code></pre></div></div>

<ul>
  <li>
    <p>BCNF: 满足1NF, 若$X\to Y$则X必含有该模式的关键字</p>
  </li>
  <li>
    <p>检查: 每个函数依赖, 是否满足X含有关键字</p>
  </li>
  <li>
    <p>BCNF -&gt; 3NF</p>
  </li>
  <li>
    <p>理解各级范式与数据冗余度、插入/删除异常的关系</p>
  </li>
  <li>
    <p>插入删除异常: 3NF消除异常</p>
  </li>
  <li>
    <p>冗余: 2NF存在冗余, 3NF冗余较小</p>
  </li>
</ul>

<h3 id="多值依赖与第四范式">多值依赖与第四范式</h3>

<ul>
  <li>
    <p>多值依赖: $X\to\to Y$</p>
  </li>
  <li>
    <p>定义: 对X的一个取值, 存在一组Y与其对应; Y的取值与$U-X-Y$不相关</p>
  </li>
  <li>
    <p>成因: 两个一对多关系$C\to T$, $C\to L$, 其合并后T与L就是多值依赖</p>
  </li>
  <li>
    <p>平凡多值依赖</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  非平凡多值依赖: $U-X-Y$不为空集

*  平凡多值依赖: 反之
</code></pre></div></div>

<ul>
  <li>
    <p>多值依赖有关的推理规则(需要掌握)</p>
  </li>
  <li>
    <p>求补规则: 若$X\to\to Y$, 则$U-X-Y\to\to Y$</p>
  </li>
  <li>
    <p>转换规则: 若$X\to Y$, 则$X\to\to Y$</p>
  </li>
  <li>
    <p>4NF</p>
  </li>
  <li>
    <p>定义: 若$X\to\to Y$是非平凡多值依赖, 则X必含有关键字</p>
  </li>
  <li>
    <p>特点: 函数依赖需要满足BCNF; 不是函数依赖的多值依赖只有平凡多值依赖</p>
  </li>
</ul>

<p>规范化所引起的一些问题</p>

<hr />

<ul>
  <li>
    <p>函数依赖的逻辑蕴涵: 函数依赖集的逻辑蕴含</p>
  </li>
  <li>
    <p>函数依赖集的等价: 可以互相推导出其中的函数依赖</p>
  </li>
  <li>
    <p>最小函数依赖集</p>
  </li>
  <li>
    <p>与F等价的, 最小的集合</p>
  </li>
  <li>
    <p>最小函数依赖集的计算算法</p>
  </li>
  <li>
    <p>首先得到题目中的所有函数依赖, 分解成右端只有一个的依赖</p>
  </li>
  <li>
    <p>消除部分函数依赖: 右边相同, 左边更多; 左边含右</p>
  </li>
  <li>
    <p>消除冗余函数依赖: 能推导就是冗余</p>
  </li>
  <li>
    <p>合并依赖</p>
  </li>
  <li>
    <p>无损联结性</p>
  </li>
  <li>
    <p>设$\rho={R_1,\cdots,R_k}$是对$R$的一个分解</p>
  </li>
  <li>
    <p>如果对每个满足F的关系实例r都满足$r=\pi_{R_1}(r)\Join\cdots\Join\pi_{R_k}(r)$</p>
  </li>
  <li>
    <p>则$\rho$是无损联接分解</p>
  </li>
  <li>
    <p>充要条件($\rho={R_1,R_2}$)</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  $R_1\cap R_2\to (R_1-R_2)$ 或 $R_1\cap R_2\to (R_2-R_1)$
</code></pre></div></div>

<ul>
  <li>
    <p>依赖保持性</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>表示$\pi_Z(F)={X\to Y</td>
          <td>X\to Y\in F^+\wedge (X\cup Y)\subseteq Z}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>$F^+=(\pi_{R_1}(F)\cup\cdots\cup\pi_{R_1}(F))^+$</p>
  </li>
  <li>
    <p>直接到3NF且满足无损联结性和依赖保持性的模式分解算法</p>
  </li>
  <li>
    <p>计算最小依赖集, 代替FFF进行分解</p>
  </li>
  <li>
    <p>$S=\emptyset$</p>
  </li>
  <li>对每一个函数$X\to Y$依赖进行</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  若在S中找不到子关系模式Z, 使得$X\cup Y\subseteq\textrm{Head}(Z)$

*  X和Y合并成新的子关系模式, 加入S
</code></pre></div></div>

<ul>
  <li>
    <p>如果R中的每个候选关键字K均不在S中, 则任选一个关键字, 其属性单独构成一个子关系模式, 加入S</p>
  </li>
  <li>
    <p>从3NF到BCNF、4NF的分解方法</p>
  </li>
  <li>
    <p>找不满足所求NF的函数依赖(多值依赖), 分解之</p>
  </li>
</ul>

<p>第九章:数据库设计</p>

<p>=====================================================================================================================================================================</p>

<p>数据库设计概述</p>

<hr />

<ul>
  <li>
    <p>数据库设计的基本任务</p>
  </li>
  <li>
    <p>根据用户对象的信息需求、处理需求和数据库的支持环境（包括硬件、操作系统与DBMS）设计出数据模式</p>
  </li>
  <li>
    <p>数据库的生命周期</p>
  </li>
  <li>
    <p>需求分析: 数据库设计的第1阶段</p>
  </li>
  <li>
    <p>概念设计: 数据库设计的第2阶段</p>
  </li>
  <li>
    <p>逻辑设计: 数据库设计的第3阶段 &lt;—– DBMS模型</p>
  </li>
  <li>
    <p>物理设计: 数据库设计的第4阶段 &lt;—– 软件, 硬件和网络</p>
  </li>
  <li>
    <p>编码</p>
  </li>
  <li>
    <p>测试</p>
  </li>
  <li>
    <p>运行</p>
  </li>
  <li>
    <p>进一步修改</p>
  </li>
</ul>

<p>数据库设计的需求分析</p>

<hr />

<ul>
  <li>
    <p>需求说明书</p>
  </li>
  <li>
    <p>用户单位对数据的需求 -&gt;</p>
  </li>
  <li>
    <p>需求分析(确定数据库中保存信息的客观事物和相互关系) -&gt;</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  事物, 事物属性, 事物关系
</code></pre></div></div>

<ul>
  <li>需求分析说明书</li>
</ul>

<p>数据库的概念设计</p>

<hr />

<ul>
  <li>
    <p>数据库概念设计的过程</p>
  </li>
  <li>
    <p>用户分解: 用户 -&gt; 功能独立的用户组</p>
  </li>
  <li>
    <p>视图设计: 根据用户需求设计视图</p>
  </li>
  <li>
    <p>视图集成: 局部视图*n -&gt; 全局视图</p>
  </li>
  <li>
    <p>E-R模型: 实体，属性，联系</p>
  </li>
  <li>
    <p>EE-R模型: E-R + 嵌套（实体集属性）、继承</p>
  </li>
</ul>

<p>数据库的逻辑设计</p>

<hr />

<ul>
  <li>
    <p>从E－R模型和扩充E－R模型向关系模型的转换</p>
  </li>
  <li>
    <p>实体集: 关系模式</p>
  </li>
  <li>
    <p>联系: 关系</p>
  </li>
  <li>
    <p>对转换得到的关系模式进行规范化设计</p>
  </li>
  <li>
    <p>根据给定的数据完整性约束发现函数依赖（最小函数依赖集）: 第八章内容</p>
  </li>
  <li>
    <p>关键字的计算: 第八章内容</p>
  </li>
  <li>
    <p>范式的判断及分解: 第八章内容, 至少满足3NF才行</p>
  </li>
</ul>

<p>数据库的物理设计</p>

<hr />

<ul>
  <li>
    <p>索引: 将文件中的记录与其物理地址(即磁盘块)间建立一张对应关系表</p>
  </li>
  <li>
    <p>作用: 加速</p>
  </li>
  <li>
    <p>设计策略</p>
  </li>
  <li>
    <p>在主关键字及外关键字上建立索引: 提速联接查询; 利于检查完整性</p>
  </li>
  <li>
    <p>读为主的关系应尽可能多地建立索引</p>
  </li>
  <li>
    <p>属性的等值查询所得到的结果元组数量较少，则可以考虑对该属性建立索引</p>
  </li>
  <li>
    <p>经常用于统计查询的属性建立索引</p>
  </li>
</ul>

<p>答题解法</p>

<p>======================================================================================================================</p>

<hr />

<ul>
  <li>
    <p>基本概念表示: 图形内写名称</p>
  </li>
  <li>
    <p>实体集: 矩形框</p>
  </li>
  <li>
    <p>属性: 椭圆</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  关键字: 椭圆, 属性名加下划线
</code></pre></div></div>

<ul>
  <li>
    <p>联系: 菱形框</p>
  </li>
  <li>
    <p>连线与标注</p>
  </li>
  <li>
    <p>属性与实体: 无向线段, 一个实体&lt;-&gt;多个属性; 连线上标注 属性基数( , )</p>
  </li>
  <li>
    <p>联系上的属性: 无向线段, 一个联系&lt;-&gt;多个属性; 因联系而产生的属性</p>
  </li>
  <li>
    <p>实体与联系: 无向线段, 多个实体&lt;-&gt;多个联系; 连线上标注 参与基数( , )</p>
  </li>
  <li>
    <p>其他</p>
  </li>
  <li>
    <p>联系上有太多属性和实体, 可以把这个联系变成实体, 与实体的连线变成新的联系</p>
  </li>
</ul>

<p>关系代数和关系演算</p>

<hr />

<h3 id="关系代数">关系代数</h3>

<ul>
  <li>
    <p>解题步骤</p>
  </li>
  <li>
    <p>确定查询目标（结果关系中的属性）</p>
  </li>
  <li>
    <p>明确查询条件</p>
  </li>
  <li>
    <p>选择从条件到目标的查找路径，并据此确定操作对象，即:</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  在操作过程中需要使用到那些关系?

*  这些关系又是如何被联接成一个关系的?
</code></pre></div></div>

<ul>
  <li>关系的合并</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  根据步骤 3) 的分析结果进行关系的联接
</code></pre></div></div>

<ul>
  <li>元组的选择</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  根据步骤 2) 的分析结果(查询条件)进行元组的选择: 用不着的尽快投影掉, 夜长梦多警告
</code></pre></div></div>

<ul>
  <li>属性的指定</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  根据步骤 1) 的分析结果执行投影操作: 别tm漏属性啊啊啊啊啊啊
</code></pre></div></div>

<ul>
  <li>
    <p>解题技巧</p>
  </li>
  <li>
    <p>“所有A都…的B”, 用除法, 被除的对象应当先投影, 以免遗漏</p>
  </li>
  <li>
    <p>用公共属性查私有属性, 先笛卡尔积, 之后用选择, 条件设为同名属性取值相等, 最后投影</p>
  </li>
  <li>
    <p>正面难构造, 就构造反面, 然后用笛卡尔积减去反面</p>
  </li>
  <li>
    <p>最大值最小值, 例子: 取C中最大, C为key-value对</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>D := C

$M = C - \pi_{C.key,C.val}\sigma_{C.val &lt; D.val}(C\times D)$

原理: 每取值跟所有取值比较, 存在更大就会保留, 找出所有的非最大值, 之后减去
</code></pre></div></div>

<ul>
  <li>
    <p>同时满足多个条件, 则取交; 满足多个条件中的一个, 则取并</p>
  </li>
  <li>
    <p>联接可以实现”之一”的效果, 也可以实现相等关系</p>
  </li>
  <li>
    <p>差运算</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  当查询条件带有‘否定’语义，或者具有明显的‘排它性’的时候，通常需要使用两个子查询之间的‘差’运算

*  ‘差’运算的运算对象（关系）中，通常需要包含其关键字
</code></pre></div></div>

<ul>
  <li>“笛卡尔积/θ-连接/自然连接”的使用方法</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  都是关系的合并运算

  *  笛卡尔积是基本运算，θ-连接和自然连接则是扩充运算, 请注意三者的结果关系的关系模式之间的区别

*  笛卡尔积

  *  是实现跨不同关系表进行数据访问的基础, 在笛卡尔积的结果关系中，存在着很多无意义的结果元组，通常需要通过后续的选择运算过滤掉

*  θ-连接

  *  **相邻的“笛卡尔积+选择运算”可以合并为一个θ-连接**

*  自然连接

  *  如果连接条件是基于“两张表中的所有同名属性的相等比较”，可以将θ-连接进一步简写为自然连接

*  一般方法: 笛卡尔积+选择 or θ-连接

  *  不存在同名属性，或者连接条件不是基于同名属性的相等比较

  *  在结果关系中可能存在同名属性，需要加以区别

*  常用方法: 自然连接

  *  连接条件是隐含的（所有同名属性的相等比较）

  *  如果在两个关系之间存在多对‘同名属性’，而本次查询又不需要‘所有’的同名属性都相等，此时有两种选择:

  *  采用前述的一般方法来实现关系的合并

  *  **先对其中的一个关系执行投影运算**，过滤掉其中不需要相等的那些同名属性，然后再使用自然连接运算

*  难点: 关系的自连接

  *  使用**赋值运算定义‘同质不同名’的两个中间关系**(元组集合相同，但关系名不同)，当然也可以对中间关系中的属性进行重命名

  *  然后再使用前述的一般方法实现两个中间关系的合并
</code></pre></div></div>

<ul>
  <li>除</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  ‘除’ 运算与‘联接’运算的区别

*  我们将查询的结果关系称为‘目标对象’，用于定义查询条件的关系称为‘条件对象’

*  在决定某个元组t是否属于结果关系时，

  *  如果只需要从条件对象中找到**一个元组**c并使得查询条件成立，那么就直接使用‘联接’运算（包括笛卡尔积、θ-连接和自然连接）

  *  如果需要条件对象集中的**所有元组**都能使得查询条件成立，那么就使用‘除’运算

*  ‘除’ 运算表达式的表示方法

  *  被除数关系中必须包含目标对象和条件对象的**关键字**

  *  除数关系中只含条件对象的关键字

  *  被除数和除数关系中**不能含其它‘不必要’的多余属性**, 先投影再除
</code></pre></div></div>

<h3 id="关系演算-1">关系演算</h3>

<ul>
  <li>
    <p>从关系代数进行转换</p>
  </li>
  <li>
    <p>基于关系演算的数据查询表示</p>
  </li>
  <li>
    <p>投影</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$\pi_{A_{1},A_{2},\cdots,A_{k}}(R)=\exists x_{k+1},x_{k+2},\cdots ,x_n(R(x_1,x_2,\cdots,x_n))$
</code></pre></div></div>

<ul>
  <li>选择</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$\sigma_F(R)=R(x_1,x_2,\cdots,x_n)\wedge F$

*  相等比较可以直接用常量代替: $\sigma_{x_1=’a’}(R)=R('a’,x_2,\cdots,x_n)\wedge F$
</code></pre></div></div>

<ul>
  <li>笛卡尔积</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\times S = R(p)\wedge S(q)$
</code></pre></div></div>

<ul>
  <li>$\theta$-联接</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\underset{F}{\bowtie} S = R(p)\wedge S(q)\wedge F$
</code></pre></div></div>

<ul>
  <li>自然联接</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\bowtie S = R(x,y,z)\wedge S(t,u,v)$
</code></pre></div></div>

<ul>
  <li>自联接, 重命名</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R(x, g_1)\wedge R(x, g_2)$
</code></pre></div></div>

<ul>
  <li>除法</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\div S=\forall y(S(y)\rightarrow R(x,y))$
</code></pre></div></div>

<ul>
  <li>删除</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R-S = R(u)\wedge \neg S(u)$
</code></pre></div></div>

<ul>
  <li>插入</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$R\cup S = R(t)\vee S(t)$
</code></pre></div></div>

<ul>
  <li>
    <p>修改 = 删除再插入</p>
  </li>
  <li>
    <p>直接构造: 不会玩</p>
  </li>
  <li>
    <p>根据题目中的约束, 直接构造公式, 约束元组</p>
  </li>
  <li>
    <p>刚刚才学到的技巧：蕴含</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  之前说是除法嘛, 其实不仅仅是除法, 表示 任意-都/仅仅 都可以

*  在全称量词后面, 使用蕴含, 记得把蕴含条件的多余变元先 存在掉, 只留下前面限定过的(之前有谓词/量词), 被蕴含的那个也是

*  全称蕴含外面, 有必要的话, 再补一个谓词

*  别TM在全称里面用 且, 根本不可能满足的
</code></pre></div></div>

<p>规范化设计</p>

<hr />

<h3 id="函数依赖">函数依赖</h3>

<ul>
  <li>
    <p>找函数依赖: 随缘, 真的很迷, 不考虑常识, 做卷子的一点体会</p>
  </li>
  <li>
    <p>一对多, 多-&gt;一应该有一个函数依赖</p>
  </li>
  <li>
    <p>一对一, 2个依赖妥妥的</p>
  </li>
  <li>
    <p>多值依赖: 两个一多, 这里可能会有一个多值依赖, 那两个一之间</p>
  </li>
  <li>
    <p>最小依赖集</p>
  </li>
  <li>
    <p>拆 -&gt; 消部分/平凡 -&gt; 消冗余(楞猜) -&gt; 合并</p>
  </li>
  <li>
    <p>关键字</p>
  </li>
  <li>
    <p>只在左, 必在关键字; 只在右, 不在关键字; 都有, 挨个讨论</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>### 规范化设计
</code></pre></div></div>

<ul>
  <li>
    <p>条件: 关键在于非主属性(不在任何关键字的属性)</p>
  </li>
  <li>
    <p>不满足2NF: 非主属性依赖于一个关键字的子集</p>
  </li>
  <li>
    <p>不满足3NF: 非主属性依赖于一个关键字的子集 或 非主属性依赖于非关键字</p>
  </li>
  <li>
    <p>不满足4NF: 能找到多值依赖(非平凡)</p>
  </li>
  <li>
    <p>不满足BCNF: 任何依赖左边不是其关键字</p>
  </li>
  <li>
    <p>注意!分解得到的新关系, 得重新找关键字和非主属性, 在判断满不满足更高要求的范式</p>
  </li>
</ul>

<p>事务和并发</p>

<hr />

<h3 id="能不能冲突串行">能不能冲突串行</h3>

<ul>
  <li>
    <p>优先图: 顶点是事务, 有向边是优先关系</p>
  </li>
  <li>
    <p>找出全部对象, 对每个对象</p>
  </li>
  <li>
    <p>列出所有对这个对象的操作, 看每一对相邻的操作</p>
  </li>
  <li>
    <p>有至少一个是写操作, 则构成一个优先关系, 优先图画一个有向边</p>
  </li>
  <li>
    <p>图中有向边有环, 则不能冲突串行化, 否则可以, 按照图中的偏序关系, 依次执行各个事务就得到可行的串行调度</p>
  </li>
</ul>

<p>### 能不能视图串行</p>

<ul>
  <li>
    <p>整一个串行调度出来, 一般按照每个对象谁先读, 定一个初步的优先关系</p>
  </li>
  <li>
    <p>三个条件, 若原调度视图等价于这个串行调度, 那就视图可串行</p>
  </li>
  <li>
    <p>对每个对象, 哪个事务读初始值, 两个调度一样</p>
  </li>
  <li>
    <p>对每个事务的每次读, 两个调度的读取结果一样(指来自同一个事务的同一次写)</p>
  </li>
  <li>
    <p>对每个对象, 哪个事务最后写, 两个调度一样</p>
  </li>
</ul>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="Courses" /><summary type="html"><![CDATA[数据库期末复习总结]]></summary></entry><entry><title type="html">机器学习导论总结</title><link href="http://localhost:4000/ppx123-web/2022/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/" rel="alternate" type="text/html" title="机器学习导论总结" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/"><![CDATA[<h1 class="no_toc" id="机器学习期末复习总结">机器学习期末复习总结</h1>
<ol id="markdown-toc">
  <li><a href="#第二章-基本术语和模型评估" id="markdown-toc-第二章-基本术语和模型评估">第二章 基本术语和模型评估</a>    <ol>
      <li><a href="#任务" id="markdown-toc-任务">任务</a></li>
      <li><a href="#预测任务根据标记的完整情况" id="markdown-toc-预测任务根据标记的完整情况">预测任务：根据标记的完整情况</a></li>
      <li><a href="#概念学习" id="markdown-toc-概念学习">概念学习</a></li>
      <li><a href="#模型评估与选择" id="markdown-toc-模型评估与选择">模型评估与选择</a>        <ol>
          <li><a href="#评估方法" id="markdown-toc-评估方法">评估方法：</a></li>
          <li><a href="#性能度量" id="markdown-toc-性能度量">性能度量</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#第三章-线性模型" id="markdown-toc-第三章-线性模型">第三章 线性模型</a>    <ol>
      <li><a href="#回归任务掌握" id="markdown-toc-回归任务掌握">回归任务（掌握）</a></li>
      <li><a href="#二分类任务" id="markdown-toc-二分类任务">二分类任务</a></li>
      <li><a href="#多分类任务" id="markdown-toc-多分类任务">多分类任务</a></li>
      <li><a href="#类别不平衡任务" id="markdown-toc-类别不平衡任务">类别不平衡任务</a></li>
    </ol>
  </li>
  <li><a href="#第四章-决策树" id="markdown-toc-第四章-决策树">第四章 决策树</a>    <ol>
      <li><a href="#决策树基本流程" id="markdown-toc-决策树基本流程">决策树基本流程</a>        <ol>
          <li><a href="#基本流程" id="markdown-toc-基本流程">基本流程</a></li>
        </ol>
      </li>
      <li><a href="#决策树算法的关键划分选择" id="markdown-toc-决策树算法的关键划分选择">决策树算法的关键：划分选择</a>        <ol>
          <li><a href="#划分选择-信息增益" id="markdown-toc-划分选择-信息增益">划分选择-信息增益</a></li>
          <li><a href="#信息增益" id="markdown-toc-信息增益">信息增益</a></li>
          <li><a href="#基尼指数cart决策树" id="markdown-toc-基尼指数cart决策树">基尼指数——CART决策树</a></li>
        </ol>
      </li>
      <li><a href="#克服过拟合的问题剪枝处理" id="markdown-toc-克服过拟合的问题剪枝处理">克服过拟合的问题：剪枝处理</a></li>
      <li><a href="#处理多种类型数据连续与缺失值" id="markdown-toc-处理多种类型数据连续与缺失值">处理多种类型数据：连续与缺失值</a></li>
      <li><a href="#决策树的变体多变量决策树" id="markdown-toc-决策树的变体多变量决策树">决策树的变体：多变量决策树</a></li>
    </ol>
  </li>
  <li><a href="#第五章-神经网络" id="markdown-toc-第五章-神经网络">第五章 神经网络</a>    <ol>
      <li><a href="#神经元模型熟悉" id="markdown-toc-神经元模型熟悉">神经元模型：熟悉</a></li>
      <li><a href="#感知机与多层网络熟悉" id="markdown-toc-感知机与多层网络熟悉">感知机与多层网络：熟悉</a>        <ol>
          <li><a href="#感知机" id="markdown-toc-感知机">感知机</a></li>
          <li><a href="#多层前馈神经网络" id="markdown-toc-多层前馈神经网络">多层前馈神经网络</a></li>
          <li><a href="#多层前馈网络表示能力" id="markdown-toc-多层前馈网络表示能力">多层前馈网络表示能力</a></li>
          <li><a href="#多层前馈网络局限" id="markdown-toc-多层前馈网络局限">多层前馈网络局限</a></li>
          <li><a href="#缓解过拟合策略" id="markdown-toc-缓解过拟合策略">缓解过拟合策略</a></li>
        </ol>
      </li>
      <li><a href="#误差逆传播算法熟悉" id="markdown-toc-误差逆传播算法熟悉">误差逆传播算法：熟悉</a>        <ol>
          <li><a href="#bp算法" id="markdown-toc-bp算法">BP算法</a>            <ol>
              <li><a href="#标准bp算法" id="markdown-toc-标准bp算法">标准BP算法</a></li>
              <li><a href="#累计bp算法" id="markdown-toc-累计bp算法">累计BP算法</a></li>
              <li><a href="#实际应用" id="markdown-toc-实际应用">实际应用</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#全局最与局部最了解" id="markdown-toc-全局最与局部最了解">全局最⼩与局部最⼩：了解</a></li>
      <li><a href="#其他常见神经网络了解" id="markdown-toc-其他常见神经网络了解">其他常见神经网络：了解</a></li>
      <li><a href="#深度学习了解" id="markdown-toc-深度学习了解">深度学习：了解</a></li>
    </ol>
  </li>
  <li><a href="#第六章-支持向量机-svm" id="markdown-toc-第六章-支持向量机-svm">第六章 支持向量机 SVM</a>    <ol>
      <li><a href="#间隔与支持向量" id="markdown-toc-间隔与支持向量">间隔与支持向量</a></li>
      <li><a href="#对偶问题" id="markdown-toc-对偶问题">对偶问题</a>        <ol>
          <li><a href="#求解smo" id="markdown-toc-求解smo">求解SMO</a></li>
        </ol>
      </li>
      <li><a href="#核函数" id="markdown-toc-核函数">核函数</a>        <ol>
          <li><a href="#常用的核函数" id="markdown-toc-常用的核函数"><strong>常用的核函数</strong></a></li>
        </ol>
      </li>
      <li><a href="#软间隔与正则化" id="markdown-toc-软间隔与正则化">软间隔与正则化</a>        <ol>
          <li><a href="#软间隔" id="markdown-toc-软间隔">软间隔</a></li>
          <li><a href="#正则化" id="markdown-toc-正则化">正则化</a></li>
        </ol>
      </li>
      <li><a href="#支持向量回归" id="markdown-toc-支持向量回归">支持向量回归</a></li>
      <li><a href="#核方法" id="markdown-toc-核方法">核方法</a></li>
    </ol>
  </li>
  <li><a href="#第七章-贝叶斯分类器" id="markdown-toc-第七章-贝叶斯分类器">第七章 贝叶斯分类器</a>    <ol>
      <li><a href="#掌握贝叶斯决策论" id="markdown-toc-掌握贝叶斯决策论">掌握贝叶斯决策论</a>        <ol>
          <li><a href="#判别式-vs-生成式" id="markdown-toc-判别式-vs-生成式">判别式 vs 生成式</a>            <ol>
              <li><a href="#判别式" id="markdown-toc-判别式">判别式</a></li>
              <li><a href="#生成式" id="markdown-toc-生成式">生成式</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#熟悉极大似然估计" id="markdown-toc-熟悉极大似然估计">熟悉极大似然估计</a></li>
      <li><a href="#熟悉朴素贝叶斯拉普拉斯修正" id="markdown-toc-熟悉朴素贝叶斯拉普拉斯修正">熟悉朴素贝叶斯（拉普拉斯修正）</a>        <ol>
          <li><a href="#估计" id="markdown-toc-估计">估计</a></li>
          <li><a href="#拉普拉斯修正" id="markdown-toc-拉普拉斯修正">拉普拉斯修正</a></li>
          <li><a href="#朴素贝叶斯分类器的使用" id="markdown-toc-朴素贝叶斯分类器的使用">朴素贝叶斯分类器的使用</a></li>
        </ol>
      </li>
      <li><a href="#掌握半朴素贝叶斯" id="markdown-toc-掌握半朴素贝叶斯">掌握半朴素贝叶斯</a>        <ol>
          <li><a href="#spode" id="markdown-toc-spode">SPODE</a></li>
          <li><a href="#tan" id="markdown-toc-tan">TAN</a></li>
          <li><a href="#aode" id="markdown-toc-aode">AODE：</a></li>
          <li><a href="#高阶依赖" id="markdown-toc-高阶依赖">高阶依赖</a></li>
        </ol>
      </li>
      <li><a href="#掌握贝叶斯网" id="markdown-toc-掌握贝叶斯网">掌握贝叶斯网</a></li>
      <li><a href="#了解em算法" id="markdown-toc-了解em算法">了解EM算法</a></li>
    </ol>
  </li>
  <li><a href="#第八章-集成学习" id="markdown-toc-第八章-集成学习">第八章 集成学习</a>    <ol>
      <li><a href="#个体与集成知道个体分类器的定义和集成学习的定义" id="markdown-toc-个体与集成知道个体分类器的定义和集成学习的定义">个体与集成：知道个体分类器的定义和集成学习的定义</a></li>
      <li><a href="#boosting知道boosting的思想和adaboost的实现" id="markdown-toc-boosting知道boosting的思想和adaboost的实现">Boosting：知道Boosting的思想和adaboost的实现</a>        <ol>
          <li><a href="#boosting" id="markdown-toc-boosting">Boosting</a></li>
          <li><a href="#adaboost" id="markdown-toc-adaboost">AdaBoost</a>            <ol>
              <li><a href="#注意事项" id="markdown-toc-注意事项">注意事项</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#bagging与随机森林知道思想和实现的方式" id="markdown-toc-bagging与随机森林知道思想和实现的方式">Bagging与随机森林：知道思想和实现的方式</a>        <ol>
          <li><a href="#bagging算法" id="markdown-toc-bagging算法">Bagging算法</a></li>
          <li><a href="#包外估计" id="markdown-toc-包外估计">包外估计</a></li>
          <li><a href="#随机森林" id="markdown-toc-随机森林">随机森林</a></li>
        </ol>
      </li>
      <li><a href="#结合策略知道集中常用策略以及stacking的优缺点" id="markdown-toc-结合策略知道集中常用策略以及stacking的优缺点">结合策略：知道集中常用策略以及stacking的优缺点</a></li>
      <li><a href="#多样性知道多样性扰动的几种办法" id="markdown-toc-多样性知道多样性扰动的几种办法">多样性：知道多样性扰动的几种办法</a>        <ol>
          <li><a href="#误差-分歧分解" id="markdown-toc-误差-分歧分解">误差-分歧分解</a></li>
          <li><a href="#多样性增强方法" id="markdown-toc-多样性增强方法">多样性增强方法</a></li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h2 id="第二章-基本术语和模型评估">第二章 基本术语和模型评估</h2>

<h3 id="任务">任务</h3>

<p>分类任务：标记为离散值</p>

<p>回归任务：标记为连续纸</p>

<p>聚类任务：标记为空值</p>

<h3 id="预测任务根据标记的完整情况">预测任务：根据标记的完整情况</h3>

<p>监督学习：所有示例有标记，分类、回归</p>

<p>无监督学习：所有实例没有标记，聚类</p>

<p>半监督学习：少量有标记，大量没有标记。</p>

<p>噪音标记学习：有标记，但不完全准确</p>

<h3 id="概念学习">概念学习</h3>

<p>假设空间：所有可能属性的组合</p>

<p>版本空间：与训练集一致的“假设集合”</p>

<p>归纳偏好：学习过程中对某种类型假设的偏好称作归纳偏好</p>

<p>No Free Lunch：总误差与学习算法无关</p>

<h3 id="模型评估与选择">模型评估与选择</h3>

<p>学习器在训练集上的误差称为训练误差或经验误差，在新样本上的误差称为测试误差或泛化误差。</p>

<h4 id="评估方法">评估方法：</h4>

<p>留出法：将数据集划分为两个互斥的集合</p>

<p>交叉验证法：将数据集划分为k个互斥子集，每次用k-1个子集的并作为训练集，余下的作为测试集，k常取10</p>

<p>自助法：从数据集有放回的随机采样m次、</p>

<p>自助法：数据集小，难以划分训练、测试集很有用；产生多个训练集，对集成学习有用</p>

<p>数据量足够，一般采用留出法和交叉验证</p>

<h4 id="性能度量">性能度量</h4>

<p>均方误差（MSE），错误率、精度，P，R，ROC(AUC)，$F_\beta$度量，代价敏感错误率。</p>

<p>ROC：</p>

<p>P：(Precision)查准率$\dfrac{TP}{TP+FP}$，预测结果正例中真实情况为正例占的比例</p>

<p>R：(Recall)查全率$\dfrac{TP}{TP+FN}$，真实情况正例中预测结果为正例占的比例</p>

<p>P-R曲线：P=R，平衡点，可用来度量P-R曲线有交叉的分类器性能的高低</p>

<p>$F_{\beta}=\dfrac{(1+\beta^2)\times P\times R}{(\beta^2\times P)+R}$,$F_\beta$度量，$\beta=1$，标准$F_1$度量。</p>

<p>比较检验（比较评价两个模型）：假设检验：二项检验、T-检验</p>

<p>偏差与方差</p>

<p>泛化误差可分解为方差、偏差与噪声之和</p>

<h2 id="第三章-线性模型">第三章 线性模型</h2>

<h3 id="回归任务掌握">回归任务（掌握）</h3>

<p>最小二乘法原理和推导</p>

<h3 id="二分类任务">二分类任务</h3>

<p>对数几率回归、线性判别分析的建模原理</p>

<p>线性判别分析</p>

<h3 id="多分类任务">多分类任务</h3>

<p>一对一</p>

<p>一对其余</p>

<p>多对多</p>

<h3 id="类别不平衡任务">类别不平衡任务</h3>

<p>欠采样、过采样、阈值移动</p>

<h2 id="第四章-决策树">第四章 决策树</h2>

<h3 id="决策树基本流程">决策树基本流程</h3>

<p>掌握决策树基本流程和原理</p>

<h4 id="基本流程">基本流程</h4>

<p>递归过程，当以下条件停止：</p>

<p>（1）当前节点包含的样本全部属于同一类别</p>

<p>（2）当前属性集为空，或所有样本在所有树性上取值相同</p>

<p>（3）当前节点包含的样本集合为空</p>

<h3 id="决策树算法的关键划分选择">决策树算法的关键：划分选择</h3>

<p>熟悉三种划分准则</p>

<h4 id="划分选择-信息增益">划分选择-信息增益</h4>

<p>信息熵：样本集合D中第k类样本所占的比例为$p_k,(k=1,2,…,|y|)$.</p>

<p>$</p>

<p>Ent(D)=-\sum\limits_{k=1}^{|y|}p_k\log_2{p_k}</p>

<p>$</p>

<p>$Ent(D)$表示集合的纯度 越小越纯</p>

<h4 id="信息增益">信息增益</h4>

<p>离散属性$a$，可能取值有$V$类，产生V个分支节点，第$v$个分支节点包含了D中所有在属性$a$上取值为$a^v$的样本，记为$D^v$。计算用属性a</p>

<p>$</p>

<p>Gain(D,a)=Ent(D)-\sum\limits_{v=1}^V\dfrac{|D^v|}{|D|}Ent(D^v)</p>

<p>$</p>

<p>选择$Gain(D,a)$最大的属性$a$来进行划分。</p>

<p>不足：若编号作为一个属性，信息增益一般远大于其他属性。信息增益指标偏好取值数目较多的属性</p>

<h4 id="基尼指数cart决策树">基尼指数——CART决策树</h4>

<p>C4.5：使用增益率，用属性的取值范围对信息增益做一个规范化。</p>

<p>基尼指数：$Gini(D)=1-\sum\limits_{k=1}^{|y|}p_k^2$.越小越纯</p>

<p>$Gini_index(D,a)=\sum\limits_{v=1}^V\dfrac{|D^v|}{|D|}Gini(D^v)$.选择使得$Gini_index(D,a)$最小的属性</p>

<h3 id="克服过拟合的问题剪枝处理">克服过拟合的问题：剪枝处理</h3>

<p>预剪枝 vs 后剪枝</p>

<p>原因：决策树容易过拟合</p>

<p>预剪枝：决策树生成过程中，对每个结点在划分前先进⾏估计，若当前结点的划分不能带来决策树泛化性能提升，则停⽌划分并将当前结点记为叶结点，其类别标记为训练样例数最多的类别。（边建树，边剪枝）（留出法，用一部分进行验证）</p>

<p>优点：降低过拟合风险，减少时间开销。缺点：欠拟合风险。</p>

<p>后剪枝：先建树，后剪枝</p>

<p>优点：欠拟合风险小 缺点：时间开销大</p>

<h3 id="处理多种类型数据连续与缺失值">处理多种类型数据：连续与缺失值</h3>

<p>了解基本原理</p>

<p>连续：连续属性离散化</p>

<p>缺失：Q1 划分 考虑一个属性时，仅使用当前属性无缺失样本学习</p>

<p>Q2：划分后样本的处理：将样本划分到每一个分支，赋予不同的权重</p>

<h3 id="决策树的变体多变量决策树">决策树的变体：多变量决策树</h3>

<p>了解基本原理</p>

<p>每一个非叶节点是一个线性分类器</p>

<h2 id="第五章-神经网络">第五章 神经网络</h2>

<h3 id="神经元模型熟悉">神经元模型：熟悉</h3>

<p>输入：来自其他n个神经云传递过来的输入信号。</p>

<p>处理：输入信号通过带权重的连接进行传递，神经元接收到总输入值将与神经元的阈值进行比较。</p>

<p>输出：通过激活函数的处理以得到输出。</p>

<h3 id="感知机与多层网络熟悉">感知机与多层网络：熟悉</h3>

<h4 id="感知机">感知机</h4>

<p>两层神经元组成，只能处理线性可分问题。</p>

<h4 id="多层前馈神经网络">多层前馈神经网络</h4>

<p>定义：每层神经元与下一层神经元全互联, 神经元 之间不存在同层连接也不存在跨层连接。</p>

<p>前馈：输入层接受外界输入, 隐含层与输出层神经 元对信号进行加工, 最终结果由输出层神经元输出。</p>

<h4 id="多层前馈网络表示能力">多层前馈网络表示能力</h4>

<p>只需要一个包含足够多神经元的隐含层，多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数。</p>

<h4 id="多层前馈网络局限">多层前馈网络局限</h4>

<p>容易过拟合</p>

<p>如何设置隐层神经元的个数仍然是个未决问题</p>

<h4 id="缓解过拟合策略">缓解过拟合策略</h4>

<p>早停：在训练中，若训练误差降低，但验证误差升高，则停止训练。</p>

<p>正则化：在误差目标函数中增加一项描述网络复杂程度的部分，例如连接权重与阈值的平方和。($E=\lambda\dfrac{1}{m}\sum\limits_{k=1}^mE_k+(1-\lambda)\sum\limits_iw_i^2$)</p>

<h3 id="误差逆传播算法熟悉">误差逆传播算法：熟悉</h3>

<h4 id="bp算法">BP算法</h4>

<p>推导注意链式法则，计算输入层的变化时要对所有的$\beta_j$分别链式法则求和。</p>

<h5 id="标准bp算法">标准BP算法</h5>

<p>每次针对单个训练样例更新权值与阈值。</p>

<p>参数更新频繁，不同样例可能抵消们需要多次迭代。</p>

<h5 id="累计bp算法">累计BP算法</h5>

<p>优点：其优化的目标是最小化整个训练集上的累计误差$E=\dfrac{1}{m}\sum\limits_{k=1}^mE_k$.</p>

<p>缺点：读取整个训练集一遍才对参数进行更新，参数更新频率较低。</p>

<h5 id="实际应用">实际应用</h5>

<p>但在很多任务中，累计误差下降到一定程度后，进一步下降会非常缓慢，这时标准BP算法往往会获得较好的解，尤其当训练集非常大时效果更明显。</p>

<h3 id="全局最与局部最了解">全局最⼩与局部最⼩：了解</h3>

<p>跳出局部最小的策略</p>

<ol>
  <li>
    <p>多组不同的初始参数优化</p>
  </li>
  <li>
    <p>模拟退火技术</p>
  </li>
  <li>
    <p>随机梯度下降</p>
  </li>
  <li>
    <p>遗传算法</p>
  </li>
</ol>

<h3 id="其他常见神经网络了解">其他常见神经网络：了解</h3>

<p>RBF网络：是哟个径向基函数$\rho(x,c_i)=e^{-\beta_i||x-c_i||^2}$作为激活函数</p>

<p>ART:竞争学习，无监督学习</p>

<p>SOM网络：竞争型无监督学习</p>

<p>级联相关网络：将网络结构也作为学习目标</p>

<p>Elman网络:递归神经网络,有反馈.</p>

<h3 id="深度学习了解">深度学习：了解</h3>

<p>深层神经网络最为典型</p>

<p>训练方法:预训练+微调. 预训练:每次训练一层,微调:对整个网络进行微调训练</p>

<p>权共享 (CNN)</p>

<p>理解深度学习:特征工程 VS 特征学习或表示学习</p>

<p>特征工程:手工设计特征</p>

<p>特征学习:通过深度学习自动产生分类的特征</p>

<h2 id="第六章-支持向量机-svm">第六章 支持向量机 SVM</h2>

<h3 id="间隔与支持向量">间隔与支持向量</h3>

<p>寻找超平面将样本划分，找最中间的超平面。</p>

<p>$</p>

<p>\mathop{\arg\max}_{w,b} \dfrac{2}{||w||}\</p>

<p>s.t.\quad y_i(w^Tx_i+b)\geq 1,i=1,2.,…,m\</p>

<p>\Leftrightarrow\</p>

<p>\mathop{\arg\min}_{w,b} \dfrac{||w||^2}{2}\</p>

<p>s.t.\quad y_i(w^Tx_i+b)\geq 1,i=1,2.,…,m</p>

<p>$</p>

<h3 id="对偶问题">对偶问题</h3>

<p>拉格朗日乘子法</p>

<p>$</p>

<p>L(w,b,\alpha)=\dfrac{1}{2}||w||^2-\sum\limits_{i=1}^{m}\alpha_i(y_i(w^Tx_i+b)-1)</p>

<p>$</p>

<p>令$L$对$w,b$的偏导为0可得</p>

<p>$</p>

<p>w=\sum\limits_{i=1}^m\alpha_iy_ix_i,\sum\limits_{i=1}^m\alpha_iy_i=0</p>

<p>$</p>

<p>回代</p>

<p>$</p>

<p>\min_\alpha\quad \dfrac{1}{2}\sum\limits_{i=1}^m\sum\limits_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum\limits_{i=1}^m\alpha_i\</p>

<p>s.t.\quad \sum\limits_{i=1}^m\alpha_iy_i=0\</p>

<p>\alpha_i\geq 0,i=1,2,…,m.</p>

<p>$</p>

<p>最终模型</p>

<p>$</p>

<p>f(x)=w^Tx+b=\sum\limits_{i=1}^m\alpha_iy_ix_i^Tx+b</p>

<p>$</p>

<p>KKT条件</p>

<p>$</p>

<p>\alpha_i\geq 0\</p>

<p>y_if(x_i)\geq 1\</p>

<p>\alpha_i(y_if(x_i)-1)=0</p>

<p>$</p>

<h4 id="求解smo">求解SMO</h4>

<p>基本思路：不断执行如下</p>

<ol>
  <li>
    <p>选取一对需要更新的变量$\alpha_{i},\alpha_j$.</p>
  </li>
  <li>
    <p>固定$\alpha_i,\alpha_j$以外的参数，求解对偶问题更新$\alpha_i,\alpha_j$.注意仅考虑两个变量，约束也视为两个变量的约束，其他视为常数，显然有闭式解。</p>
  </li>
</ol>

<p>b通过支持向量来计算。（对任意支持向量$x_s$，$y_s(\sum\limits_{i=1}^m\alpha_iy_ix_i^Tx_s+b)=1$）</p>

<p>支持向量机解的稀疏性：训练后，模型仅与支持向量有关，及$\alpha_i$不等于0的对应的向量有关。</p>

<h3 id="核函数">核函数</h3>

<p>当空间不线性可分时，将样本从低维映射到一个更高维的特征空间。</p>

<p>样本$x$映射后$\phi(x)$，超平面$f(x)=w^T\phi(x)+b$。在模型中仅以内积的形式出现。</p>

<p>Mercer定理(充分非必要)：只要一个对称函数所对应的核矩阵半正定, 则它就能作为核函数来使用.</p>

<p>$</p>

<p>k(x_i,x_j)=\phi(x_i)^T\phi(x_j)</p>

<p>$</p>

<h4 id="常用的核函数"><strong>常用的核函数</strong></h4>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211225202119165.png" alt="image-20211225202119165" /></p>

<h3 id="软间隔与正则化">软间隔与正则化</h3>

<h4 id="软间隔">软间隔</h4>

<p>现实中, 很难确定合适的核函数使得训练样本在特征空间中线性可分; 同时一个线性可分的结果也很难断定是否是有过拟合造成的.</p>

<p>引入”软间隔”的概念, 允许支持向量机在一些样本上不满足约束.</p>

<p>基本想法：最大化间隔的同时, 让不满足约束的样本应尽可能少</p>

<p>$</p>

<p>\min_{w,b}\quad \dfrac{1}{2}||w||^2+C\sum\limits_{i=1}^ml_{0/1}(y_i(w^T\phi(x_i)+b)-1)</p>

<p>$</p>

<p>$l_{0/1}$是损失函数</p>

<p>$</p>

<p>l_{0/1}(z)=1, z &lt; 0</p>

<p>\</p>

<p>l_{0/1}(z)=0,otherwise</p>

<p>$</p>

<p>替代函数（因为0-1函数不连续）</p>

<p>$</p>

<p>l_{hinge(z)}=\max(0,1-z)</p>

<p>$</p>

<p>模型</p>

<p>原始问题</p>

<p>$</p>

<p>\mathop{\arg\min}<em>{w,b} \dfrac{||w||^2}{2}+C\sum\limits</em>{i=1}^m\max(0,1-y_i(w^T\phi(x_i)+b))\</p>

<p>s.t.\quad y_i(w^Tx_i+b)\geq 1,i=1,2.,…,m</p>

<p>$</p>

<p>对偶问题</p>

<p>$</p>

<p>\min_\alpha\quad \dfrac{1}{2}\sum\limits_{i=1}^m\sum\limits_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum\limits_{i=1}^m\alpha_i\</p>

<p>s.t.\quad \sum\limits_{i=1}^m\alpha_iy_i=0\</p>

<p>C\geq \alpha_i\geq 0,i=1,2,…,m.</p>

<p>$</p>

<h4 id="正则化">正则化</h4>

<p>$</p>

<p>\min_f\quad \Omega(f)+C\sum\limits_{i=1}^ml(f(x_i),y_i)</p>

<p>$</p>

<p>第一项是结构风险（描述模型的某些性质），第二项是经验风险（描述模型与训练数据的契合程度）</p>

<h3 id="支持向量回归">支持向量回归</h3>

<p>特点: 允许模型输出和实际输出间存在$2\epsilon$的偏差</p>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211225203203092.png" alt="image-20211225203203092" /></p>

<p>损失函数</p>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211225203230958.png" alt="image-20211225203230958" /></p>

<h3 id="核方法">核方法</h3>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211225203439450.png" alt="image-20211225203439450" /></p>

<p>推广：核LDA（线性模型中提到），核PCA</p>

<h2 id="第七章-贝叶斯分类器">第七章 贝叶斯分类器</h2>

<h3 id="掌握贝叶斯决策论">掌握贝叶斯决策论</h3>

<p>给定N个类别，令$\lambda_{ij}$代表将第$j$类样本误分类为第$i$类所产生的损失，</p>

<p>将样本$x$分到第$i$类的条件风险为：</p>

<p>$</p>

<p>R(c_i|\mathbf{x})=\sum\limits_{j=1}^N\lambda_{ij}P(c_j|\mathbf{x})</p>

<p>$</p>

<p>贝叶斯判定准则</p>

<p>$</p>

<p>h^*(\mathbf{x})=\mathop{\arg\min}_{c\in Y}R(c|\mathbf{x})</p>

<p>$</p>

<p>$h^*$成为被贝叶斯最优分类器，总风险成为贝叶斯风险，反应学习性能的理论上限。</p>

<h4 id="判别式-vs-生成式">判别式 vs 生成式</h4>

<h5 id="判别式">判别式</h5>

<p>直接对$P(c|\mathbf{x})$建模如决策树，BP神经网络，SVM</p>

<h5 id="生成式">生成式</h5>

<p>先对$P(\mathbf{x},c)$建模，再由次获得$P(c|\mathbf{x})$.</p>

<p>$</p>

<p>P(c|\mathbf{x})=\dfrac{P(\mathbf{x},c)}{P(\mathbf{x})}=\dfrac{P(c)P(\mathbf{x}|c)}{P(\mathbf{x})}</p>

<p>$</p>

<p>代表：贝叶斯分类器，（贝叶斯分类器$\neq$贝叶斯学习）</p>

<h3 id="熟悉极大似然估计">熟悉极大似然估计</h3>

<p>先假设某种概率分布形式，再基于训练样例对参数进行估计</p>

<p>设$P(x|c)$具有某种概率分布，参数$\theta_c$.</p>

<p>$\theta_c$对训练集D中第c类样本组成的集合$D_c$的似然为</p>

<p>$</p>

<p>P(D_c|\theta_c)=\prod_{x\in D_c}P(x|\theta_c)</p>

<p>$</p>

<p>连乘容易下溢，故通常使用对数似然LL</p>

<p>$LL(\theta_c)=\log{P(D_c|\theta_c)}=\sum_{x\in D_c}\log{P(x|\theta_c)}$</p>

<p>$\hat{\theta}_c=\arg\max_{\theta_c}{LL(\theta)}$</p>

<h3 id="熟悉朴素贝叶斯拉普拉斯修正">熟悉朴素贝叶斯（拉普拉斯修正）</h3>

<p>主要障碍：所有属性上的联合概率难以从有限训练样本估计获得</p>

<p>组合爆炸；样本稀疏</p>

<p>基本思路：假定属性独立</p>

<p>$</p>

<p>P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}=\dfrac{P(c)}{P(x)}\prod_{i=1}^dP(x_i|c)</p>

<p>$</p>

<h4 id="估计">估计</h4>

<p>$P(c)=\dfrac{|D_c|}{|D|}$.</p>

<p>$P(x|c)$:</p>

<p>对离散属性，$D_{c,x_i}$表示$D_c$在第i个属性上取值为$x_i$的样本组成的集合，则$P(x_i|c)=\dfrac{|D_{c,x_i}|}{|D_c|}$.</p>

<p>对连续属性，考虑概率密度函数，假定$P(x_i|c)\sim N(\mu_{c,i},\sigma^2_{c,i})$.</p>

<h4 id="拉普拉斯修正">拉普拉斯修正</h4>

<p>若某个属性值在训练集中没有与某个类同时出现过，则直接计算会出现 问题，因为概率连乘将“抹去”其他属性提供的信息。</p>

<p>$P(c)=\dfrac{|D_c|+1}{|D|+N}$.$P(x_i|c)=\dfrac{|D_{c,x_i}|+1}{|D_c|+N_i}$.</p>

<h4 id="朴素贝叶斯分类器的使用">朴素贝叶斯分类器的使用</h4>

<p>若对预测速度要求高：预计算所有概率估值，使用时“查表”</p>

<p>若数据更替频繁：不进行任何训练，收到预测请求时再估值 (懒惰学习, lazy learning)</p>

<p>若数据不断增加：基于现有估值，对新样本涉及的概率估值进行修正 (增量学习, incremental learning)</p>

<h3 id="掌握半朴素贝叶斯">掌握半朴素贝叶斯</h3>

<p>基本思路：适当考虑一部分属性间的相互依赖信息</p>

<p>最常用策略：独依赖估计 (One-Dependent Estimator, ODE)</p>

<p>假设每个属性在类别之外最多仅依赖一个其他属性</p>

<p>$</p>

<p>P(c|x)\propto P(c)\prod_{i=1}^d P(x_i|c,pa_i)</p>

<p>$</p>

<h4 id="spode">SPODE</h4>

<p>假设所有属性都依赖于同一属性，称为“超父” (Super-Parent)， 然后通过交叉验证等模型选择方法来确定超父属性</p>

<h4 id="tan">TAN</h4>

<p>以属性间的条件”互信息”(mutual information)为边的权重，构建完全图，再利用最大带权生成树算法，仅保留强相关属性间的依赖性</p>

<h4 id="aode">AODE：</h4>

<p>尝试将每个属性作为超父构建 SPODE</p>

<p>将拥有足够训练数据支撑的 SPODE 集成起来作为最终结果</p>

<p>$</p>

<p>P(c|x)\propto \sum_{i=1,|D_{x_i}|\geq m’}^d P(c,x_i)\prod_{j=1}^d P(x_j|c,x_i)\</p>

<p>\hat{P}(c,x_i)=\dfrac{|D_{c,x_i}|+1}{|D|+N_i}\</p>

<p>\hat{P}(x_j|c,x_i)=\dfrac{|D_{c,x_i,x_j}|+1}{|D_{c,x_i}|+N_j}</p>

<p>$</p>

<h4 id="高阶依赖">高阶依赖</h4>

<p>需要充分的样本</p>

<h3 id="掌握贝叶斯网">掌握贝叶斯网</h3>

<h3 id="了解em算法">了解EM算法</h3>

<h2 id="第八章-集成学习">第八章 集成学习</h2>

<h3 id="个体与集成知道个体分类器的定义和集成学习的定义">个体与集成：知道个体分类器的定义和集成学习的定义</h3>

<p>集成学习通过构建并结合多个学习器来提升性能</p>

<h3 id="boosting知道boosting的思想和adaboost的实现">Boosting：知道Boosting的思想和adaboost的实现</h3>

<h4 id="boosting">Boosting</h4>

<p>个体学习器存在强依赖关系，串行生成，每次调整训练数据样本分布</p>

<h4 id="adaboost">AdaBoost</h4>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211226162942021.png" alt="image-20211226162942021" /></p>

<p>($Z_t$是规范化因子，保证权重之和是1)</p>

<p>基学习器的线性组合</p>

<p>$</p>

<p>H(x)=\sum_{t=1}^T\alpha_th_t(x)</p>

<p>$</p>

<p>最小化指数损失函数</p>

<p>$</p>

<p>l_{exp}(H|D)=E_{x\sim D}[e^{-f(x)H(x)}]</p>

<p>$</p>

<h5 id="注意事项">注意事项</h5>

<p>数据分布的学习：重赋权法，重采样法</p>

<p>重启动，避免训练过程过早停止，（8.5处，如果学习的分类器不佳）</p>

<h3 id="bagging与随机森林知道思想和实现的方式">Bagging与随机森林：知道思想和实现的方式</h3>

<p>个体学习器不存在强依赖关系</p>

<p>并行化生成</p>

<p>自助采样法</p>

<h4 id="bagging算法">Bagging算法</h4>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211226164842877.png" alt="image-20211226164842877" /></p>

<p>($D_{bs}$是自助采样产生的样本分布)</p>

<p>时间复杂度低 :</p>

<ol>
  <li>
    <p>假定基学习器的计算复杂度为O(m)，采样与投票/平均过程的复杂度 为O(s)，则bagging的复杂度大致为T(O(m)+O(s))</p>
  </li>
  <li>
    <p>由于O(s)很小且T是一个不大的常数</p>
  </li>
  <li>
    <p>因此训练一个bagging集成与直接使用基学习器的复杂度同阶</p>
  </li>
</ol>

<p>可使用包外估计</p>

<h4 id="包外估计">包外估计</h4>

<p>可以计算泛化误差等</p>

<h4 id="随机森林">随机森林</h4>

<p>采样的随机性，属性的随机性</p>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211226165628669.png" alt="image-20211226165628669" /></p>

<h3 id="结合策略知道集中常用策略以及stacking的优缺点">结合策略：知道集中常用策略以及stacking的优缺点</h3>

<p>平均法：如加权平均法</p>

<p>投票法：绝对多数投票法和相对多数投票法</p>

<p>学习法：Stacking 先从初始数据集训练出初级学习器，然后”生成”一个新数据集用于训练次级学习器.</p>

<p>在训练阶段，次级训练集是利用初级学习器产生的，若直接用初级学习器 的训练集来产生次级训练集，则过拟合风险会比较大;因此一般是通过使用交叉验证或留一法这样的方式，用训练初级学习器未使用的样本来产生次级学习器的训练样本.</p>

<h3 id="多样性知道多样性扰动的几种办法">多样性：知道多样性扰动的几种办法</h3>

<h4 id="误差-分歧分解">误差-分歧分解</h4>

<p>$</p>

<p>E=\bar{E}-\bar{A}</p>

<p>$</p>

<p>($\bar{E}$表示个体学习器泛化误差的加权评分，$\bar{A}$表示个体学习器的加权分歧值。)</p>

<p>个体学习器精确性越高、多样性越大，则集成效果越好</p>

<h4 id="多样性增强方法">多样性增强方法</h4>

<p>数据样本扰动：</p>

<ol>
  <li>采样</li>
</ol>

<p>输入属性扰动：</p>

<ol>
  <li>随机子空间算法</li>
</ol>

<p>输出表示扰动：</p>

<ol>
  <li>
    <p>翻转法：随机改变输入样本的标记</p>
  </li>
  <li>
    <p>输出调剂法：分类输出改为回归输出得到分类器</p>
  </li>
  <li>
    <p>ECOC法：多类任务分解为一系列两类任务来求解</p>
  </li>
</ol>

<p>算法参数扰动：</p>

<ol>
  <li>
    <p>负相关法：强制要求个体神经网络采用不同的参数</p>
  </li>
  <li>
    <p>不同的多样性增强机制同时使用</p>
  </li>
</ol>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="Courses" /><summary type="html"><![CDATA[机器学习导论期末复习总结，建议复习再多看看细节的概念]]></summary></entry><entry><title type="html">毛概总结</title><link href="http://localhost:4000/ppx123-web/2022/01/15/%E6%AF%9B%E6%A6%82/" rel="alternate" type="text/html" title="毛概总结" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/%E6%AF%9B%E6%A6%82</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/%E6%AF%9B%E6%A6%82/"><![CDATA[<h1 class="no_toc" id="毛概复习">毛概复习</h1>
<ol id="markdown-toc">
  <li><a href="#考试内容及复习方式" id="markdown-toc-考试内容及复习方式">考试内容及复习方式</a></li>
  <li><a href="#第一章-第二节-毛泽东思想的主要内容和活的灵魂" id="markdown-toc-第一章-第二节-毛泽东思想的主要内容和活的灵魂">第一章 第二节 毛泽东思想的主要内容和活的灵魂</a>    <ol>
      <li><a href="#毛泽东思想的主要内容" id="markdown-toc-毛泽东思想的主要内容">毛泽东思想的主要内容</a></li>
      <li><a href="#毛泽东思想活的灵魂" id="markdown-toc-毛泽东思想活的灵魂">毛泽东思想活的灵魂</a></li>
    </ol>
  </li>
  <li><a href="#第二章-第二节-新民主主义革命的总路线和基本纲领" id="markdown-toc-第二章-第二节-新民主主义革命的总路线和基本纲领">第二章 第二节 新民主主义革命的总路线和基本纲领</a>    <ol>
      <li><a href="#总路线的内容" id="markdown-toc-总路线的内容">总路线的内容</a></li>
      <li><a href="#新民主主义革命的动力" id="markdown-toc-新民主主义革命的动力">新民主主义革命的动力</a></li>
      <li><a href="#革命的领导阶级是无产阶级" id="markdown-toc-革命的领导阶级是无产阶级">革命的领导阶级是无产阶级</a></li>
      <li><a href="#新民主主义革命的性质和前途" id="markdown-toc-新民主主义革命的性质和前途">新民主主义革命的性质和前途</a></li>
      <li><a href="#基本纲领" id="markdown-toc-基本纲领">基本纲领</a></li>
    </ol>
  </li>
  <li><a href="#第三章-第三节-社会主义制度在中国的确立" id="markdown-toc-第三章-第三节-社会主义制度在中国的确立">第三章 第三节 社会主义制度在中国的确立</a>    <ol>
      <li><a href="#社会主义基本制度的确立及其理论根据" id="markdown-toc-社会主义基本制度的确立及其理论根据">社会主义基本制度的确立及其理论根据</a></li>
      <li><a href="#重大意义" id="markdown-toc-重大意义">重大意义</a></li>
    </ol>
  </li>
  <li><a href="#第四章-第二节-初步探索的意义和经验教训" id="markdown-toc-第四章-第二节-初步探索的意义和经验教训">第四章 第二节 初步探索的意义和经验教训</a>    <ol>
      <li><a href="#初步探索的意义" id="markdown-toc-初步探索的意义">初步探索的意义</a></li>
      <li><a href="#初步探索的经验教训" id="markdown-toc-初步探索的经验教训">初步探索的经验教训</a></li>
    </ol>
  </li>
  <li><a href="#第五章-第二节-邓小平理论的基本问题和主要内容" id="markdown-toc-第五章-第二节-邓小平理论的基本问题和主要内容">第五章 第二节 邓小平理论的基本问题和主要内容</a>    <ol>
      <li><a href="#基本问题" id="markdown-toc-基本问题">基本问题</a></li>
      <li><a href="#主要内容" id="markdown-toc-主要内容">主要内容</a></li>
    </ol>
  </li>
  <li><a href="#第七章-第二节-科学发展观的科学内涵和主要内容" id="markdown-toc-第七章-第二节-科学发展观的科学内涵和主要内容">第七章 第二节 科学发展观的科学内涵和主要内容</a>    <ol>
      <li><a href="#科学内涵" id="markdown-toc-科学内涵">科学内涵</a></li>
      <li><a href="#主要内容-1" id="markdown-toc-主要内容-1">主要内容</a></li>
    </ol>
  </li>
  <li><a href="#第八章-习近平新时代中国特社会主义思想及其历史地位" id="markdown-toc-第八章-习近平新时代中国特社会主义思想及其历史地位">第八章 习近平新时代中国特⾊社会主义思想及其历史地位</a>    <ol>
      <li><a href="#第一节-习近平新时代中国特色社会主义思想创立的社会历史条件重点是新时代和大变局" id="markdown-toc-第一节-习近平新时代中国特色社会主义思想创立的社会历史条件重点是新时代和大变局">第一节 习近平新时代中国特色社会主义思想创立的社会历史条件（重点是新时代和大变局）</a>        <ol>
          <li><a href="#中国特色社会主义新时代的变与不变" id="markdown-toc-中国特色社会主义新时代的变与不变">中国特色社会主义新时代的变与不变</a></li>
          <li><a href="#世界正经历百年未有之大变局" id="markdown-toc-世界正经历百年未有之大变局">世界正经历百年未有之大变局</a></li>
        </ol>
      </li>
      <li><a href="#第三节-习近平新时代中国特色社会主义思想的历史地位" id="markdown-toc-第三节-习近平新时代中国特色社会主义思想的历史地位">第三节 习近平新时代中国特色社会主义思想的<strong>历史地位</strong></a></li>
    </ol>
  </li>
  <li><a href="#第九章-坚持和发展中国特色社会主义的总任务" id="markdown-toc-第九章-坚持和发展中国特色社会主义的总任务">第九章 坚持和发展中国特色社会主义的总任务</a>    <ol>
      <li><a href="#第二节-建成社会主义现代化强国的战略安排" id="markdown-toc-第二节-建成社会主义现代化强国的战略安排">第二节 建成社会主义现代化强国的战略安排</a></li>
      <li><a href="#第三节-建设社会主义现代化国家的战略导向" id="markdown-toc-第三节-建设社会主义现代化国家的战略导向">第三节 建设社会主义现代化国家的战略导向</a>        <ol>
          <li><a href="#新发展阶段" id="markdown-toc-新发展阶段">新发展阶段</a></li>
          <li><a href="#新发展理念" id="markdown-toc-新发展理念">新发展理念</a></li>
          <li><a href="#新发展格局" id="markdown-toc-新发展格局">新发展格局</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#第十章-五位一体总布局" id="markdown-toc-第十章-五位一体总布局">第十章 “五位一体”总布局</a>    <ol>
      <li><a href="#第一节-实现经济高质量发展" id="markdown-toc-第一节-实现经济高质量发展">第一节 实现经济高质量发展</a>        <ol>
          <li><a href="#坚持习近平经济思想" id="markdown-toc-坚持习近平经济思想">坚持习近平经济思想</a>            <ol>
              <li><a href="#实现高质量发展的途径ppt无书上的" id="markdown-toc-实现高质量发展的途径ppt无书上的">实现高质量发展的途径（ppt无，书上的）</a></li>
            </ol>
          </li>
          <li><a href="#供给侧结构性改革" id="markdown-toc-供给侧结构性改革">供给侧结构性改革</a>            <ol>
              <li><a href="#内涵" id="markdown-toc-内涵">内涵</a></li>
              <li><a href="#背景" id="markdown-toc-背景">背景</a></li>
              <li><a href="#举措" id="markdown-toc-举措">举措</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#第二节-发展社会主义民主政治" id="markdown-toc-第二节-发展社会主义民主政治">第二节 发展社会主义民主政治</a>        <ol>
          <li><a href="#坚持中国特色社会主义政治发展道路" id="markdown-toc-坚持中国特色社会主义政治发展道路">坚持中国特色社会主义政治发展道路</a></li>
          <li><a href="#健全人民当家做主制度体系" id="markdown-toc-健全人民当家做主制度体系">健全人民当家做主制度体系</a></li>
          <li><a href="#巩固和发展爱国统一战线非主要" id="markdown-toc-巩固和发展爱国统一战线非主要">巩固和发展爱国统一战线（非主要）</a></li>
        </ol>
      </li>
      <li><a href="#第三节-建设社会主义文化强国" id="markdown-toc-第三节-建设社会主义文化强国">第三节 建设社会主义文化强国</a>        <ol>
          <li><a href="#坚持马克思主义在意识形态领域指导地位的根本制度" id="markdown-toc-坚持马克思主义在意识形态领域指导地位的根本制度">坚持马克思主义在意识形态领域指导地位的根本制度</a></li>
          <li><a href="#社会主义核心价值观" id="markdown-toc-社会主义核心价值观">社会主义核心价值观</a>            <ol>
              <li><a href="#做法" id="markdown-toc-做法">做法</a></li>
            </ol>
          </li>
          <li><a href="#坚定文化自信繁荣发展社会主义文化" id="markdown-toc-坚定文化自信繁荣发展社会主义文化">坚定文化自信，繁荣发展社会主义文化</a></li>
          <li><a href="#ppt补充做法" id="markdown-toc-ppt补充做法">（ppt补充）做法</a></li>
          <li><a href="#推进社会主义文化强国建设" id="markdown-toc-推进社会主义文化强国建设">推进社会主义文化强国建设</a></li>
        </ol>
      </li>
      <li><a href="#第四节-加强以民生为重点的社会建设" id="markdown-toc-第四节-加强以民生为重点的社会建设">第四节 加强以民生为重点的社会建设</a>        <ol>
          <li><a href="#发展中保障和改善民生提高保障和改善民生水平" id="markdown-toc-发展中保障和改善民生提高保障和改善民生水平">发展中保障和改善民生（提高保障和改善民生水平）</a></li>
          <li><a href="#加强和创新社会治理" id="markdown-toc-加强和创新社会治理">加强和创新社会治理</a></li>
          <li><a href="#社会治理面临新挑战" id="markdown-toc-社会治理面临新挑战">社会治理面临新挑战</a></li>
          <li><a href="#加强和创新社会治理的举措" id="markdown-toc-加强和创新社会治理的举措">加强和创新社会治理的举措</a></li>
        </ol>
      </li>
      <li><a href="#第十章思考题" id="markdown-toc-第十章思考题">第十章思考题</a>        <ol>
          <li><a href="#1如何准确把握习近平经济思想的主要内容" id="markdown-toc-1如何准确把握习近平经济思想的主要内容">1.如何准确把握习近平经济思想的主要内容?</a></li>
          <li><a href="#2供给侧结构性改革的背景内涵及对策" id="markdown-toc-2供给侧结构性改革的背景内涵及对策">2.供给侧结构性改革的背景、内涵及对策?</a></li>
          <li><a href="#3保障人民当家作主的制度体系包括哪些内容" id="markdown-toc-3保障人民当家作主的制度体系包括哪些内容">3.保障人民当家作主的制度体系包括哪些内容?</a></li>
          <li><a href="#4如何提升文化软实力建设中国特色的文化强国" id="markdown-toc-4如何提升文化软实力建设中国特色的文化强国">4.如何提升文化软实力，建设中国特色的文化强国?</a></li>
          <li><a href="#5如何加强制度建设推进共同富裕" id="markdown-toc-5如何加强制度建设推进共同富裕">5.如何加强制度建设推进共同富裕?</a></li>
          <li><a href="#6如何加强和创新社会治理" id="markdown-toc-6如何加强和创新社会治理">6.如何加强和创新社会治理?</a></li>
        </ol>
      </li>
    </ol>
  </li>
  <li><a href="#第十一章-第一节-全面建设社会主义现代化国家" id="markdown-toc-第十一章-第一节-全面建设社会主义现代化国家">第十一章 第一节 全面建设社会主义现代化国家</a>    <ol>
      <li><a href="#从全面建成小康社会到全面建设社会主义现代化国家" id="markdown-toc-从全面建成小康社会到全面建设社会主义现代化国家">从全面建成小康社会到全面建设社会主义现代化国家</a></li>
      <li><a href="#脱贫攻坚经验" id="markdown-toc-脱贫攻坚经验">脱贫攻坚经验</a></li>
      <li><a href="#中国社会主义现代化国家的基本特征" id="markdown-toc-中国社会主义现代化国家的基本特征">中国社会主义现代化国家的基本特征</a></li>
    </ol>
  </li>
  <li><a href="#第十二章-第一节-坚持总体国家安全观" id="markdown-toc-第十二章-第一节-坚持总体国家安全观">第十二章 第一节 坚持总体国家安全观</a>    <ol>
      <li><a href="#国家安全是安邦定国的重要基石" id="markdown-toc-国家安全是安邦定国的重要基石">国家安全是安邦定国的重要基石</a></li>
      <li><a href="#国家总体安全观" id="markdown-toc-国家总体安全观">国家总体安全观</a></li>
      <li><a href="#坚持总体国家安全观的意义" id="markdown-toc-坚持总体国家安全观的意义">坚持总体国家安全观的意义</a></li>
      <li><a href="#坚持走中国特色社会国家安全道路" id="markdown-toc-坚持走中国特色社会国家安全道路">坚持走中国特色社会国家安全道路</a></li>
      <li><a href="#着力防范化解重大风险" id="markdown-toc-着力防范化解重大风险">着力防范化解重大风险</a></li>
    </ol>
  </li>
  <li><a href="#第十三章-第二节-坚持走和平发展道路" id="markdown-toc-第十三章-第二节-坚持走和平发展道路">第十三章 第二节 坚持走和平发展道路</a>    <ol>
      <li><a href="#坚持独立自主和平外交政策" id="markdown-toc-坚持独立自主和平外交政策">坚持独立自主和平外交政策</a></li>
      <li><a href="#推动建设新型国际关系" id="markdown-toc-推动建设新型国际关系">推动建设新型国际关系</a></li>
    </ol>
  </li>
</ol>

<h1 id="考试内容及复习方式">考试内容及复习方式</h1>

<p>名词解释：4pt x 5  不需要答太多，也不能太少</p>

<p>简答题：10pt x 4    答要点</p>

<p>论述题：一道材料题，一道仅题干。需要观点，要点，结合实际。</p>

<p>1-7章 看ppt，教材均可，8-10 看ppt，11-13 看教材</p>

<p>注意课件中的侧重点</p>

<h1 id="第一章-第二节-毛泽东思想的主要内容和活的灵魂">第一章 第二节 毛泽东思想的主要内容和活的灵魂</h1>

<h2 id="毛泽东思想的主要内容">毛泽东思想的主要内容</h2>

<p>1.新民主主义革命理论：指明了新民主主义革命的对象、动力、领导力量、性质和前途等基本问题。</p>

<p>两个基本点： 一是关于中国资产阶级双重性的分析；二是关于中国革命主要形式是长期武装斗争的科学判断。</p>

<p>2.社会主义革命和社会主义建设理论</p>

<p>（1）社会主义革命理论：三大改造，社会主义现代化。——非暴力的社会主义革命新路。</p>

<p>（2）社会主义建设理论：尝试突破“苏联模式”的限制，探索中国社会主义的建设道路；社会主义矛盾理论、社会主义工业化道路、文化发展理论，等等。</p>

<p>3.革命军队建设和军事战略的理论</p>

<p>4.政治和策略理论</p>

<p>5.思想政治工作和文化工作理论</p>

<p>6.党的建设理论</p>

<h2 id="毛泽东思想活的灵魂">毛泽东思想活的灵魂</h2>

<p>贯穿于毛泽东思想各个组成部分的立场、观点和方法，是毛泽东思想的活的灵魂，</p>

<p>三个基本方面，即<strong>实事求是，群众路线，独立自主</strong>。</p>

<p>1.实事求是：党的思想路线是一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理</p>

<p>2.群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p>

<p>3.独立自主：坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。</p>

<h1 id="第二章-第二节-新民主主义革命的总路线和基本纲领">第二章 第二节 新民主主义革命的总路线和基本纲领</h1>

<h2 id="总路线的内容">总路线的内容</h2>

<p>1948年在《在晋绥干部会议上的讲话》提出：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。</p>

<h2 id="新民主主义革命的动力">新民主主义革命的动力</h2>

<p>动力：人民大众，包括⽆产阶级、农⺠阶级、城市⼩资产阶级和 ⺠族资产阶级。</p>

<p>无产阶级是中国革命最基本的动力</p>

<p>农民是中国民主革命的主力军（中农20%、贫农70%）</p>

<p>小资产阶级是中国无产阶级可靠的同盟者</p>

<p>民族资产阶级也是中国革命的动力之一（两面性）</p>

<h2 id="革命的领导阶级是无产阶级">革命的领导阶级是无产阶级</h2>

<h2 id="新民主主义革命的性质和前途">新民主主义革命的性质和前途</h2>

<p>性质：资产阶级民主主义革命。</p>

<p>新民主主义革命已经成为世界无产阶级革命的一个重要组成部分；新民主主义革命的领导力量是中国无产阶级及其先锋队——中国共产党；</p>

<p>新民主主义革命的指导思想是马克思列宁主义；新民主主义革命的前途是通过新民主主义社会最终实现向社会主义的过渡。</p>

<h2 id="基本纲领">基本纲领</h2>

<p>新民主主义的政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。</p>

<p>回答了：1.国体问题。2.政体问题。</p>

<p>新民主主义经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。</p>

<p>新民主主义的文化纲领：无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。</p>

<h1 id="第三章-第三节-社会主义制度在中国的确立">第三章 第三节 社会主义制度在中国的确立</h1>

<p>1956年底我国对农业、手工业和资本主义工商业的社会主义改造基本完成，标志着中国历史上长达数千年的阶级剥削制度的结束，实现了我国社会由新民主主义向社会主义的转变，社会主义制度在我国初步确立，我国进入社会主义初级阶段。</p>

<h2 id="社会主义基本制度的确立及其理论根据">社会主义基本制度的确立及其理论根据</h2>

<p>社会主义经济制度的确立：社会主义改造的基本完成，以生产资料公有制为基础的社会主义基本经济制度已经建立起来。</p>

<p>社会主义政治制度的确立：第一届人大，《中华人民共和国宪法》。</p>

<p>人民代表大会制度这一根本政治制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度这些基本政治制度的确立，表明我国由一个新民主主义的国家转变为社会主义国家。</p>

<p>社会的阶级关系和主要矛盾发生根本变化：剥削阶级已经被消灭，工人阶级成为国家的领导阶级；人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾，成为国内的主要矛盾。</p>

<h2 id="重大意义">重大意义</h2>

<p>第一，社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。</p>

<p>第二、社会主义制度的确立极大地提高了工人阶级和广大劳动人民的积极性和创造性，促进社会生产力的发展。</p>

<p>第三，社会主义基本制度的确立，初步显示了社会主义制度的优越性。</p>

<p>第四，中国社会主义基本制度的确立，使占世界人口四分之一的东方大国进入了社会主义社会，这是世界社会主义运动历史上又一个历史性的伟大胜利。</p>

<p>第五，在一个经济文化落后的东方大国中顺利地实现了从新民主主义到社会主义的转变，建立了社会主义的基本制度，是马克思列宁主义关于社会主义革命理论在中国正确运用和创造性发展的结果。</p>

<p>从新民主主义社会向社会主义社会过渡是一个历史发展的必然。中国共产党坚持马克思主义基本理论的指导，结合中国社会主义革命的具体实践，成功完成了“三大改造”的任务，实现了中国历史上最深刻最伟大的社会变革。为当代中国一切发展进步奠定了根本的政治前提和制度基础，实现了中华民族由近代不断衰落到根本扭转命运、持续走向繁荣富强的伟大飞跃。</p>

<h1 id="第四章-第二节-初步探索的意义和经验教训">第四章 第二节 初步探索的意义和经验教训</h1>

<h2 id="初步探索的意义">初步探索的意义</h2>

<p>巩固和发展了我国的社会主义制度</p>

<p>为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础</p>

<p>丰富了科学社会主义的理论和实践</p>

<h2 id="初步探索的经验教训">初步探索的经验教训</h2>

<p>必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。</p>

<p>必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。</p>

<p>必须从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成。</p>

<p>必须发展社会主义民主，健全社会主义法制。</p>

<p>必须坚持党的民主集中制和集体领导制度，加强执政党建设。</p>

<p>必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。</p>

<p>总结：初步探索时期我们对如何建设社会主义的问题展开了重要的理论与实践探索，这一过程中既取得了宝贵的经验、也留下了深刻的教训，这些成功的经验与深刻的教训都构成了我们在继续推进中国特色社会主义的伟大历史征程中所必须要加以珍视的宝贵财富。不能采取形而上学的态度将改革开放前后两个历史时期割裂开来，这两个时期都是我们党领导人民进行社会主义建设的实践探索，是相互衔接、有机统一的整体。</p>

<h1 id="第五章-第二节-邓小平理论的基本问题和主要内容">第五章 第二节 邓小平理论的基本问题和主要内容</h1>

<h2 id="基本问题">基本问题</h2>

<p>什么是社会主义,怎样建设社会主义.</p>

<p>关键要认清社会主义的本质,社会主义本质:社会主义本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。</p>

<h2 id="主要内容">主要内容</h2>

<p>解放思想,实事求是													改革开放理论</p>

<p>社会主义初级阶段理论					 						社会主义市场经济理论</p>

<p>党的基本路线									 						“两手抓,两手都要硬”</p>

<p>社会主义根本任务的理论（发展生产力）			“一国两制”</p>

<p>“三步走”战略									 						中国问题的关键在于 党</p>

<h1 id="第七章-第二节-科学发展观的科学内涵和主要内容">第七章 第二节 科学发展观的科学内涵和主要内容</h1>

<h2 id="科学内涵">科学内涵</h2>

<p>科学发展观，第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。</p>

<p>1.推动经济社会发展是科学发展观的第一要义</p>

<p>2.以人为本是科学发展观的核心立场</p>

<p>3.全面协调可持续是科学发展观的基本要求</p>

<p>4.统筹兼顾是科学发展观的根本方法</p>

<h2 id="主要内容-1">主要内容</h2>

<p>加快转变经济发展方式。</p>

<p>发展社会主义民主政治。</p>

<p>推进社会主义文化强国建设。</p>

<p>构建社会主义和谐社会。</p>

<p>推进生态文明建设。</p>

<p>全面提高党的建设科学化水平。</p>

<h1 id="第八章-习近平新时代中国特社会主义思想及其历史地位">第八章 习近平新时代中国特⾊社会主义思想及其历史地位</h1>

<h2 id="第一节-习近平新时代中国特色社会主义思想创立的社会历史条件重点是新时代和大变局">第一节 习近平新时代中国特色社会主义思想创立的社会历史条件（重点是新时代和大变局）</h2>

<h3 id="中国特色社会主义新时代的变与不变">中国特色社会主义新时代的变与不变</h3>

<p>新的历史方位</p>

<p>我国社会的主要矛盾发生了变化</p>

<p>我国仍处于并将长期处于社会主义初级阶段的基本国情没有改变</p>

<p>我国仍是世界最大发展中国家的国际地位没有改变</p>

<p>共产党人“为中国人民谋幸福，为中华民族谋复兴”的初心和使命没有变</p>

<p>社会主要矛盾的变化：已转变为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</p>

<h3 id="世界正经历百年未有之大变局">世界正经历百年未有之大变局</h3>

<p>世界经济版图之变，科技与产业之变，国际力量对比之变，全球治理之变（中西共治），人类前途命运之变，公共卫生安全之变。</p>

<h2 id="第三节-习近平新时代中国特色社会主义思想的历史地位">第三节 习近平新时代中国特色社会主义思想的<strong>历史地位</strong></h2>

<p>当代中国马克思主义、21世纪马克思主义</p>

<p>实现现中华民族伟大复兴的行动指南</p>

<p>建设美好世界的中国智慧和中国方案</p>

<h1 id="第九章-坚持和发展中国特色社会主义的总任务">第九章 坚持和发展中国特色社会主义的总任务</h1>

<h2 id="第二节-建成社会主义现代化强国的战略安排">第二节 建成社会主义现代化强国的战略安排</h2>

<p>第一个阶段，从2020年到2035年，在全面建成小康社会的基础上，再奋斗15年，基本实现社会主义现代化。</p>

<p>第二个阶段，从2035年到本世纪中叶；在基本实现现代化的基础上，再奋斗15年，把我国建成富强民主文明和谐美丽的社会主义现代化强国。</p>

<h2 id="第三节-建设社会主义现代化国家的战略导向">第三节 建设社会主义现代化国家的战略导向</h2>

<p>《中共中央关于制定国民经济和社会发展第十四个五年规划和二〇三五年远景目标的建议》（以下简称《建议》）</p>

<p>《建议》的核心要义是新发展阶段、新发展理念、新发展格局。</p>

<h3 id="新发展阶段">新发展阶段</h3>

<p>新发展阶段的基本特征：新的历史起点、发展不平衡不充分的问题仍然突出、高质量发展将成为发展主题、构建新发展格局的发展路径、推动改革向更深层次挺进。</p>

<h3 id="新发展理念">新发展理念</h3>

<p>新发展理念是在深刻分析国内外发展形势的基础上形成的，也是针对我国发展中的突出矛盾和问题提出来的。集中反映了我们党对经济社会发展规律认识的深化。</p>

<p>(1) 创新：创新是引领发展的第一动力。</p>

<p>1.创新的顶层设计。2.创新发展的现实依据。3.创新的理论基础。4.实施创新驱动发展战略的具体措施。</p>

<p>(2) 协调：协调是持续健康发展的内在要求，解决发展不平衡问题。</p>

<p>(3) 绿色：绿色是永续发展的必要条件。绿色发展，就其要义就是要解决好人与自然和谐共生问题。</p>

<p>(4) 开放：开放是国家繁荣发展的必由之路。</p>

<p>(5) 共享：共享是中国特色社会主义的本质要求。全民共享、全面共享、共建共享、剪进共享。</p>

<h3 id="新发展格局">新发展格局</h3>

<p>构建以国内大循环为主体、国内国际双循环相互促进的新发展格局。</p>

<h1 id="第十章-五位一体总布局">第十章 “五位一体”总布局</h1>

<h2 id="第一节-实现经济高质量发展">第一节 实现经济高质量发展</h2>

<h3 id="坚持习近平经济思想">坚持习近平经济思想</h3>

<p>坚持加强党对经济工作的集中统一领导 （首位）</p>

<p>坚持以人民为中心的发展思想 （经济发展的根本目的）</p>

<h4 id="实现高质量发展的途径ppt无书上的">实现高质量发展的途径（ppt无，书上的）</h4>

<p>坚持适应把握引领经济发展新常态</p>

<p>坚持使市场在资源配置中起决定性作用，更好发挥作用</p>

<p>坚持适应我国经济发展主要矛盾变化，完善宏观调控</p>

<p>坚持问题导向部署经济发展新战略</p>

<p>坚持正确工作策略和方法</p>

<h3 id="供给侧结构性改革">供给侧结构性改革</h3>

<h4 id="内涵">内涵</h4>

<p>供给侧结构性改革就是用改革的方法推进结构调整， 从生产端入手，减少无效和低端供给，提高扩大有效和中高端供给，增强供给侧结构对需求变化的适应性和灵活性，提高全要素生产率，推动我国经济朝着更高质量和更有效率的方向发展。</p>

<p>处理好四方面的关系：处理好政府和市场的关系，处理好加法和减法的关系，处理好短期和长期的关系， 处理好供给侧改⾰和需求侧管理的关系。</p>

<h4 id="背景">背景</h4>

<p>引领经济发展新常态</p>

<p>推动经济高质量发展</p>

<p>适应国际竞争新形势</p>

<h4 id="举措">举措</h4>

<p>推进增长动能转化，加快实施创新驱动战略。</p>

<p>深化要素市场化配置改革，由以价取胜转向以质取胜。</p>

<p>加大人力资本培育力度，调动和保护人的积极性。</p>

<p>激发各类市场主体活力，加快建设世界一流企业。</p>

<p>持续推进“三去一降一补”，优化市场供给结构。（去产能、去库存、去杠杆，降成本，补短板）</p>

<h2 id="第二节-发展社会主义民主政治">第二节 发展社会主义民主政治</h2>

<h3 id="坚持中国特色社会主义政治发展道路">坚持中国特色社会主义政治发展道路</h3>

<h3 id="健全人民当家做主制度体系">健全人民当家做主制度体系</h3>

<p>四梁八柱：人民代表大会制度，中国共产党领导的多党合作和政治协商制度，民族区域自治制度，基层群众自治制度。</p>

<p>⼈⺠代表⼤会制度是我国根本政治制度。</p>

<p>中国共产党领导的多党合作和政治协商制度、中国共产党领导的多党合作和政治协商制度、基层群众⾃治制度是我国的基本政治制度。</p>

<h3 id="巩固和发展爱国统一战线非主要">巩固和发展爱国统一战线（非主要）</h3>

<p>重要任务</p>

<p>1.坚持长期共存、互相监督、肝胆相照、荣辱与共，支持民主党派按照中国特色社会主义参政党要求更好履行职能。</p>

<p>2.深化民族团结进步教育，铸牢中华民族共同体意识。</p>

<p>3.全面贯彻党的宗教工作基本方针，坚持我国宗教的中国化方向。</p>

<p>4.牢牢把握大团结大联合的主题，做好统战工作。</p>

<h2 id="第三节-建设社会主义文化强国">第三节 建设社会主义文化强国</h2>

<h3 id="坚持马克思主义在意识形态领域指导地位的根本制度">坚持马克思主义在意识形态领域指导地位的根本制度</h3>

<h3 id="社会主义核心价值观">社会主义核心价值观</h3>

<p>与历史文化相契合</p>

<p>正在进行的奋斗相结合</p>

<p>与需要解决的时代问题相适应。</p>

<h4 id="做法">做法</h4>

<ol>
  <li>
    <p>把社会主义核⼼价值观融⼊社会⽣活各个⽅⾯。</p>
  </li>
  <li>
    <p>坚持全⺠⾏动、⼲部带头，从家庭做起、从娃娃抓起。</p>
  </li>
  <li>
    <p>⽴⾜中华优秀传统⽂化和⾰命⽂化。</p>
  </li>
</ol>

<h3 id="坚定文化自信繁荣发展社会主义文化">坚定文化自信，繁荣发展社会主义文化</h3>

<p>文化是一个国家、一个⺠族的灵魂，是人⺠的精神家园。</p>

<h3 id="ppt补充做法">（ppt补充）做法</h3>

<p>针对不同受众（差异化传播）</p>

<p>推动融合发展（新媒体）</p>

<p>选择新议题</p>

<p>加强内容建设</p>

<h3 id="推进社会主义文化强国建设">推进社会主义文化强国建设</h3>

<p>培养高度的文化自信。</p>

<p>提升公共⽂化服务⽔平。</p>

<p>健全现代文化产业体系。</p>

<p>提高国家文化软实力。</p>

<h2 id="第四节-加强以民生为重点的社会建设">第四节 加强以民生为重点的社会建设</h2>

<h3 id="发展中保障和改善民生提高保障和改善民生水平">发展中保障和改善民生（提高保障和改善民生水平）</h3>

<p>建设高质量教育体系</p>

<p>实施就业优先策略</p>

<p>优化收入分配结构</p>

<p>健全多层次社会保障体系</p>

<p>全面推进健康中国建设</p>

<h3 id="加强和创新社会治理">加强和创新社会治理</h3>

<p>社会治理目标是保护安全稳定，打基础谋长远。</p>

<h3 id="社会治理面临新挑战">社会治理面临新挑战</h3>

<p>各种风险交织。</p>

<p>国内社会矛盾和问题交织叠加。</p>

<p>社会阶层结构分化，贫富差距。</p>

<p>移动互联网时代的到来。</p>

<h3 id="加强和创新社会治理的举措">加强和创新社会治理的举措</h3>

<p>创新社会治理体系。</p>

<p>完善正确处理新形势下人民内部矛盾有效机制。</p>

<p>完善社会治安防控体系。</p>

<p>加强社会心理服务体系建设。</p>

<p>加强构建基层社会治理新格局。</p>

<h2 id="第十章思考题">第十章思考题</h2>

<h3 id="1如何准确把握习近平经济思想的主要内容">1.如何准确把握习近平经济思想的主要内容?</h3>

<h3 id="2供给侧结构性改革的背景内涵及对策">2.供给侧结构性改革的背景、内涵及对策?</h3>

<h3 id="3保障人民当家作主的制度体系包括哪些内容">3.保障人民当家作主的制度体系包括哪些内容?</h3>

<h3 id="4如何提升文化软实力建设中国特色的文化强国">4.如何提升文化软实力，建设中国特色的文化强国?</h3>

<h3 id="5如何加强制度建设推进共同富裕">5.如何加强制度建设推进共同富裕?</h3>

<p>改革初次分配制度，提升中低收入群体收入水平</p>

<p>完善再分配制度，将共享发展理念落到实处</p>

<p>发挥第三次分配的调节作用</p>

<h3 id="6如何加强和创新社会治理">6.如何加强和创新社会治理?</h3>

<h1 id="第十一章-第一节-全面建设社会主义现代化国家">第十一章 第一节 全面建设社会主义现代化国家</h1>

<h2 id="从全面建成小康社会到全面建设社会主义现代化国家">从全面建成小康社会到全面建设社会主义现代化国家</h2>

<p>全面建成小康社会是战略目标，在“四个全面”中居于引领地位；全面深化改革、全面依法治国、全面从严治党是三大战略举措，为如期全面建成小康社会提供重要保障。</p>

<h2 id="脱贫攻坚经验">脱贫攻坚经验</h2>

<p>坚持党的领导， 为脱贫攻坚提供坚强政治和组织保证。</p>

<p>坚持以人民为中心的发展思想，坚定不移的走共同富裕道路。</p>

<p>坚持发挥我国社会主义制度能够集中力量办大事的政治优势，形成脱贫攻坚的共同意志、共同行动。</p>

<p>坚持精准扶贫方略，用发展的办法消除贫困根源。</p>

<p>坚持调动广大贫困群众积极性、主动新、创造性，激发脱贫内生动力。</p>

<p>坚持弘扬和衷共济、团结互助美德，营造全社会扶危济困的浓厚氛围。</p>

<p>坚持求真务实、较真碰硬，做到真扶贫、扶真贫、脱真贫。</p>

<h2 id="中国社会主义现代化国家的基本特征">中国社会主义现代化国家的基本特征</h2>

<p>1.中国的现代化是人口规模巨大的现代化。</p>

<p>2.中国的现代化是全体人民共同富裕的现代化。</p>

<p>3.中国的现代化是物质文明和精神文明相协调的现代化。</p>

<p>4.中国的现代化是人与自然和谐共生的现代化。</p>

<p>5.中国的现代化是走和平发展道路的现代化。</p>

<h1 id="第十二章-第一节-坚持总体国家安全观">第十二章 第一节 坚持总体国家安全观</h1>

<h2 id="国家安全是安邦定国的重要基石">国家安全是安邦定国的重要基石</h2>

<h2 id="国家总体安全观">国家总体安全观</h2>

<p>总体国家安全观关键在“总体”，突出的是“大安全” 理念，涵盖诸多领域，而且随着社会发展不断拓展。</p>

<h2 id="坚持总体国家安全观的意义">坚持总体国家安全观的意义</h2>

<p>适应了进⾏具有许多新的历史特点的伟大斗争的新要求。</p>

<p>回应了人民对国家安全的新期待。</p>

<p>顺应了世界发展变化的新趋势。</p>

<h2 id="坚持走中国特色社会国家安全道路">坚持走中国特色社会国家安全道路</h2>

<p>坚持统筹发展和安全的两件大事。</p>

<p>坚持人民安全、政治安全、国家利益至上有机统一。</p>

<p>坚持维护和塑造国家安全。</p>

<p>坚持科学统筹的根本方法。</p>

<p>坚持党对国家安全工作的绝对领导。</p>

<h2 id="着力防范化解重大风险">着力防范化解重大风险</h2>

<p>加强战略预判和风险预警</p>

<p>坚持立足于防，又有效处置风险。</p>

<h1 id="第十三章-第二节-坚持走和平发展道路">第十三章 第二节 坚持走和平发展道路</h1>

<h2 id="坚持独立自主和平外交政策">坚持独立自主和平外交政策</h2>

<p>中国坚定不移地奉⾏独立自主的和平外交政策，坚持互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处五项原则，走和平发展道路。</p>

<h2 id="推动建设新型国际关系">推动建设新型国际关系</h2>

<p>新型国际关系，“ 新” 在相互尊重，“ 新” 在公平正义，特别是“ 新” 在合作共赢。</p>

<p>新型国际关系，核心是维护联合国宪章宗旨和原则，维护不干涉别国内政和尊重国家主权、独立、领土完整等国际关系基本准则，维护联合国及其安理会对世界和平承担的首要责任，开展对话、合作而不是对抗，实现双赢、共赢而不是单赢。</p>

<p>推动建设新型国际关系：</p>

<p>1.要坚决维护国家核⼼利益。</p>

<p>2.要在和平共处五项原则基础上发展，同世界各国的友好合作。</p>

<p>3.要积极参与全球治理体系改革和建设。</p>

<p>4.要加强涉外法律⼯作，完善涉外法律法规体系。</p>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="Courses" /><summary type="html"><![CDATA[毛概期末总结]]></summary></entry><entry><title type="html">计算机网络期末复习</title><link href="http://localhost:4000/ppx123-web/2022/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="alternate" type="text/html" title="计算机网络期末复习" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><![CDATA[<blockquote>
  <p>主体来自于Maxwell：https://maxwell-lyu.github.io/，在其基础上简单修改</p>
</blockquote>

<h1 class="no_toc" id="list">List</h1>
<ol id="markdown-toc">
  <li><a href="#计网复习" id="markdown-toc-计网复习">计网复习</a>    <ol>
      <li><a href="#具体构成描述" id="markdown-toc-具体构成描述">具体构成描述</a></li>
      <li><a href="#服务描述" id="markdown-toc-服务描述">服务描述</a></li>
      <li><a href="#什么是协议" id="markdown-toc-什么是协议">什么是协议</a></li>
      <li><a href="#接入网" id="markdown-toc-接入网">接入网</a></li>
      <li><a href="#物理媒体" id="markdown-toc-物理媒体">物理媒体</a></li>
      <li><a href="#分组交换" id="markdown-toc-分组交换">分组交换</a></li>
      <li><a href="#电路交换" id="markdown-toc-电路交换">电路交换</a></li>
      <li><a href="#网络的网络" id="markdown-toc-网络的网络">网络的网络</a></li>
      <li><a href="#时延概述" id="markdown-toc-时延概述">时延概述</a></li>
      <li><a href="#排队时延和丢包" id="markdown-toc-排队时延和丢包">排队时延和丢包</a></li>
      <li><a href="#端到端时延" id="markdown-toc-端到端时延">端到端时延</a></li>
      <li><a href="#吞吐量" id="markdown-toc-吞吐量">吞吐量</a></li>
      <li><a href="#分层的协议结构" id="markdown-toc-分层的协议结构">分层的协议结构</a></li>
      <li><a href="#封装" id="markdown-toc-封装">封装</a></li>
      <li><a href="#无连接的多路复用与多路分解" id="markdown-toc-无连接的多路复用与多路分解">无连接的多路复用与多路分解</a></li>
      <li><a href="#面向连接的多路复用与多路分解" id="markdown-toc-面向连接的多路复用与多路分解">面向连接的多路复用与多路分解</a></li>
      <li><a href="#报文段结构" id="markdown-toc-报文段结构">报文段结构</a></li>
      <li><a href="#udp检验和" id="markdown-toc-udp检验和">UDP检验和</a></li>
      <li><a href="#tcp连接" id="markdown-toc-tcp连接">TCP连接</a></li>
      <li><a href="#tcp报文段结构" id="markdown-toc-tcp报文段结构">TCP报文段结构</a></li>
      <li><a href="#往返时间的估计与超时" id="markdown-toc-往返时间的估计与超时">往返时间的估计与超时</a></li>
      <li><a href="#可靠数据传输" id="markdown-toc-可靠数据传输">可靠数据传输</a></li>
      <li><a href="#流量控制" id="markdown-toc-流量控制">流量控制</a></li>
      <li><a href="#tcp连接管理" id="markdown-toc-tcp连接管理">TCP连接管理</a></li>
      <li><a href="#公平性" id="markdown-toc-公平性">公平性</a></li>
      <li><a href="#网络辅助拥塞控制" id="markdown-toc-网络辅助拥塞控制">网络辅助拥塞控制</a></li>
      <li><a href="#输入端口处理和基于目的地转发" id="markdown-toc-输入端口处理和基于目的地转发">输入端口处理和基于目的地转发</a></li>
      <li><a href="#交换" id="markdown-toc-交换">交换</a></li>
      <li><a href="#输出端口处理" id="markdown-toc-输出端口处理">输出端口处理</a></li>
      <li><a href="#何处出现排队" id="markdown-toc-何处出现排队">何处出现排队</a></li>
      <li><a href="#分组调度" id="markdown-toc-分组调度">分组调度</a></li>
      <li><a href="#ipv4数据报格式" id="markdown-toc-ipv4数据报格式">IPv4数据报格式</a></li>
      <li><a href="#ipv4数据报分片" id="markdown-toc-ipv4数据报分片">IPv4数据报分片</a></li>
      <li><a href="#ipv4编址" id="markdown-toc-ipv4编址">IPv4编址</a></li>
      <li><a href="#网络地址转换nat" id="markdown-toc-网络地址转换nat">网络地址转换NAT</a></li>
      <li><a href="#ipv6" id="markdown-toc-ipv6">IPv6</a></li>
      <li><a href="#链路状态路由选择算法" id="markdown-toc-链路状态路由选择算法">链路状态路由选择算法</a></li>
      <li><a href="#距离向量路由选择算法" id="markdown-toc-距离向量路由选择算法">距离向量路由选择算法</a></li>
      <li><a href="#开放最短路优先ospf" id="markdown-toc-开放最短路优先ospf">开放最短路优先OSPF</a></li>
      <li><a href="#bgp的作用" id="markdown-toc-bgp的作用">BGP的作用</a></li>
      <li><a href="#通告bgp路由信息" id="markdown-toc-通告bgp路由信息">通告BGP路由信息</a></li>
      <li><a href="#确定最好的路由" id="markdown-toc-确定最好的路由">确定最好的路由</a></li>
      <li><a href="#ip任播" id="markdown-toc-ip任播">IP任播</a></li>
      <li><a href="#路由选择策略" id="markdown-toc-路由选择策略">路由选择策略</a></li>
      <li><a href="#拼装在一起-在因特网中呈现" id="markdown-toc-拼装在一起-在因特网中呈现">拼装在一起: 在因特网中呈现</a></li>
      <li><a href="#信道划分协议" id="markdown-toc-信道划分协议">信道划分协议</a></li>
      <li><a href="#随机接入协议" id="markdown-toc-随机接入协议">随机接入协议</a></li>
      <li><a href="#轮流协议" id="markdown-toc-轮流协议">轮流协议</a></li>
      <li><a href="#链路层寻址和arp" id="markdown-toc-链路层寻址和arp">链路层寻址和ARP</a></li>
      <li><a href="#以太网" id="markdown-toc-以太网">以太网</a></li>
      <li><a href="#链路层交换机" id="markdown-toc-链路层交换机">链路层交换机</a></li>
      <li><a href="#网桥" id="markdown-toc-网桥">网桥</a></li>
      <li><a href="#虚拟局域网" id="markdown-toc-虚拟局域网">虚拟局域网</a></li>
      <li><a href="#流式存储视频" id="markdown-toc-流式存储视频">流式存储视频</a></li>
    </ol>
  </li>
</ol>

<h1 id="计网复习">计网复习</h1>

<ul>
  <li>
    <p>[重点] 1.x</p>
  </li>
  <li>
    <p>[概念] 3.2 3.3</p>
  </li>
  <li>
    <p>[重点] 3.5 3.6 3.7</p>
  </li>
  <li>
    <p>[重点] 4.2 4.3</p>
  </li>
  <li>
    <p>[重点] 5.2 5.3</p>
  </li>
  <li>
    <p>[概念]</p>
  </li>
  <li>
    <p>[重点] CSMA/CD</p>
  </li>
  <li>
    <p>[概念]</p>
  </li>
  <li>
    <p>[概念] 9.x QoS相关内容</p>
  </li>
</ul>

<p>距离向量算法，可能出现的问题</p>

<p>LS算法</p>

<p>TCP reno协议 三次握手，四次挥手</p>

<p>默写ALOHA</p>

<p>流媒体</p>

<p>CSMA/CA  CSMA/CD</p>

<p>了解：SDN，ICMP，网桥</p>

<p>第一章</p>

<p>=================</p>

<p>什么是因特网</p>

<hr />

<h3 id="具体构成描述">具体构成描述</h3>

<ul>
  <li>
    <p>主机 / 端系统: 与因特网相连的设备</p>
  </li>
  <li>
    <p>通信链路: 同轴电缆, 铜缆, 光纤, 无线电频谱</p>
  </li>
  <li>
    <p>分组交换机</p>
  </li>
  <li>
    <p>路由器: 通常在网络核心</p>
  </li>
  <li>
    <p>链路层交换机: 通常在接入网</p>
  </li>
  <li>
    <p>传输速率: 比特/秒 bps</p>
  </li>
  <li>
    <p>分组: 数据分段并加上首部字节(发送系统)</p>
  </li>
  <li>
    <p>路径: 分组经历的通信链路和分组交换机</p>
  </li>
  <li>
    <p>因特网服务提供商(ISP): 因特网接入服务</p>
  </li>
  <li>
    <p>协议: 控制因特网中信息的接收和发送</p>
  </li>
  <li>
    <p>TCP: 传输控制协议</p>
  </li>
  <li>
    <p>IP: 网际协议</p>
  </li>
  <li>
    <p>因特网标准: 由IETF研发</p>
  </li>
  <li>
    <p>RFC: 请求评论, 因特网标准文档</p>
  </li>
</ul>

<h3 id="服务描述">服务描述</h3>

<ul>
  <li>
    <p>分布式应用程序: 涉及到多个相互交换数据的端系统</p>
  </li>
  <li>
    <p>套接字接口: 规定了端系统上的程序, 请求因特网基础设施, 向另一个端系统上程序, 交付数据的方式</p>
  </li>
</ul>

<h3 id="什么是协议">什么是协议</h3>

<ul>
  <li>
    <p>协议定义了:</p>
  </li>
  <li>
    <p>在两个或多个通信实体之间, 交换报文的格式和顺序</p>
  </li>
  <li>
    <p>报文发送和/或接收报文, 或其他事件, 所采取的动作</p>
  </li>
</ul>

<p>网络边缘</p>

<hr />

<ul>
  <li>
    <p>端系统: 运行应用程序</p>
  </li>
  <li>
    <p>P2S模型</p>
  </li>
  <li>
    <p>客户端: 发送请求, 接受服务</p>
  </li>
  <li>
    <p>服务器: 响应请求, 提供服务, 始终在线, 性能更强</p>
  </li>
  <li>
    <p>P2P模型</p>
  </li>
  <li>
    <p>无专用服务器, 每设备既是客户端也是服务器</p>
  </li>
</ul>

<h3 id="接入网">接入网</h3>

<ul>
  <li>
    <p>接入网: 端系统物理连接到边缘路由器的网络</p>
  </li>
  <li>
    <p>边缘路由器: 端系统接入到远程端系统的第一台路由器</p>
  </li>
  <li>
    <p>接入链路与接入环境</p>
  </li>
  <li>
    <p>家庭接入</p>
  </li>
  <li>
    <p>拨号</p>
  </li>
  <li>
    <p>介质: 电话线, 有调制解调器, 执行的操作相当于给接入号(服务台)打个电话, 独占一个线路</p>
  </li>
  <li>
    <p>速率: 56kbps</p>
  </li>
  <li>
    <p>卫星: 1Mbps</p>
  </li>
  <li>
    <p>DSL: 数字用户线</p>
  </li>
  <li>
    <p>介质: 电话线</p>
  </li>
  <li>
    <p>拓扑</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![image-20211222112530253](C:\Users\zhaochaoyi\AppData\Roaming\Typora\typora-user-images\image-20211222112530253.png)
</code></pre></div></div>

<ul>
  <li>
    <p>DSLAM: 数字用户线接入复用器, 位于中心局, 许多端系统共享</p>
  </li>
  <li>
    <p>频段分布</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  高速下行: 50kHz - 1MHz 12Mbps 55Mbps

*  中速上行: 4kHz - 50kHz 1.8Mbps 15Mbps

*  双向话音: 0 - 4kHz
</code></pre></div></div>

<ul>
  <li>
    <p>HFC: 混合光纤同轴/电缆因特网接入</p>
  </li>
  <li>
    <p>介质: 同轴电缆 + 光纤</p>
  </li>
  <li>
    <p>拓扑</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![image-20211222112541475](C:\Users\zhaochaoyi\AppData\Roaming\Typora\typora-user-images\image-20211222112541475.png)
</code></pre></div></div>

<ul>
  <li>
    <p>CMTS: 电缆调制解调器端接系统, 位于电缆头端</p>
  </li>
  <li>
    <p>速率: 42.8Mbps下行, 30.7Mbps上行</p>
  </li>
  <li>
    <p>有碰撞</p>
  </li>
  <li>
    <p>FTTH: 光纤到户(PON: 被动光纤网络)</p>
  </li>
  <li>
    <p>介质: 光纤</p>
  </li>
  <li>
    <p>拓扑</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>![image-20211222112605837](C:\Users\zhaochaoyi\AppData\Roaming\Typora\typora-user-images\image-20211222112605837.png)
</code></pre></div></div>

<ul>
  <li>
    <p>ONT: 光纤网络端接器; OLT: 光纤线路端接器</p>
  </li>
  <li>
    <p>企业(家庭)接入</p>
  </li>
  <li>
    <p>LAN</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  介质: 双绞线

*  拓扑: 设备接入以太网交换机, 通过路由器接入因特网

*  速率: 10Mbps 100Mbps, 1Gbps, 10Gbps
</code></pre></div></div>

<ul>
  <li>WiFi(802.11b/g/ac)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  11Mbps, 54Mbps, 100Mbps+
</code></pre></div></div>

<ul>
  <li>
    <p>广域无线接入: 通信运营商</p>
  </li>
  <li>
    <p>3G: 1Mbps</p>
  </li>
  <li>
    <p>4G LTE / WiMAX(淘汰): 10Mbps+</p>
  </li>
  <li>
    <p>5G: 20Gbps?</p>
  </li>
</ul>

<h3 id="物理媒体">物理媒体</h3>

<ul>
  <li>
    <p>导向型</p>
  </li>
  <li>
    <p>双绞铜线</p>
  </li>
  <li>
    <p>同轴电缆(可用作共享媒体)</p>
  </li>
  <li>
    <p>光纤</p>
  </li>
  <li>
    <p>非导向型</p>
  </li>
  <li>
    <p>陆地无线电</p>
  </li>
  <li>
    <p>卫星无线电</p>
  </li>
</ul>

<p>网络核心</p>

<hr />

<h3 id="分组交换">分组交换</h3>

<ul>
  <li>
    <p>数据切分成分组, 加首部</p>
  </li>
  <li>
    <p>每个分组发送时独占带宽</p>
  </li>
  <li>
    <p>交换机: 链路层交换机, 路由器</p>
  </li>
  <li>
    <p>存储转发传输</p>
  </li>
  <li>
    <p>交换机先接收并存储整个分组, 之后再发出</p>
  </li>
  <li>
    <p>端到端时延(N个交换机, 分组长度L, 速率R): $d_{e2e}=N\frac{L}{R}$</p>
  </li>
  <li>
    <p>排队时延和分组丢失</p>
  </li>
  <li>
    <p>输出缓存/输出队列: 位于输出链路前</p>
  </li>
  <li>
    <p>拥塞: 分组排队等待链路</p>
  </li>
  <li>
    <p>排队时延: 入队到出队的时延</p>
  </li>
  <li>
    <p>分组丢失: 队列近满, 概率丢失; 队列满, 直接丢失</p>
  </li>
  <li>
    <p>转发表和路由选择协议</p>
  </li>
  <li>
    <p>转发表: 目的地址映射到输出链路</p>
  </li>
  <li>
    <p>路由选择协议: 自动设置转发表</p>
  </li>
</ul>

<h3 id="电路交换">电路交换</h3>

<ul>
  <li>
    <p>预留资源, 需要建立连接/断开连接</p>
  </li>
  <li>
    <p>端到端连接: 专用电路, 恒定时延/速率, 稳定的性能</p>
  </li>
  <li>
    <p>电路交换中的复用</p>
  </li>
  <li>
    <p>频分复用</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  分频段, 每个电路独占一个频率范围
</code></pre></div></div>

<ul>
  <li>时分复用</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  划分时隙, 每个电路轮流得到时隙

*  统计时分复用: 划分时隙, 高数据率的源得到更多时隙
</code></pre></div></div>

<ul>
  <li>对比</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  电路: 时延固定

*  分组: 时延不可预测, 共享带宽更高, 更简单有效成本低

*  电路预先分配, 分组按需分配
</code></pre></div></div>

<ul>
  <li>虚电路</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  电路交换 + 分组交换

*  虚电路建立时, 固定路由, 无需路由选择

*  共享资源, 需要拥塞控制

*  保证分组按序到达

*  可预留资源, 可区别服务(有快有慢, 优先级等)

*  需要连接建立和拆除
</code></pre></div></div>

<h3 id="网络的网络">网络的网络</h3>

<ul>
  <li>
    <p>粗略的层次结构</p>
  </li>
  <li>
    <p>Tier-1 ISP与内容提供商</p>
  </li>
  <li>
    <p>区域ISP(与多个Tier-1相连)</p>
  </li>
  <li>
    <p>接入ISP: 接入网, 连接端系统和Tier-2 ISP</p>
  </li>
  <li>
    <p>IXP: 连接ISP, 可以来自不同级</p>
  </li>
</ul>

<p>分组交换网中的时延丢包和吞吐量</p>

<hr />

<h3 id="时延概述">时延概述</h3>

<ul>
  <li>
    <p>处理时延: 节点检查首部, 决定转发, 进行校验的时间, 微秒-$d_{proc}$</p>
  </li>
  <li>
    <p>排队时延: 在链路前的队列等待传输, 微秒~毫秒,$d_{queue}$</p>
  </li>
  <li>
    <p>传输时延: $L/R$, 将所有比特推向链路的时间, 微秒~毫秒，$d_{tran}$.</p>
  </li>
  <li>
    <p>传播时延: $d/s$, 速度s略小于光速, 毫秒,$d_{prop}$.</p>
  </li>
</ul>

<h3 id="排队时延和丢包">排队时延和丢包</h3>

<ul>
  <li>
    <p>排队时延对不同的分组不相通, 以统计量衡量</p>
  </li>
  <li>
    <p>流量强度: $La/R$, $a$为分组到达的速率, 流量强度不能大于1。($a$是分组到达的速率，$L$是分组的长度,比特到达队列的平均速率是$La$ $bps$)</p>
  </li>
  <li>
    <p>流量强度增加, 平均排队时延迅速增加($x^2$)</p>
  </li>
  <li>
    <p>丢包</p>
  </li>
  <li>
    <p>(上课提到)队列近满, 部分设备采取按照概率丢弃分组, 队列越长概率越大</p>
  </li>
  <li>
    <p>队列满, 再来就丢, 用丢包率衡量</p>
  </li>
</ul>

<h3 id="端到端时延">端到端时延</h3>

<ul>
  <li>
    <p>$N-1$个路由器, 则端到端时延$d_{e2e}=N(d_{proc}+d_{trans}+d_{prop})$</p>
  </li>
  <li>
    <p>traceroute: ttl递增的一系列分组, 分别测试到第i跳的时延</p>
  </li>
  <li>
    <p>端系统, 应用程序和其他时延</p>
  </li>
  <li>
    <p>向共享媒体传输的端系统, 有意延迟传输</p>
  </li>
  <li>
    <p>媒体分组化(AD-DA转换, 填充分组)延迟</p>
  </li>
</ul>

<h3 id="吞吐量">吞吐量</h3>

<ul>
  <li>
    <p>瞬时吞吐量: 主机B接收的速率</p>
  </li>
  <li>
    <p>平均吞吐量: $F/T$, 文件大小除以传输时间</p>
  </li>
  <li>
    <p>瓶颈链路: 吞吐量是各个子链路吞吐量的最小值</p>
  </li>
  <li>
    <p>因特网中, 吞吐量瓶颈在接入网</p>
  </li>
  <li>
    <p>共享链路: 多个链路共享某一段链路, 则需要共享这个链路的吞吐量</p>
  </li>
</ul>

<p>协议层级及其服务模型</p>

<hr />

<h3 id="分层的协议结构">分层的协议结构</h3>

<ul>
  <li>
    <p>协议分层</p>
  </li>
  <li>
    <p>每层向上提供服务， 各层所有协议称为协议栈</p>
  </li>
  <li>
    <p>PDU: protocol data units, 也就是分组(控制信息 + 数据)</p>
  </li>
  <li>
    <p>因特网(TCP/IP)协议栈</p>
  </li>
  <li>
    <p>应用层：网络应用程序及它们的应用层协议停留的地方</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  支持网络应用程序: FTP(端系统文件传输), SMTP(电子邮件报文传输), HTTP(Web文档请求和传送)

*  信息分组: 报文
</code></pre></div></div>

<ul>
  <li>运输层：在应用程序端点之间传递报文</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  进程间数据传输: TCP, UDP

*  信息分组: 报文段
</code></pre></div></div>

<ul>
  <li>网络层：负责将称为数据报的网络层分组从一台主机移动到另一台主机</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  路由数据报: IP

*  信息分组: 数据报
</code></pre></div></div>

<ul>
  <li>链路层：沿着路径将数据报传递给下一个节点</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  在邻接的主机或路由器间传输: Ethernet, PPP

*  信息分组: 帧
</code></pre></div></div>

<ul>
  <li>物理层：将该帧中的一个个比特从一个节点移动到下一个节点</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  线路上的比特
</code></pre></div></div>

<ul>
  <li>
    <p>OSI模型</p>
  </li>
  <li>
    <p>应用层: 应用访问OSI模型的环境</p>
  </li>
  <li>
    <p>表示层, 会话层: 并入应用层</p>
  </li>
  <li>
    <p>表示层：表示层的作用是使通信的应用程序能够解释交换数据的含义</p>
  </li>
  <li>
    <p>会话层：会话层提供了数据交换的定界和同步功能，包括了建立检 查点和恢复方案的方法</p>
  </li>
  <li>
    <p>运输层</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  端系统间通信

*  可靠传输 或 单块传输

*  连接建立, 维持, 释放
</code></pre></div></div>

<ul>
  <li>网络层</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  分组在多个网络或链路上传输

*  编址, 路由, 转发, 拥塞控制

*  连接建立, 维持, 拆除
</code></pre></div></div>

<ul>
  <li>数据链路层</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  链路层帧

*  媒体访问控制, 差错检测和重传, 流量控制

*  连接激活, 维持和失活
</code></pre></div></div>

<ul>
  <li>物理层</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  链路上的比特流
</code></pre></div></div>

<h3 id="封装">封装</h3>

<ul>
  <li>
    <p>封装: 分组 = 首部字段 + 有效载荷字段</p>
  </li>
  <li>
    <p>应用层报文</p>
  </li>
  <li>
    <p>运输层报文段: 运输层首部(应用交付信息, 差错检测信息) + (分段的)应用层报文</p>
  </li>
  <li>
    <p>网络层数据报: 网络层首部(源目的地址等) + 运输层报文段</p>
  </li>
  <li>
    <p>链路层帧: 链路层首部 + 网络层数据报</p>
  </li>
</ul>

<p>面对攻击的网络</p>

<hr />

<ul>
  <li>
    <p>攻击个人电脑</p>
  </li>
  <li>
    <p>恶意软件</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  大多数都是自我复制的

*  病毒: 需要某种形式的用户交互来感染用户设备

*  蠕虫: 无需任何明显用户交互就能进入设备

*  木马: 伪装成无害程序, 吸引用户点击

*  后门: 绕过授权验证

*  广告软件: 访问弹出广告

*  间谍软件: 收集用户的输入, 记录用户活动
</code></pre></div></div>

<ul>
  <li>
    <p>攻击服务器和网络基础设施</p>
  </li>
  <li>
    <p>拒绝服务攻击DoS</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  使得服务不能由合法用户使用

*  弱点攻击: 针对易受攻击的程序或操作系统, 引发停止运行或崩溃

*  带宽洪泛: 大量发送分组到目标, 使链路拥塞

*  连接洪泛: 创建大量半开或全开的TCP连接, 耗尽资源
</code></pre></div></div>

<ul>
  <li>分布式DoS(DDoS)</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  攻击者控制多个源

*  僵尸网路: 攻击者用恶意软件控制大量计算机, 作为DDoS的源头等
</code></pre></div></div>

<ul>
  <li>
    <p>嗅探分组</p>
  </li>
  <li>
    <p>分组嗅探器: 记录每个流经的分组副本的被动接收机</p>
  </li>
  <li>
    <p>防范: 加密</p>
  </li>
  <li>
    <p>伪装</p>
  </li>
  <li>
    <p>IP欺骗: 将具有虚假源地址的分组注入因特网</p>
  </li>
  <li>
    <p>重放攻击</p>
  </li>
  <li>
    <p>中间人攻击</p>
  </li>
  <li>
    <p>连接劫持</p>
  </li>
  <li>
    <p>解决方案: 加密, 数字签名, MAC</p>
  </li>
</ul>

<p>第三章</p>

<p>=================</p>

<p>多路复用与多路分解</p>

<hr />

<ul>
  <li>
    <p>多路分解: 将运输层报文段中的数据, 交付到正确的套接字的工作</p>
  </li>
  <li>
    <p>多路复用: 从套接字中收集数据, 加首部生成报文段, 将报文段传递到网络层</p>
  </li>
  <li>
    <p>套接字</p>
  </li>
  <li>
    <p>具有唯一标识符</p>
  </li>
  <li>
    <p>报文段具有特殊字段(源端口号16bit, 目的端口号16bit), 指示需要交付到的套接字</p>
  </li>
  <li>
    <p>周知端口号: 0~1023</p>
  </li>
</ul>

<h3 id="无连接的多路复用与多路分解">无连接的多路复用与多路分解</h3>

<ul>
  <li>
    <p>UDP套接字由二元组进行标识: 目的IP : 目的端口号</p>
  </li>
  <li>
    <p>源端口号: 回复时使用</p>
  </li>
</ul>

<h3 id="面向连接的多路复用与多路分解">面向连接的多路复用与多路分解</h3>

<ul>
  <li>
    <p>TCP套接字由四元组进行标识: 源IP : 源端口号 : 目的IP : 目的端口号</p>
  </li>
  <li>
    <p>不同来源的报文到达同一端口可区分, HTTP服务器</p>
  </li>
</ul>

<p>无连接运输UDP</p>

<hr />

<ul>
  <li>
    <p>仅提供复用分解, 差错检测</p>
  </li>
  <li>
    <p>无连接: 发送报文段之前, 没有握手</p>
  </li>
  <li>
    <p>优点: 首部短, 时间灵活, 无连接建立, 无连接状态</p>
  </li>
  <li>
    <p>无拥塞控制, 可以由应用层构建可靠传输</p>
  </li>
</ul>

<h3 id="报文段结构">报文段结构</h3>

<table>
  <tbody>
    <tr>
      <td>源端口号</td>
      <td>目的端口号</td>
      <td>长度（首部+数据）</td>
      <td>检验和</td>
      <td>应用数据（报文）</td>
    </tr>
  </tbody>
</table>

<p>| ——– | ———- | —————– | —— | —————- |</p>

<table>
  <tbody>
    <tr>
      <td>16 bit</td>
      <td>16 bit</td>
      <td>16 bit</td>
      <td>16 bit</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>UDP变长数据段</p>
  </li>
  <li>
    <p>检验和计算: UDP报文段 + IP首部的部分字段()</p>
  </li>
</ul>

<h3 id="udp检验和">UDP检验和</h3>

<ul>
  <li>
    <p>计算方法</p>
  </li>
  <li>
    <p>报文段分为16bit字, 相加求和</p>
  </li>
  <li>
    <p>最高位进位回卷, 加到最低位</p>
  </li>
  <li>
    <p>取反码</p>
  </li>
  <li>
    <p>检验方法: 接收方做前两步, 得到全1, 则没问题</p>
  </li>
  <li>
    <p>能检测, 不能纠错, 端到端差错控制</p>
  </li>
</ul>

<p>面向连接的运输TCP</p>

<hr />

<ul>
  <li>
    <p>提供差错检测, 重传, 累积确认, 定时器, 序号和确认号的首部字段</p>
  </li>
  <li>
    <p>全双工</p>
  </li>
</ul>

<h3 id="tcp连接">TCP连接</h3>

<ul>
  <li>
    <p>三次握手</p>
  </li>
  <li>
    <p>客户发送</p>
  </li>
  <li>
    <p>服务端发送</p>
  </li>
  <li>
    <p>客户发送</p>
  </li>
  <li>
    <p>MSS最大报文段长度(其实是应用层数据的最大长度): 根据 MTU(链路层)最大传输单元确定, 典型值1460字节（1500-40TCP/IP首部）</p>
  </li>
</ul>

<h3 id="tcp报文段结构">TCP报文段结构</h3>

<table>
  <tbody>
    <tr>
      <td>源端口号</td>
      <td>目的端口号</td>
      <td>序号</td>
      <td>确认号</td>
      <td>（第一堆）</td>
      <td>接收窗口</td>
      <td>因特网校验和 -紧急数据指针</td>
      <td>选项</td>
      <td>数据</td>
    </tr>
  </tbody>
</table>

<p>| ——– | ———- | —– | —— | ———- | ——– | ————————– | —– | —- |</p>

<table>
  <tbody>
    <tr>
      <td>16bit</td>
      <td>16bit</td>
      <td>32bit</td>
      <td>16bit</td>
      <td>16bit</td>
      <td>16bit</td>
      <td>16bit + 16bit</td>
      <td>0bit+</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>第一堆里面有: 首部长度4bit(以字为单位, 1=4字节) + 保留未用6bit + (URG ACK PSH RST SYN FIN)标志字段6bit</p>
  </li>
  <li>
    <p>SYN FIN RST 用于连接建立和拆除, PSH代表必须立即将数据交给上层, URG与紧急数据指表示指向位置是紧急数据的最后一个字节, 需要通知上层</p>
  </li>
  <li>
    <p>序号和确认号</p>
  </li>
  <li>
    <p>序号: 是该报文段的首字节的字节流编号</p>
  </li>
</ul>

<blockquote>
  <p>单纯的ACK不包含数据字节, 因此不引发编号增加</p>
</blockquote>

<ul>
  <li>确认号: 表示这一序号之前的字节均被正确接收, 它和其后的未接收</li>
</ul>

<blockquote>
  <p>一个报文可以同时有确认号和序号, 是捎带ACK</p>
</blockquote>

<h3 id="往返时间的估计与超时">往返时间的估计与超时</h3>

<ul>
  <li>
    <p>估计往返时间</p>
  </li>
  <li>
    <p>SampleRTT: 某一报文被发出(交给IP)到其确认被接收的时间量(一个来回)</p>
  </li>
</ul>

<blockquote>
  <p>重传的报文不进行测量</p>
</blockquote>

<ul>
  <li>EstimatedRTT: 初始为第一个测得的SampleRTT, 之后根据下式更新</li>
</ul>

\[\textrm{EstimatedRTT} = (1-\alpha)\cdot\textrm{EstimatedRTT} + \alpha \cdot \textrm{SampleRTT}\]

<blockquote>
  <p>指数移动加权平均</p>
</blockquote>

<ul>
  <li>DevRTT: RTT的偏差, 是Sample和Estimated的差的绝对值, 也用指数移动加权平均</li>
</ul>

\[\textrm{DevRTT} = (1-\beta)\cdot\textrm{DevRTT} + \beta \cdot |\textrm{SampleRTT}-\textrm{EstimatedRTT}|\]

<ul>
  <li>
    <p>设置和管理重传超时间隔</p>
  </li>
  <li>
    <p>重传间隔</p>
  </li>
  <li>
    <p>默认初始值为1s</p>
  </li>
  <li>
    <p>超时后, 设为先前值的2倍</p>
  </li>
  <li>
    <p>若有新的EstimatedRTT, 立刻据下式更新</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $$\textrm{TimeInterval} = \textrm{EstimatedRTT} + 4\cdot \textrm{DevRTT}$$
</code></pre></div></div>

<h3 id="可靠数据传输">可靠数据传输</h3>

<ul>
  <li>
    <p>累积ACK</p>
  </li>
  <li>
    <p>ACK中的数字, 表示其之前的字节均被接收</p>
  </li>
  <li>
    <p>重传</p>
  </li>
  <li>
    <p>规则: 一个报文到达重传间隔, 仍未收到ACK(ACK&gt;SEQ+LEN), 则重传</p>
  </li>
  <li>
    <p>超时间隔加倍: 重传过后, 下一次的定时将会加倍;</p>
  </li>
  <li>
    <p>推算超时间隔: 若收到ACK或得到上层应用数据, 则又改为使用$\textrm{TimeInterval}$计算</p>
  </li>
  <li>
    <p>快速重传</p>
  </li>
  <li>
    <p>ACK生成策略</p>
  </li>
  <li>
    <p>具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认：延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下 一个按序报文段在这个时间间隔内没有到达，则发送一个ACK</p>
  </li>
  <li>
    <p>具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输：立即发送单个累积ACK,以确认两个按序报文段</p>
  </li>
  <li>
    <p>比期望序号大的失序报文段到达。检测出间隔：立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端 的序号）</p>
  </li>
  <li>
    <p>能部分或完全填充接收数据间隔的报文 段到达：倘若该报文段起始于间隔的低端，则立即发送ACK</p>
  </li>
  <li>
    <p>收到3个冗余ACK, 则进行快速重传, 假定被ACK的报文后的报文全部丢失</p>
  </li>
  <li>
    <p>回退N步还是选择重传</p>
  </li>
  <li>
    <p>第n个报文重传, 若之后的报文被缓存, 且其ACK及时到达, 那么后续可以不用重传</p>
  </li>
</ul>

<blockquote>
  <p>这意味着TCP不是单纯的GBN, 而含有一部分SN</p>
</blockquote>

<h3 id="流量控制">流量控制</h3>

<ul>
  <li>
    <p>接收窗口</p>
  </li>
  <li>
    <p>接收方跟踪</p>
  </li>
  <li>
    <p>应用读取的最后一个字节的编号: LastByteRead</p>
  </li>
  <li>
    <p>接收到的最后一个字节的编号: LastByteRcvd</p>
  </li>
  <li>
    <p>接收缓存大小: RcvBuffer</p>
  </li>
  <li>
    <p>接收窗口大小: rwnd = RcvBuffer-(LastByteRcvd-LastByteRead)</p>
  </li>
</ul>

<blockquote>
  <p>也就是缓存余量</p>
</blockquote>

<ul>
  <li>
    <p>接收方将rwnd放入发给发送方的报文中</p>
  </li>
  <li>
    <p>发送方跟踪</p>
  </li>
  <li>
    <p>发送的最后一个字节的编号: LastByteSent</p>
  </li>
  <li>
    <p>被确认的最后一个字节的编号: LastByteAcked</p>
  </li>
  <li>
    <p>从接收到的报文中得到的rwnd</p>
  </li>
  <li>
    <p>需要始终保证 LastByteSent - LastByteAcked &lt;= rwnd</p>
  </li>
  <li>
    <p>若出现rwnd=0, 则需要继续发送含有一字节数据的报文</p>
  </li>
</ul>

<blockquote>
  <p>为了防止接收方无数据要发, 引发发送端阻塞. 这个一字节的报文总会被ACK, 有机会获得一个非0的rwnd值</p>
</blockquote>

<h3 id="tcp连接管理">TCP连接管理</h3>

<ul>
  <li>建立: 三次握手</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>通信</td>
      <td>SYN</td>
      <td>是否有ACK</td>
      <td>ACK</td>
      <td>SEQ</td>
      <td>数据</td>
      <td>操作</td>
    </tr>
  </tbody>
</table>

<p>| ———- | —- | ——— | ———— | ———— | —— | ——————————– |</p>

<table>
  <tbody>
    <tr>
      <td>客户-&gt;服务</td>
      <td>+</td>
      <td> </td>
      <td> </td>
      <td>client_isn</td>
      <td> </td>
      <td>客户端随机选择起始序号</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>服务-&gt;客户</td>
      <td>+</td>
      <td>+</td>
      <td>client_isn+1</td>
      <td>server_isn</td>
      <td> </td>
      <td>服务器分配资源, 随机选择起始序号</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>客户-&gt;服务</td>
      <td> </td>
      <td>+</td>
      <td>server_isn+1</td>
      <td>client_isn+1</td>
      <td>可携带</td>
      <td>客户端分配资源</td>
    </tr>
  </tbody>
</table>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20220102152227074.png" alt="image-20220102152227074" /></p>

<ul>
  <li>终止(以客户终止为例)</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>通信</td>
      <td>FIN</td>
      <td>SEQ</td>
      <td>是否有ACK</td>
      <td>ACK</td>
      <td>操作</td>
    </tr>
  </tbody>
</table>

<p>| ———- | —- | ————– | ——— | —————- | ———————————————- |</p>

<table>
  <tbody>
    <tr>
      <td>客户-&gt;服务</td>
      <td>+</td>
      <td>client_isn</td>
      <td> </td>
      <td>server_isn</td>
      <td>客户发送FIN</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>服务-&gt;客户</td>
      <td> </td>
      <td>server_isn</td>
      <td>+</td>
      <td>client_isn+1</td>
      <td>服务器ACK这个FIN, 之后还可以发数据(len)</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>服务-&gt;客户</td>
      <td>+</td>
      <td>server_isn+len</td>
      <td> </td>
      <td>client_isn+1</td>
      <td>服务器发送FIN, 收到客户端的ACK后关闭, 释放资源</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>客户-&gt;服务</td>
      <td> </td>
      <td>client_isn+1</td>
      <td>+</td>
      <td>server_isn+len+1</td>
      <td>客户端ACK这个FIN, 定时等待之后关闭, 释放资源</td>
    </tr>
  </tbody>
</table>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20220102152429848.png" alt="image-20220102152429848" /></p>

<ul>
  <li>
    <p>防范SYN洪泛攻击</p>
  </li>
  <li>
    <p>第二步的server_isn使用散列函数, 用源地址, 目的地址和端口号, 和一个只有服务器知道的散列函数</p>
  </li>
  <li>
    <p>第二步不分配资源</p>
  </li>
  <li>
    <p>第三步根据ACK里面的seq, 可以验证这个ACK是由先前的某个SYN生成的, 于是分配资源建立连接</p>
  </li>
  <li>
    <p>拒绝通信</p>
  </li>
  <li>
    <p>发送RST(RST标志位1)</p>
  </li>
</ul>

<p>拥塞控制原理</p>

<hr />

<ul>
  <li>一堆废话, 我只关心TCP</li>
</ul>

<p>TCP拥塞控制</p>

<hr />

<ul>
  <li>
    <p>拥塞窗口cwnd</p>
  </li>
  <li>
    <p>对发送进行限制: LastByteSent - LastByteAcked &lt;= min(rwnd, cwnd)</p>
  </li>
  <li>
    <p>窗口与速率的关系: B = S(发出的包数量)/RTT(往返时间)</p>
  </li>
  <li>
    <p>TCP拥塞控制算法</p>
  </li>
  <li>
    <p>总结</p>
  </li>
  <li>
    <p>ssthresh(慢启动阈值)变化: 丢包事件: ssthresh = cwnd / 2</p>
  </li>
  <li>
    <p>cwnd变化: 状态初始值</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  进入慢启动: cwnd = 1

*  进入拥塞避免: cwnd = ssthresh

*  进入快速恢复: cwnd = ssthresh + 3
</code></pre></div></div>

<ul>
  <li>cwnd变化: 增长方式</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  慢启动: 每个ACK, +1, 相当于每轮乘二

*  拥塞避免: 每轮 +1

*  快速恢复: 每个冗余ACK +1
</code></pre></div></div>

<ul>
  <li>
    <p>慢启动</p>
  </li>
  <li>
    <p>初始: cwnd = 1 (MSS)</p>
  </li>
  <li>
    <p>加倍: 每一轮, cwnd加倍</p>
  </li>
  <li>
    <p>结束</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  超时, 取cwnd = 1, ssthresh = cwnd/2,重新慢启动

*  到达ssthresh, 进入拥塞避免模式

*  3个冗余ACK, ssthresh = cwnd/2, cwnd = cwnd/2+3, 快速重传后，进入快速恢复
</code></pre></div></div>

<ul>
  <li>
    <p>拥塞避免</p>
  </li>
  <li>
    <p>线性增加: 每一轮, cwnd+1</p>
  </li>
  <li>
    <p>结束</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  超时, 取cwnd = 1, ssthresh = cwnd/2, 相当于慢启动，进入慢启动

*  3个冗余ACK, ssthresh = cwnd/2, cwnd = cwnd/2+3, 进入快速恢复
</code></pre></div></div>

<ul>
  <li>
    <p>快速恢复</p>
  </li>
  <li>
    <p>接下来收到的冗余ACK, cwnd都加1(之前的3个冗余ACK已经加过3, 至少加3)</p>
  </li>
  <li>
    <p>结束</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  收到期待的ACK（当对丢失报文段的一个ACK到达时）, 将cwnd = ssthresh, 进入拥塞避免

*  超时, ssthresh = cwnd/2, cwnd = 1
</code></pre></div></div>

<ul>
  <li>
    <p>TCP拥塞控制: 回顾</p>
  </li>
  <li>
    <p>TCP Tahoe: 没有快速恢复, 3个ACK也进入慢启动</p>
  </li>
  <li>
    <p>TCP Reno: 上文的方案</p>
  </li>
</ul>

<blockquote>
  <p>加3根据协议不同, 看具体情况做</p>
</blockquote>

<blockquote>
  <p>慢启动: 其实是收到的每个ACK都加1, 因为ACK数等于发送数, 相当于翻倍</p>
</blockquote>

<ul>
  <li>
    <p>需要拥塞控制的原因: 浪费带宽</p>
  </li>
  <li>
    <p>速率接近容量 -&gt; 队列满 + 大排队时延</p>
  </li>
  <li>
    <p>大时延 -&gt; 不必要的超时重传</p>
  </li>
  <li>
    <p>队列满 -&gt; 丢包 -&gt; 浪费上游流量</p>
  </li>
  <li>
    <p>丢包 -&gt; 重传代价</p>
  </li>
</ul>

<h3 id="公平性">公平性</h3>

<ul>
  <li>
    <p>TCP AIMD</p>
  </li>
  <li>
    <p>相同的RTT: 公平, 最终会达到平均分配带宽</p>
  </li>
  <li>
    <p>RTT不同: RTT小的更快扩大窗口, 将得到更多带宽, 最终似乎与RTT成反比</p>
  </li>
  <li>
    <p>UDP参与</p>
  </li>
  <li>
    <p>UDP没有公平可言, 抢占资源</p>
  </li>
  <li>
    <p>UDP将挤压TCP资源</p>
  </li>
  <li>
    <p>并行TCP</p>
  </li>
  <li>
    <p>一个应用使用多个TCP连接, 就获得了多倍其应得的带宽</p>
  </li>
</ul>

<h3 id="网络辅助拥塞控制">网络辅助拥塞控制</h3>

<ul>
  <li>
    <p>IP首部设置ECN(2比特, 4状态), 送到接收主机</p>
  </li>
  <li>
    <p>接收主机在TCP ACK中设置ECE, 发到发送主机</p>
  </li>
  <li>
    <p>发送主机减半cwnd, 并在下一个报文头中设置CWD, 发到接收主机</p>
  </li>
</ul>

<p>第四章</p>

<p>=================</p>

<p>路由器工作原理</p>

<hr />

<ul>
  <li>
    <p>输入端口</p>
  </li>
  <li>
    <p>线路端接: 物理线路接入</p>
  </li>
  <li>
    <p>数据链路处理: 协议, 拆封</p>
  </li>
  <li>
    <p>查找转发排队: 查找转发表, 存帧排队</p>
  </li>
  <li>
    <p>交换结构</p>
  </li>
  <li>
    <p>经内存交换</p>
  </li>
  <li>
    <p>经总线交换</p>
  </li>
  <li>
    <p>经互连网络交换(纵横式)</p>
  </li>
  <li>
    <p>输出端口: 排队, 数据链路处理, 线路端接</p>
  </li>
  <li>
    <p>路由选择处理器: 执行控制平面功能, 维护路由选择表和链路状态, 计算转发表</p>
  </li>
  <li>
    <p>基于目的地转发: 仅考虑目的地</p>
  </li>
  <li>
    <p>通用转发: 考虑更多因素</p>
  </li>
</ul>

<h3 id="输入端口处理和基于目的地转发">输入端口处理和基于目的地转发</h3>

<ul>
  <li>
    <p>转发表在输入端口有副本, 在输入端口本地做出转发决策</p>
  </li>
  <li>
    <p>前缀匹配</p>
  </li>
  <li>
    <p>转发表不存储所有目的地址, 而是根据最长前缀匹配确定转发</p>
  </li>
  <li>
    <p>使用DRAM, SRAM, TCAM(三态内容可寻址存储器), 纳秒级</p>
  </li>
  <li>
    <p>其他动作</p>
  </li>
  <li>
    <p>出现物理层和链路层处理</p>
  </li>
  <li>
    <p>检查版本号, 检验和, 寿命, 重写后两个</p>
  </li>
  <li>
    <p>更新网络管理信息(如 计数器)</p>
  </li>
</ul>

<h3 id="交换">交换</h3>

<ul>
  <li>
    <p>经内存交换: 输入卡处理地址查找和分组存储, 所有输入共享内存</p>
  </li>
  <li>
    <p>经总线交换</p>
  </li>
  <li>
    <p>输入端口为分组计划一个交换机内部标签(首部)</p>
  </li>
  <li>
    <p>与首部匹配的输出端口存分组, 并去除标签</p>
  </li>
  <li>
    <p>经互连网络交换</p>
  </li>
  <li>
    <p>优点: 可以并行</p>
  </li>
  <li>
    <p>纵横式, N纵N横N*N交叉点</p>
  </li>
  <li>
    <p>非阻塞: 到不同输出端的分组不会互相阻塞</p>
  </li>
  <li>
    <p>更复杂(去数据通信笔记看)</p>
  </li>
  <li>
    <p>三级非阻塞网络</p>
  </li>
</ul>

<h3 id="输出端口处理">输出端口处理</h3>

<ul>
  <li>输出缓存, 数据链路处理(协议, 封装), 线路端接</li>
</ul>

<h3 id="何处出现排队">何处出现排队</h3>

<ul>
  <li>
    <p>丢包: 没有缓存可以用来存储到达的分组</p>
  </li>
  <li>
    <p>输入排队</p>
  </li>
  <li>
    <p>交换结构不足以使所有到达分组无时延地通过它传送</p>
  </li>
  <li>
    <p>HOL阻塞(线路前部阻塞): 被线路前部的一个分组阻塞, 例如两个分组发往一个目的地</p>
  </li>
  <li>
    <p>输出排队</p>
  </li>
  <li>
    <p>没有足够的内存存储到达的分组</p>
  </li>
  <li>
    <p>主动队列管理AQM</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  弃尾: 丢弃到达的分组

*  也可以删除正在排队的部分分组

*  向发送方提供阻塞信号
</code></pre></div></div>

<ul>
  <li>
    <p>随机早期检测RED</p>
  </li>
  <li>
    <p>缓存大小: $B=\textrm{RTT}\cdot C/\sqrt{N}$, $C$为链路容量, $N$链路上的TCP流数量, $\textrm{RTT}$平均往返时延</p>
  </li>
</ul>

<h3 id="分组调度">分组调度</h3>

<ul>
  <li>
    <p>先进先出FIFO 先来先服务FCFS</p>
  </li>
  <li>
    <p>维护一个队列, 来了进入队尾, 队首挨个处理</p>
  </li>
  <li>
    <p>优先权排队</p>
  </li>
  <li>
    <p>每个优先权类有自己的队列, 各自FIFO</p>
  </li>
  <li>
    <p>不同优先级, 高的队列空了才处理低的</p>
  </li>
  <li>
    <p>非抢占: 已经开始的传输不会被打断</p>
  </li>
  <li>
    <p>循环排队规则</p>
  </li>
  <li>
    <p>多个队列, 不分优先级, 轮流提供服务</p>
  </li>
  <li>
    <p>保持工作排队规则: 有任何类的分组在等待, 则不允许链路保持空闲</p>
  </li>
  <li>
    <p>加权公平排队</p>
  </li>
  <li>
    <p>在循环排队的基础上加上优先级</p>
  </li>
  <li>
    <p>每一循环, 每个类得到多次服务, 次数与权重成正比</p>
  </li>
</ul>

<p>网际协议</p>

<hr />

<h3 id="ipv4数据报格式">IPv4数据报格式</h3>

<ul>
  <li>数据报格式</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>版本 4</td>
      <td>首部长度 4</td>
      <td>服务类型 8</td>
      <td>数据报长度16</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>标识16</td>
      <td>标志 3</td>
      <td>片偏移13</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>寿命 8</td>
      <td>上层协议 8</td>
      <td>首部检验和16</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>(NoNAT)源地址32</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>(NoNAT)目的地址32</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>选项(可选)</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>数据</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>服务类型: 优先级(3bit), 可靠性(1bit, 一般/高), 时延(1bit, 一般/低), 吞吐量(1bit, 一般/高)</p>
  </li>
  <li>
    <p>标识, 标志, 片偏移: 与IPv4分片有关</p>
  </li>
  <li>
    <p>选项: 长度不定, 默认首部长度为20字节, 可变</p>
  </li>
  <li>
    <p>数据报长度: 首部加数据的长度, 字节为单位</p>
  </li>
  <li>
    <p>寿命: 经过一个路由器, 减1, 为0丢弃</p>
  </li>
  <li>
    <p>协议: 到达目的地才有用, 6-TCP, 17-UDP, 类似端口号</p>
  </li>
</ul>

<h3 id="ipv4数据报分片">IPv4数据报分片</h3>

<ul>
  <li>
    <p>原因: 链路层最大传输单元MTU, 限制IP数据报的长度</p>
  </li>
  <li>
    <p>对数据报分片, 并设置标识等</p>
  </li>
  <li>
    <p>标识: 每个数据报+1, 一个数据报的各个分片相同</p>
  </li>
  <li>
    <p>标志: 最后一个为0, 其他是1</p>
  </li>
  <li>
    <p>片偏移: 以64bit为单位</p>
  </li>
</ul>

<h3 id="ipv4编址">IPv4编址</h3>

<ul>
  <li>
    <p>接口: 主机与物理线路的边界</p>
  </li>
  <li>
    <p>点分十进制记法: 192.168.0.255, 就这样的, 每个8位当作十进制数, 点分开</p>
  </li>
  <li>
    <p>地址分类:</p>
  </li>
  <li>
    <p>A: 0开头/8</p>
  </li>
  <li>
    <p>B: 10开头/16</p>
  </li>
  <li>
    <p>C: 110开头/24</p>
  </li>
  <li>
    <p>子网(IP网络): CIDR无类别域间路由选择</p>
  </li>
  <li>
    <p>子网掩码: xxx.xxx.xxx.xxx/yy, yy为子网掩码,</p>
  </li>
  <li>
    <p>网络前缀: 地址的前yy位</p>
  </li>
  <li>
    <p>子网内的地址: 剩下的位数</p>
  </li>
  <li>
    <p>另一种表示: 前yy位为1, 剩下为0, 用点分十进制写出来</p>
  </li>
  <li>
    <p>路由聚合/路由摘要: 一个组织共享相同前缀</p>
  </li>
  <li>
    <p>主机得到地址的过程</p>
  </li>
  <li>
    <p>获取一块地址</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  来自ISP, ISP来自ICANN

*  管理员划分这些地址给子网
</code></pre></div></div>

<ul>
  <li>获取主机地址: DHCP</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  所有的目的地址都是 255.255.255.255

*  DHCP服务器发现: 新到达的主机发送DHCP发现报文

  *  UDP目的端口67的报文

  *  目的: 255.255.255.255

  *  内容: 事务ID

*  DHCP服务器提供: 服务器的相应

  *  UDP目的端口68（其它端口也行）的报文

  *  源: DHCP服务器地址

  *  内容

    *  事务ID, 推荐IP地址, 掩码, 地址租期

*  DHCP请求: 主机选择一个服务器, 相应

  *  UDP端口67的报文

  *  源: 0.0.0.0

  *  内容: 回显配置信息, 事务ID+1

*  DHCP ACK: 确认配置

  *  UDP端口68的报文

  *  源: DHCP服务器地址

  *  内容: 证实参数, 事务ID+1
</code></pre></div></div>

<h3 id="网络地址转换nat">网络地址转换NAT</h3>

<ul>
  <li>
    <p>NAT路由器: 它和它背后的网路对外界是一台单一的设备</p>
  </li>
  <li>
    <p>允许内部外部通信, 使用不同的地址</p>
  </li>
  <li>
    <p>NAT路由器将重写IP地址和端口号字段</p>
  </li>
  <li>
    <p>NAT转换表</p>
  </li>
  <li>
    <p>内部地址:端口 - 外部地址:端口</p>
  </li>
  <li>
    <p>NAT穿越: 解决内网服务器周知端口问题</p>
  </li>
  <li>
    <p>UPnP: 通用即插即用协议, 解决NAT自动配置</p>
  </li>
  <li>
    <p>跨越网络层和传输层</p>
  </li>
</ul>

<h3 id="ipv6">IPv6</h3>

<ul>
  <li>数据报格式</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>版本 4</td>
      <td>流量类型 8</td>
      <td>流量标签 20</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>有效载荷长度 16</td>
      <td>下一个首部 8</td>
      <td>寿命 8</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>源地址 128</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>目的地址 128</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>数据</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>首部定长40字节</p>
  </li>
  <li>
    <p>版本: 6</p>
  </li>
  <li>
    <p>流量类型: 与IP的服务类型字段类似</p>
  </li>
  <li>
    <p>流标签: 识别数据报的流, 用于优先权等</p>
  </li>
  <li>
    <p>有效载荷长度: 给出数据段的长度, 不含头部</p>
  </li>
  <li>
    <p>下一个首部 = 上层协议类型, 与IPv4的协议类型同值</p>
  </li>
  <li>
    <p>与IPv4的不同</p>
  </li>
  <li>
    <p>IPv6不允许由路由器进行分片, 因此没有分片3字段</p>
  </li>
  <li>
    <p>首部检验和: 运输层和数据链路层进行过检验, 因此丢掉</p>
  </li>
  <li>
    <p>选项: 不是标准IP的一部分了, 可能出现在”下一个首部”指定的地方</p>
  </li>
  <li>
    <p>从IPv4到IPv6</p>
  </li>
  <li>
    <p>隧道: IPv6数据报放入IPv4的有效载荷字段中, 上层协议41</p>
  </li>
</ul>

<p>第五章</p>

<p>=================</p>

<p>路由选择算法</p>

<hr />

<ul>
  <li>
    <p>路由选择算法: 从发送方到接收方, 确定一条通过路由器网络的好的路径</p>
  </li>
  <li>
    <p>图, 节点, 路径, 最低开销路径, 最短路径</p>
  </li>
  <li>
    <p>分类1</p>
  </li>
  <li>
    <p>集中式路由选择算法(链路状态算法): 完整, 全局的网络知识, 计算源到目的的最低开销路径</p>
  </li>
  <li>
    <p>分散式路由选择算法(距离向量算法): 迭代, 分布式地计算出最低开销路径</p>
  </li>
  <li>
    <p>分类2</p>
  </li>
  <li>
    <p>静态路由选择算法: 变化很慢, 人工配置</p>
  </li>
  <li>
    <p>动态路由选择算法: 随着网络流量负载变化或拓扑发生变化而改变路由选择路径</p>
  </li>
  <li>
    <p>分类3</p>
  </li>
  <li>
    <p>负载敏感: 链路开销反映拥塞水平</p>
  </li>
  <li>
    <p>负载迟钝: 反之</p>
  </li>
</ul>

<h3 id="链路状态路由选择算法">链路状态路由选择算法</h3>

<ul>
  <li>
    <p>算法流程</p>
  </li>
  <li>
    <p>$u$源, $D(v)$从源到$v$的距离, $p(v)$到$v$的最短路上的下一个节点</p>
  </li>
  <li>
    <p>首先$D(v)$正无穷, 若有边设为边的开销</p>
  </li>
  <li>
    <p>每一轮, 找出$D(v)$中最小的一个$v$, 进行如下操作</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  用这个$D(v)$更新$v$的所有邻点的开销, 值为$D(v)$加边开销
</code></pre></div></div>

<ul>
  <li>
    <p>直到不再变化</p>
  </li>
  <li>
    <p>复杂性: $O(n^2)$</p>
  </li>
  <li>
    <p>出现的问题</p>
  </li>
  <li>
    <p>同时运行LS算法的路由器</p>
  </li>
  <li>
    <p>链路选择的震荡, 由于一侧拥塞, 都选择另一侧, 而恰好使得这一侧也拥塞, 不断往返</p>
  </li>
  <li>
    <p>解决: 随机化发送链路通告的时间</p>
  </li>
</ul>

<h3 id="距离向量路由选择算法">距离向量路由选择算法</h3>

<ul>
  <li>
    <p>算法流程: 对于每个节点</p>
  </li>
  <li>
    <p>更新距离向量估计值, 当直接相连的链路开销发生变化, 或从邻居接收到距离向量的更新</p>
  </li>
  <li>
    <p>更新规则: 取最小值, 对所有$D_v(y)+c(x,v)$以及原有的距离, $v$是$x$的邻居</p>
  </li>
  <li>
    <p>路由选择环路</p>
  </li>
  <li>
    <p>无穷计数: 有环路的情况下, 链路代价的增加, 将会反复震荡, 长时间后才能达到稳定</p>
  </li>
  <li>
    <p>毒性逆转: 如果z通过y路由选择到x, 则z将通告y, z到x的距离是无穷大</p>
  </li>
  <li>
    <p>涉及到3个或更多节点的环路还是不能解决无穷计数</p>
  </li>
</ul>

<p>算法比较</p>

<hr />

<ul>
  <li>
    <p>报文复杂性</p>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>LS: $O(</td>
          <td>N</td>
          <td> </td>
          <td>E</td>
          <td>)$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <p>DV: 仅在新的链路开销导致与该链路相连节点的最低开销路径发生改变, 才传播开销</p>
  </li>
  <li>
    <p>收敛速度</p>
  </li>
  <li>
    <p>LS: 收敛块</p>
  </li>
  <li>
    <p>DV: 较慢, 还有无穷计数</p>
  </li>
  <li>
    <p>健壮性</p>
  </li>
  <li>
    <p>LS: 节点分别计算自己的最短路径, 一定程度健壮性</p>
  </li>
  <li>DV: 一个节点的错误计算值, 扩散到整个网络</li>
</ul>

<p>因特网中自治系统内部的路由选择OSPF</p>

<hr />

<ul>
  <li>
    <p>自治系统AS</p>
  </li>
  <li>
    <p>由处在相同管理控制下的路由器组成</p>
  </li>
  <li>
    <p>具有 自治系统内部路由选择协议</p>
  </li>
  <li>
    <p>具有 独有的AS编号 ASN</p>
  </li>
</ul>

<h3 id="开放最短路优先ospf">开放最短路优先OSPF</h3>

<ul>
  <li>
    <p>是一种链路状态协议: 洪泛状态信息 + Dijkstra算法</p>
  </li>
  <li>
    <p>各个链路的开销: 管理员进行配置</p>
  </li>
  <li>
    <p>路由选择信息: 向全部路由器广播</p>
  </li>
  <li>
    <p>广播条件: 有链路状态发生变化 / 至少每30min一次</p>
  </li>
  <li>
    <p>报文: 直接由IP承担, 上层协议的值为89, 自己实现可靠传输和链路状态广播</p>
  </li>
  <li>
    <p>其他功能: 检查链路运行(发送OSPF HELLO), 获得相邻路由的链路状态数据库</p>
  </li>
  <li>
    <p>优点</p>
  </li>
  <li>
    <p>安全: 鉴别报文防止伪造(使用口令或MD5), 序号防范重放攻击</p>
  </li>
  <li>
    <p>多条相同开销的路径: 允许使用多条路径</p>
  </li>
  <li>
    <p>单播与多播: MOSPF使用现有的链路数据库, 链路状态广播机制增加新型链路状态通告</p>
  </li>
  <li>
    <p>AS内层次结构: OSPF自治系统内部也可以配置多个区域, 运行自己的OSPF算法</p>
  </li>
</ul>

<p>ISP之间的路由选择BGP</p>

<hr />

<ul>
  <li>
    <p>自治系统间路由选择协议</p>
  </li>
  <li>
    <p>边界网关协议: BGP</p>
  </li>
</ul>

<h3 id="bgp的作用">BGP的作用</h3>

<ul>
  <li>
    <p>BGP中, 分组不是路由到特定的地址, 而是路由到CIDR化的前缀</p>
  </li>
  <li>
    <p>协议提供的手段</p>
  </li>
  <li>
    <p>从邻居AS获得前缀的可达性信息: 允许子网广播自己的存在</p>
  </li>
  <li>
    <p>确定到该前缀的”最好的”路由: 本地运行BGP路由选择过程, 基于策略和可达性信息</p>
  </li>
</ul>

<h3 id="通告bgp路由信息">通告BGP路由信息</h3>

<ul>
  <li>
    <p>网关路由器: AS边缘的路由器, 直接连接到其他AS中的路由器</p>
  </li>
  <li>
    <p>内部路由器: 只连接了同一AS内的路由器</p>
  </li>
  <li>
    <p>BGP连接</p>
  </li>
  <li>
    <p>在端口179的半永久TCP连接</p>
  </li>
  <li>
    <p>eBGP: 跨越AS的BGP连接</p>
  </li>
  <li>
    <p>iBGP: 相同的AS内的两台路由器的连接</p>
  </li>
  <li>
    <p>传递可达信息: 不断重复 AS内广播, 网关传递到其他AS 的过程</p>
  </li>
</ul>

<h3 id="确定最好的路由">确定最好的路由</h3>

<ul>
  <li>
    <p>BGP属性: 路由器通告前缀时, 会在前缀中包括BGP属性</p>
  </li>
  <li>
    <p>AS-PATH属性</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  每当前缀通过(离开)一个AS, (网关路由器)就在AS-PATH属性末尾, 加上自己的ASN

*  若其中已有自己的ASN, 则拒绝该通告, 以防止环路

*  于是, 接到这个通告的路由器, AS-PATH从头到尾恰为到达目标需要经过的AS的顺序
</code></pre></div></div>

<ul>
  <li>NEXT-HOP属性</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  是该AS-PATH起始路由器接口的IP地址, 也就是连接AS1, AS2的子网中, AS2网关路由器的地址
</code></pre></div></div>

<ul>
  <li>
    <p>目的前缀属性</p>
  </li>
  <li>
    <p>更多</p>
  </li>
  <li>
    <p>热土豆(烫手山芋)路由选择</p>
  </li>
  <li>
    <p>不考虑AS-PATH, 只关注NEXT-HOP</p>
  </li>
  <li>
    <p>用内部路由协议确定, 所有的NEXT-HOP中, 开销最小的一个</p>
  </li>
  <li>
    <p>目的是尽快将分组送出AS, 如同烫手山芋</p>
  </li>
  <li>
    <p>路由器选择算法</p>
  </li>
  <li>
    <p>依次使用规则, 直到只剩一个</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  选择本地偏好最高的

  *  路由被指派本地偏好(是BGP属性之一), 可由该路由器设置或学习到, 取决于网络管理员

*  选择最短AS-PATH的路由, 使用DV确定路径, 距离测度使用AS跳的跳数

*  使用热土豆路由选择

*  使用BGP标识选择
</code></pre></div></div>

<h3 id="ip任播">IP任播</h3>

<ul>
  <li>
    <p>访问某任播地址的请求, 到达一系列主机中的一个</p>
  </li>
  <li>
    <p>CDN</p>
  </li>
  <li>
    <p>多台服务器, 相同IP地址, 都用BGP通告各自的IP地址</p>
  </li>
  <li>
    <p>路由器将认为收到的多个通告, 是到达同一服务器的不同路径(其实是不同的服务器, 只是配置为相同的服务)</p>
  </li>
  <li>
    <p>客户请求时, 路由器将路由到”较近”的CDN服务器</p>
  </li>
  <li>
    <p>DNS</p>
  </li>
  <li>
    <p>根服务器13个地址, 每个地址有许多镜像</p>
  </li>
  <li>
    <p>类似CDN, 可以让DNS请求到达”最近的”镜像</p>
  </li>
</ul>

<h3 id="路由选择策略">路由选择策略</h3>

<ul>
  <li>
    <p>选择的路由通告策略</p>
  </li>
  <li>
    <p>ISP协商等, 确定BGP通告规则, 拒绝某些通告, 尽管这些通告能够提供有效的路径</p>
  </li>
  <li>
    <p>例如BC直连, 另有BXC路线, X可以选择拒绝通告B和C自己能到达C或B, 以达到不转发BC流量的目的</p>
  </li>
</ul>

<h3 id="拼装在一起-在因特网中呈现">拼装在一起: 在因特网中呈现</h3>

<ul>
  <li>[木大警告] 这节不知道在讲什么玩意, 全是例子</li>
</ul>

<p>因特网控制报文协议ICMP</p>

<hr />

<ul>
  <li>
    <p>ICMP在IP之上, 位于IP分组的有效载荷字段, 上层协议字段为1</p>
  </li>
  <li>
    <p>字段</p>
  </li>
  <li>
    <p>类型</p>
  </li>
  <li>
    <p>编码</p>
  </li>
  <li>
    <p>引发该ICMP报文生成的IP数据报的首部, 及其前8字节</p>
  </li>
  <li>
    <p>详细</p>
  </li>
  <li>
    <p>0-0: PING回显</p>
  </li>
  <li>
    <p>3-[0~3]: 目的[网络/主机/协议/端口]不可达</p>
  </li>
  <li>
    <p>3-[6-7]: 目的[网络/主机]未知</p>
  </li>
  <li>
    <p>4-0: 源抑制</p>
  </li>
  <li>
    <p>8-0: PING请求</p>
  </li>
  <li>
    <p>9-0: 路由器通告</p>
  </li>
  <li>
    <p>10-0: 路由器发现</p>
  </li>
  <li>
    <p>11-0: TTL过期</p>
  </li>
  <li>
    <p>12-0: IP首部损坏</p>
  </li>
  <li>
    <p>例子</p>
  </li>
  <li>
    <p>PING: 类型8编码0, 回显: 类型0编码0</p>
  </li>
  <li>
    <p>ICMP源抑制: 网络层拥塞控制, 然而TCP有了, 废物一件</p>
  </li>
  <li>
    <p>TRACEROUTE</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  利用报文过期的ICMP的TTL过期报文(内含路由器的地址和名字)

*  每个包的目的端口号都不可达, 使用ICMP的目的端口不可达报文, 确定探索结束
</code></pre></div></div>

<ul>
  <li>
    <p>IPv6新的ICMPv6</p>
  </li>
  <li>
    <p>分组太大</p>
  </li>
  <li>
    <p>未被承认的IPv6选项</p>
  </li>
</ul>

<p>第六章</p>

<p>=================</p>

<p>多路访问链路和协议</p>

<hr />

<ul>
  <li>
    <p>广播链路: 多点, 一个信道</p>
  </li>
  <li>
    <p>碰撞: 多个结点同时发送</p>
  </li>
</ul>

<h3 id="信道划分协议">信道划分协议</h3>

<ul>
  <li>
    <p>时分复用TDM</p>
  </li>
  <li>
    <p>时隙slot, 每轮每结点一个时隙</p>
  </li>
  <li>
    <p>速率: R/N, 负载不均衡时浪费, 统计时分复用解决, 有额外开销</p>
  </li>
  <li>
    <p>频分复用FDM</p>
  </li>
  <li>
    <p>分频率, 一人一频</p>
  </li>
  <li>
    <p>速率: R/N, 负载不均衡时浪费</p>
  </li>
  <li>
    <p>码分多址CDMA</p>
  </li>
  <li>
    <p>每结点一个编码, 1电平为此编码, 0为编码取反</p>
  </li>
  <li>
    <p>速率: R, 可同时发送(每个结点的编码必须线性不相关), 抗干扰</p>
  </li>
</ul>

<h3 id="随机接入协议">随机接入协议</h3>

<ul>
  <li>
    <p>时隙ALOHA</p>
  </li>
  <li>
    <p>有ACK</p>
  </li>
  <li>
    <p>前提: 每帧长L, 每时隙L/R, 结点同步, 且在时隙开始时才传输, 碰撞检测够快</p>
  </li>
  <li>
    <p>流程</p>
  </li>
  <li>
    <p>发送: 结点在一个时隙开始发送帧</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> *  成功: 若没检测到碰撞, 则认为成功传输
</code></pre></div></div>

<ul>
  <li>
    <p>失败: 检测到碰撞, 在之后的时隙中以概率p不断尝试重传, 直到没有碰撞</p>
  </li>
  <li>
    <p>效率: 取p=1/N时最大化, 当N趋于无穷时, 效率为1/e</p>
  </li>
  <li>
    <p>ALOHA</p>
  </li>
  <li>
    <p>有ACK</p>
  </li>
</ul>

<blockquote>
  <p>除了不同步, 跟时隙ALOHA一样</p>
</blockquote>

<ul>
  <li>
    <p>流程</p>
  </li>
  <li>
    <p>发送: 结点发送帧</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  成功: 若没检测到碰撞, 则认为成功传输
</code></pre></div></div>

<ul>
  <li>
    <p>失败: 检测到碰撞, 立刻以概率p不断尝试重传, 直到没有碰撞</p>
  </li>
  <li>
    <p>效率: 取p=1/N时最大化, 当N趋于无穷时, 效率为1/2e(前后都可能有重叠)</p>
  </li>
  <li>
    <p>CSMA/CD</p>
  </li>
  <li>
    <p>无ACK</p>
  </li>
  <li>
    <p>不做同步</p>
  </li>
  <li>
    <p>流程</p>
  </li>
  <li>
    <p>监听: 监听信道是否空闲, 空闲时才开始传输, 传输前得等96比特时间(最小帧间隔)</p>
  </li>
  <li>
    <p>传输: 传输时也不断监听是否有其他结点的信号能量</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> *  成功: 未发现其他能量, 认为发送成功
</code></pre></div></div>

<ul>
  <li>
    <p>失败: 发现其他能量, 立刻停止; <strong>发送48bit干扰信号</strong></p>
  </li>
  <li>
    <p>等待(非持续): 等待一个随机时间, 回到”监听”重传</p>
  </li>
  <li>
    <p>回退(p持续): 之后的时间当中以概率p重传</p>
  </li>
  <li>
    <p>回退(1持续, 以太网): 使用二进制指数后退</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> *  经历过了k次碰撞, 就从\[0,…,2^k-1\]中选一个K值, 等待512K个比特时间

 *  k最大为10

 *  最多尝试16次发送
</code></pre></div></div>

<ul>
  <li>效率: 近似为</li>
</ul>

\[\frac{1}{1+5d_{prop}/d_{trans}}\]

<ul>
  <li>最小帧长: 检测冲突的时长不超过端到端传播时延的2倍, 取这一值为最小帧长</li>
</ul>

<h3 id="轮流协议">轮流协议</h3>

<ul>
  <li>
    <p>轮询协议</p>
  </li>
  <li>
    <p>流程: 每个从结点n</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  主节点发帧, 告诉从节点n能够发送的最大包数

*  从节点发送不超过n帧

*  主节点发现没有信号了, 继续轮询下一个从节点
</code></pre></div></div>

<ul>
  <li>
    <p>缺点: 轮询时延(第一步耗时); 主节点损坏则信道无用</p>
  </li>
  <li>
    <p>令牌传递协议</p>
  </li>
  <li>
    <p>流程</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  收到令牌

*  如果有帧要发, 则发送不超过最大数目的帧数

*  传递令牌
</code></pre></div></div>

<ul>
  <li>缺点: 令牌传播时延, 令牌丢失, 单点故障则信道崩溃</li>
</ul>

<p>交换局域网</p>

<hr />

<h3 id="链路层寻址和arp">链路层寻址和ARP</h3>

<ul>
  <li>
    <p>媒体访问控制 MAC地址</p>
  </li>
  <li>
    <p>长度: 6字节</p>
  </li>
  <li>
    <p>与适配器(NIC等)绑定</p>
  </li>
  <li>
    <p>广播地址: 全1, 即12个F</p>
  </li>
  <li>
    <p>每个主机都检查MAC是否与自己相同, 相同则接收</p>
  </li>
  <li>
    <p>地址解析协议 ARP协议</p>
  </li>
  <li>
    <p>子网内解析</p>
  </li>
  <li>
    <p>每台主机或路由器存有ARP表, 保存了其知晓的MAC-IP对应关系, 每个条目有过期时间</p>
  </li>
  <li>
    <p>流程</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  若有表项, 直接构造包并发送

*  若无, 向适配器发送ARP分组(内容: 发送和接收的IP地址, 目的MAC: 广播地址)

*  每个主机都收到, 若IP相同, 则响应ARP分组, 用标准链路层帧回复
</code></pre></div></div>

<ul>
  <li>
    <p>发送数据报到子网以外</p>
  </li>
  <li>
    <p>路由器每个端口均有MAC和IP</p>
  </li>
  <li>
    <p>路由器将相应ARP, 主机获得的此IP的MAC地址是路由器这一端口的MAC</p>
  </li>
</ul>

<h3 id="以太网">以太网</h3>

<ul>
  <li>
    <p>以太网帧结构</p>
  </li>
  <li>
    <p>帧字段</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  前同步码: 8字节: 前7个字节都是10101010, 同步时钟并唤醒适配器; 最后一个是10101011, “11”警告适配器数据到来

*  目的MAC地址: 6字节: 与自己的MAC相同才会接收

*  源MAC地址: 6字节

*  类型字段: 2字节: 允许以太网复用多种网络层协议

*  数据: 46-1500: 承载IP数据报, 超长将分片

*  CRC: 4字节: 适配器丢弃校验出错的帧
</code></pre></div></div>

<ul>
  <li>
    <p>无连接服务: 不事先握手</p>
  </li>
  <li>
    <p>不可靠服务: 成功无ACK, 失败无REJ</p>
  </li>
  <li>
    <p>以太网技术</p>
  </li>
  <li>
    <p>命名: [速率]BASE[距离 或 介质], T指铜双绞线, FX/SX/BX指光纤</p>
  </li>
  <li>
    <p>10Mbps: 10BASE[%d], 距离, 使用同轴电缆</p>
  </li>
  <li>
    <p>100Mbps: 100BASE-TX/T4/T2双绞线, -FX/SX/BX光纤</p>
  </li>
  <li>
    <p>1000Mbps: 1000BASE-T等, 又名802.3z, 双绞线, 兼容旧标准, 点对点(交换机)信道全双工, 另有广播(集线器)</p>
  </li>
  <li>
    <p>10Gbps: 10GBASE-T</p>
  </li>
</ul>

<h3 id="链路层交换机">链路层交换机</h3>

<ul>
  <li>
    <p>交换机转发和过滤</p>
  </li>
  <li>
    <p>过滤: 决定帧应该发到某个接口还是将其丢弃</p>
  </li>
  <li>
    <p>转发: 决定帧去往哪个接口</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  流程: 借助交换机表(MAC - 接口 - 时间)

  *  没找到目的MAC, 向源以外的所有端口广播

  *  找到MAC, 与源端口匹配, 则丢弃

  *  找到MAC, 与另一端口匹配, 转发到这一端口(进入端口的缓存)
</code></pre></div></div>

<ul>
  <li>
    <p>自学习</p>
  </li>
  <li>
    <p>流程</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  初始: 交换表为空

*  学习: 收到帧, 则将\[源MAC地址 - 到达的接口 - 当前时间\]存入交换表

*  老化: 一段时间后未收到这一地址作为源的帧, 则此表项移除
</code></pre></div></div>

<ul>
  <li>
    <p>即插即用设备: 无需进行配置</p>
  </li>
  <li>
    <p>双工: 每个接口可同时发送和接收</p>
  </li>
  <li>
    <p>链路层交换机的性质</p>
  </li>
  <li>
    <p>消除碰撞: 星型拓扑, 没有因碰撞而浪费的带宽</p>
  </li>
  <li>
    <p>异质链路: 链路彼此隔离, 允许不同速率, 新旧混用</p>
  </li>
  <li>
    <p>管理: 检测异常适配器并断开之, 等</p>
  </li>
  <li>
    <p>交换机与路由器</p>
  </li>
  <li>
    <p>交换机</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  优: 即插即用, 分组过滤, 高速率

*  缺: 拓扑限制为树形, 不提供广播风暴的保护
</code></pre></div></div>

<ul>
  <li>路由器</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  优: 拓扑灵活, 提供防火墙保护

*  缺: 需要配置, 处理延迟大
</code></pre></div></div>

<h3 id="网桥">网桥</h3>

<ul>
  <li>
    <p>功能: 读取A网(总线)的所有帧, 在B(总线)上重发每个帧; B-&gt;A同理</p>
  </li>
  <li>
    <p>特点: 不更改帧, 原样转发; 带缓存; 路由寻址能力(基于MAC, 只转发需要转发的帧)</p>
  </li>
  <li>
    <p>协议体系</p>
  </li>
  <li>
    <p>层次: 数据链路层 - MAC层</p>
  </li>
  <li>
    <p>链接模式</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. `局域网 - 网桥 - 局域网`, 原样转发

2. `局域网 - 网桥 - [网络或链路] - 网桥 - 局域网`, 需要适当封装, 但原始MAC帧不修改
</code></pre></div></div>

<ul>
  <li>
    <p>固定路由选择</p>
  </li>
  <li>
    <p>每对点均有一条选定的路由, 跳数最少, 仅在拓扑变化时改变(生成树算法)</p>
  </li>
  <li>
    <p>生成树方法</p>
  </li>
  <li>
    <p>帧转发</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  x收到帧

*  检查目的地址: 若在某一端口的列表中, 且非阻塞, 发送; 不在任何列表, 则x除以外的端口全部转发
</code></pre></div></div>

<ul>
  <li>地址探索: 同交换机</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  收到帧, 则帧源地址MAC与此端口关联, 加入此端口数据库

*  数据库项带计时器, 超时删除
</code></pre></div></div>

<ul>
  <li>最小生成树算法: Prim</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  Prim算法流程

  *  选取起始点(根网桥), 加入集合S

  *  对于S中所有点(网桥), 在他们所有邻居里面找离S中点最短的距离, 把这个邻居加入S, 这条边(网桥间的最短距离)加入生成树

  *  直到所有点都加入S, 边集合构成生成树

*  网桥阻塞规则

  *  选择根网桥: ID最小的网桥

  *  为每个网桥选择root port: 到根网桥最低开销的端口

  *  为每个LAN指定网桥: 拥有到根网桥最低开销路径的, 与这个LAN相连的网桥

  *  Designated port: 这个指定网桥与这个LAN相连的端口

  *  Designated port 和 root port 不阻塞, 别的都阻塞
</code></pre></div></div>

<h3 id="虚拟局域网">虚拟局域网</h3>

<ul>
  <li>
    <p>树形交换局域网的缺陷</p>
  </li>
  <li>
    <p>缺乏流量隔离: 单播能够隔离, 但广播不行; 缺乏安全隐私的隔离</p>
  </li>
  <li>
    <p>交换机无效使用: 为了分组造成交换机端口的浪费</p>
  </li>
  <li>
    <p>管理用户: 用户在分组间移动, 则需要改变物理布线, 连接到不同交换机</p>
  </li>
  <li>
    <p>VLAN: 单一的物理交换机定义多个虚拟局域网, 广播流量仅到达同一分组的端口</p>
  </li>
  <li>
    <p>跨VLAN需要路由器</p>
  </li>
  <li>
    <p>VLAN划分: 端口 或 MAC</p>
  </li>
  <li>
    <p>VLAN干线连接</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  干线接口: VLAN交换机之间交换帧

*  帧格式802.1Q: 以太网帧的源地址和类型之间, 加入VLAN标志
</code></pre></div></div>

<p>第七章</p>

<p>=================</p>

<p>802.11 体系结构</p>

<hr />

<ul>
  <li>
    <p>接入点AP： 中央基站</p>
  </li>
  <li>
    <p>基本服务集BSS: 1AP + 若干站点(其NIC有唯一MAC)</p>
  </li>
  <li>
    <p>基础设施无线LAN: AP和将AP连接到路由器的有线以太网</p>
  </li>
  <li>
    <p>信道与关联</p>
  </li>
  <li>
    <p>服务集标识符SSID: 热点名(单字/双字)</p>
  </li>
  <li>
    <p>信道: 一共11个, 1 6 11是三个不重叠信道</p>
  </li>
  <li>
    <p>关联: 站点选择一个AP, 仅通过它接入因特网</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  信标帧: AP周期性广播发送, 包含SSID和MAC

*  被动扫描: 站点等待信标帧

*  主动扫描: 站点广播探测帧, AP回复探测响应帧

*  关联流程: 类似DHCP

  *  关联请求帧 -&gt; 关联响应帧 -&gt; (第二次握手, 与想关联的AP)
</code></pre></div></div>

<p>CSMA/CA: 802.11 MAC协议</p>

<hr />

<ul>
  <li>
    <p>带碰撞避免的CSMA: CSMA/CA</p>
  </li>
  <li>
    <p>载波侦听</p>
  </li>
  <li>
    <p>碰撞避免</p>
  </li>
  <li>
    <p>使用链路层ARQ: 确认/重传, 有ACK</p>
  </li>
  <li>
    <p>不适用碰撞检测的原因</p>
  </li>
  <li>
    <p>接收信号的强度远小于发送信号的强度, 检测碰撞代价大</p>
  </li>
  <li>
    <p>由于隐藏终端, 衰减问题, 无法检测所有的碰撞</p>
  </li>
  <li>
    <p>链路层确认方案</p>
  </li>
  <li>
    <p>目的接到帧, 且通过了CRC检验, 则等待”短帧间间隔SIFS”, 发回确认帧</p>
  </li>
  <li>
    <p>发送站点在给定时间内未收到确认, 将会假定发生错误, 并重传该帧</p>
  </li>
  <li>
    <p>多次重传失败, 将放弃发送并丢弃该帧</p>
  </li>
  <li>
    <p>CSMA/CA流程</p>
  </li>
  <li>
    <p>监听到信道空闲, 则在”分布式帧间间隔DIFS”的短时间后发送</p>
  </li>
  <li>
    <p>否则, 选取一个随机回退值, 并在侦听信道空闲时递减该值, 若信道忙, 则不变</p>
  </li>
  <li>
    <p>当值为0时, 发送整个帧</p>
  </li>
  <li>
    <p>如果收到确认, 则该帧已被正确接收</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  如果此时需要发下一帧, 直接从第二步开始

*  如果没有确认, 则进入第二步的回退, 并从更大的范围选取随机值
</code></pre></div></div>

<ul>
  <li>
    <p>处理隐藏终端</p>
  </li>
  <li>
    <p>隐藏终端: AP与节点A B均相互可见, 但由于信号衰减, AB之间互相接收不到对方的信号, 无从进行载波侦听</p>
  </li>
  <li>
    <p>请求发送(RTS)帧, 短: 站点广播, 指示传输DATA帧和ACK需要的总时间</p>
  </li>
  <li>
    <p>允许发送(CTS)帧, 短: AP广播, 给发送方明确地许可, 并让其他站点知道不要发送</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  收到CTS且不是自己发送RTS的站点, 将在其中的时间段内, 抑制发送
</code></pre></div></div>

<ul>
  <li>效果</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  解决隐藏终端, 长DATA只会在预约后才被传输

*  发生RTS和CTS的碰撞, 因为他们很短, 仅持续很短时间
</code></pre></div></div>

<ul>
  <li>实际</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  RTS门限值, 大于此的数据才会预约

*  许多站点的RTS门限大于帧长, 默认不使用RTS/CTS
</code></pre></div></div>

<ul>
  <li>
    <p>点对点网络</p>
  </li>
  <li>
    <p>定向天线, 没其他站点, 相当于是AP与站点的点对点</p>
  </li>
</ul>

<p>第八章 网络安全</p>

<p>=================</p>

<ul>
  <li>
    <p>安全通信要求</p>
  </li>
  <li>
    <p>机密性：加密报文</p>
  </li>
  <li>
    <p>报文完整性：不会被篡改，或识别出篡改</p>
  </li>
  <li>
    <p>端点鉴别：确认两方身份</p>
  </li>
  <li>
    <p>运行安全性</p>
  </li>
  <li>
    <p>密钥</p>
  </li>
  <li>
    <p>对称密钥</p>
  </li>
  <li>
    <p>攻击方式</p>
  </li>
  <li>
    <p>唯密文攻击：入侵者只能截获密文</p>
  </li>
  <li>
    <p>已知明文攻击：入侵者知道明文和密文的匹配</p>
  </li>
  <li>
    <p>选择明文攻击：能够选择某一明文报文并得到改明文报文对应的密文形式</p>
  </li>
  <li>
    <p>单码代替密码：凯撒密码</p>
  </li>
  <li>
    <p>多码代替密码：不同位置出现的相同字母可能以不同的方式加密</p>
  </li>
  <li>
    <p>块密码</p>
  </li>
  <li>
    <p>要加密的报文被处理为k比特的块，kbit块明文被映射为k比特块的密文</p>
  </li>
  <li>
    <p>如：DES，3DES，AES</p>
  </li>
  <li>
    <p>流密码</p>
  </li>
  <li>
    <p>公开密钥加密</p>
  </li>
  <li>
    <p>RSA</p>
  </li>
  <li>
    <p>$n=pq,z=\phi(n)=(p-1)(q-1)$</p>
  </li>
  <li>
    <p>选择$e&lt;n,gcd(e,z)=1$,$ed\mod{z}=1$</p>
  </li>
  <li>
    <p>公钥$K_B^+(n,e)$，私钥$K_B^-(n,d)$</p>
  </li>
  <li>
    <p>$K_B^+(m)=m^e\mod{n},K_B^-(m)=m^d\mod{n}$.</p>
  </li>
  <li>
    <p>会话密钥</p>
  </li>
  <li>
    <p>用RSA传输用于加密大量传输信息的密钥</p>
  </li>
  <li>
    <p>报文完整性和数字签名</p>
  </li>
  <li>
    <p>密码散列函数：MD5、SHA-1等</p>
  </li>
  <li>
    <p>报文鉴别码：报文附加H(m+s),s仅二者已知</p>
  </li>
  <li>
    <p>数字签名：私钥签名</p>
  </li>
  <li>
    <p>公钥认证：CA</p>
  </li>
  <li>
    <p>端点鉴别</p>
  </li>
  <li>
    <p>ap4.0：</p>
  </li>
  <li>
    <p>A-&gt;B:  “我是A”</p>
  </li>
  <li>
    <p>B-&gt;A: 选一个不重数R，给A</p>
  </li>
  <li>
    <p>A-&gt;B: $K_{A-B}(R)$.</p>
  </li>
  <li>
    <p>B验证</p>
  </li>
  <li>
    <p>TCP：SSL</p>
  </li>
  <li>
    <p>握手</p>
  </li>
  <li>
    <p>客户发送它支持的密码算法的列表，连同一个客户的不重数</p>
  </li>
  <li>
    <p>从该列表中，服务器选择一种对称算法（例如AES）、一种公钥算法（例如具有 特定密钥长度的RSA）和一种MAC算法。它把它的选择以及证书和一个服务器不重数返 回给客户</p>
  </li>
  <li>
    <p>客户验证该证书，提取服务器的公钥，生成一个前主密钥（Pe Master Secret, PMS）,用服务器的公钥加密该PMS,并将加密的PMS发送给服务器。</p>
  </li>
  <li>
    <p>使用相同的密钥导岀函数（就像SSL标准定义的那样），客户和服务器独立地从 PMS和不重数中计算出主密钥（Master Secret, MS）O然后该MS被切片以生成两个密码和 两个MAC密钥。此外，当选择的对称密码应用于CBC （例如3DES或AES）,则两个初始 化向量（Initialization Vector, IV）也从该MS获得，这两个IV分别用于该连接的两端。自 此以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用MAC）</p>
  </li>
  <li>
    <p>客户发送所有握手报文的一个MAC</p>
  </li>
  <li>
    <p>服务器发送所有握手报文的一个MAC</p>
  </li>
</ul>

<p>第九章</p>

<p>=================</p>

<h2 id="流式存储视频">流式存储视频</h2>

<ul>
  <li>
    <p>UDP流、HTTP流、适应性HTTP流</p>
  </li>
  <li>
    <p>与客户缓存有关</p>
  </li>
</ul>

<p>提供多种类型的服务</p>

<hr />

<ul>
  <li>
    <p>监管: 漏桶</p>
  </li>
  <li>
    <p>监管准则</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  平均速率: 长时间速率存在最大值 - 漏桶的令牌产生速率

*  峰值速率: 短时间速率存在最大值 - (将桶容量定为1, 此时能够限制峰值速率)

*  突发长度: 极短时间(趋近0)发送的分组数量存在最大值 - 漏桶的高度
</code></pre></div></div>

<ul>
  <li>漏桶描述</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  分组首先进入令牌等待队列

*  在漏桶处取得令牌的分组将被发送

*  桶高度不超过b

*  每秒生成r个令牌加入桶
</code></pre></div></div>

<ul>
  <li>效果</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*  平均速率: r + b/t, 时间足够长, 该值为r

*  突发长度: b

*  峰值速率: 在已有的一个漏桶后, 串联一个高度为1的桶, 其速率r’可限制峰值速率
</code></pre></div></div>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="Courses" /><summary type="html"><![CDATA[计算机期末复习总结]]></summary></entry><entry><title type="html">概率论与数理统计</title><link href="http://localhost:4000/ppx123-web/2021/07/04/%E6%A6%82%E7%8E%87%E8%AE%BA/" rel="alternate" type="text/html" title="概率论与数理统计" /><published>2021-07-04T00:00:00+08:00</published><updated>2021-07-04T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2021/07/04/%E6%A6%82%E7%8E%87%E8%AE%BA</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2021/07/04/%E6%A6%82%E7%8E%87%E8%AE%BA/"><![CDATA[<blockquote>
  <p>概率论其期中与期末总结</p>
</blockquote>

<h1 class="no_toc" id="list">List</h1>
<ol id="markdown-toc">
  <li><a href="#概率论" id="markdown-toc-概率论">概率论</a>    <ol>
      <li><a href="#大数定律" id="markdown-toc-大数定律">大数定律</a></li>
      <li><a href="#中心极限定理" id="markdown-toc-中心极限定理">中心极限定理</a></li>
      <li><a href="#统计量与抽样分布" id="markdown-toc-统计量与抽样分布">统计量与抽样分布</a>        <ol>
          <li><a href="#统计量" id="markdown-toc-统计量">统计量</a></li>
          <li><a href="#正态分布的一些性质" id="markdown-toc-正态分布的一些性质">正态分布的一些性质</a></li>
          <li><a href="#正态总体" id="markdown-toc-正态总体">正态总体</a>            <ol>
              <li><a href="#chi2分布" id="markdown-toc-chi2分布">$\chi^2$分布</a></li>
              <li><a href="#t分布" id="markdown-toc-t分布">t分布</a></li>
              <li><a href="#f分布" id="markdown-toc-f分布">F分布</a></li>
            </ol>
          </li>
          <li><a href="#上分位点" id="markdown-toc-上分位点">上分位点</a></li>
          <li><a href="#正态总体的样本均值与样本方差的分布" id="markdown-toc-正态总体的样本均值与样本方差的分布">正态总体的样本均值与样本方差的分布</a></li>
        </ol>
      </li>
      <li><a href="#参数估计" id="markdown-toc-参数估计">参数估计</a>        <ol>
          <li><a href="#矩估计" id="markdown-toc-矩估计">矩估计</a>            <ol>
              <li><a href="#无论总体x服从何种分布总体均值exμ-总体方差dxσ2作为未知参数其矩估计量一定是样本均值和样本方差即" id="markdown-toc-无论总体x服从何种分布总体均值exμ-总体方差dxσ2作为未知参数其矩估计量一定是样本均值和样本方差即">无论总体X服从何种分布，总体均值$EX=μ$, 总体方差$DX=σ^2$作为未知参数，其矩估计量一定是样本均值和样本方差，即</a></li>
              <li><a href="#矩估计特殊情况" id="markdown-toc-矩估计特殊情况">矩估计特殊情况</a></li>
            </ol>
          </li>
          <li><a href="#极大似然估计" id="markdown-toc-极大似然估计">极大似然估计</a>            <ol>
              <li><a href="#极大似然估计的不变性" id="markdown-toc-极大似然估计的不变性">极大似然估计的不变性</a></li>
            </ol>
          </li>
          <li><a href="#估计量的评选标准" id="markdown-toc-估计量的评选标准">估计量的评选标准</a>            <ol>
              <li><a href="#无偏性" id="markdown-toc-无偏性">无偏性</a></li>
              <li><a href="#有效性" id="markdown-toc-有效性">有效性</a></li>
              <li><a href="#一致性" id="markdown-toc-一致性">一致性</a>                <ol>
                  <li><a href="#样本k阶矩是总体k阶矩的一致性估计量由大数定律证明" id="markdown-toc-样本k阶矩是总体k阶矩的一致性估计量由大数定律证明">样本k阶矩是总体k阶矩的一致性估计量（由大数定律证明）</a></li>
                  <li><a href="#设theta_n是theta的无偏估计量且lim_nrightarrow-inftydhattheta_n--0则hattheta是theta的一致估计量" id="markdown-toc-设theta_n是theta的无偏估计量且lim_nrightarrow-inftydhattheta_n--0则hattheta是theta的一致估计量">设$\theta_n$是$\theta$的无偏估计量，且$lim_{n\rightarrow \infty}D(\hat{\theta_n}) = 0$,则$\hat{\theta}$是$\theta$的一致估计量</a></li>
                </ol>
              </li>
            </ol>
          </li>
          <li><a href="#区间估计" id="markdown-toc-区间估计">区间估计</a>            <ol>
              <li><a href="#置信区间与置信度" id="markdown-toc-置信区间与置信度">置信区间与置信度</a></li>
              <li><a href="#正态总体求均值的μ区间估计" id="markdown-toc-正态总体求均值的μ区间估计">正态总体，求均值的μ区间估计</a>                <ol>
                  <li><a href="#已知方差估计均值" id="markdown-toc-已知方差估计均值">已知方差，估计均值</a></li>
                  <li><a href="#未知方差估计均值" id="markdown-toc-未知方差估计均值">未知方差，估计均值</a></li>
                  <li><a href="#正态总体求方差sigma2的区间估计" id="markdown-toc-正态总体求方差sigma2的区间估计">正态总体，求方差$\sigma^2$的区间估计</a></li>
                </ol>
              </li>
              <li><a href="#双正态总体情形" id="markdown-toc-双正态总体情形">双正态总体情形</a>                <ol>
                  <li><a href="#sigma_12sigma_22已知求mu_1mu_2的置信区间" id="markdown-toc-sigma_12sigma_22已知求mu_1mu_2的置信区间">$\sigma_1^2,\sigma_2^2$已知，求$\mu_1,\mu_2$的置信区间</a></li>
                  <li><a href="#方差比dfracsigma_12sigma_22的置信区间" id="markdown-toc-方差比dfracsigma_12sigma_22的置信区间">方差比$\dfrac{\sigma_1^2}{\sigma_2^2}$的置信区间</a></li>
                </ol>
              </li>
              <li><a href="#单侧置信区间" id="markdown-toc-单侧置信区间">单侧置信区间</a></li>
            </ol>
          </li>
          <li><a href="#非正态总体均值的区间估计大样本法" id="markdown-toc-非正态总体均值的区间估计大样本法">非正态总体均值的区间估计（大样本法）</a></li>
        </ol>
      </li>
      <li><a href="#假设检验" id="markdown-toc-假设检验">假设检验</a>        <ol>
          <li><a href="#u检验法" id="markdown-toc-u检验法">u检验法</a></li>
          <li><a href="#假设检验基本步骤" id="markdown-toc-假设检验基本步骤">假设检验基本步骤</a></li>
          <li><a href="#正态总体均值的假设检验" id="markdown-toc-正态总体均值的假设检验">正态总体均值的假设检验</a>            <ol>
              <li><a href="#单个正态总体均值的假设检验" id="markdown-toc-单个正态总体均值的假设检验">单个正态总体均值的假设检验</a>                <ol>
                  <li><a href="#sigma2已知u检验法" id="markdown-toc-sigma2已知u检验法">$\sigma^2$已知(u检验法)</a></li>
                  <li><a href="#单边检验" id="markdown-toc-单边检验">单边检验</a></li>
                  <li><a href="#sigma2未知t检验法" id="markdown-toc-sigma2未知t检验法">$\sigma^2$未知（t检验法）</a></li>
                  <li><a href="#双正态总体的情形" id="markdown-toc-双正态总体的情形">双正态总体的情形</a>                    <ol>
                      <li><a href="#sigma_1sigma_2已知" id="markdown-toc-sigma_1sigma_2已知">$\sigma_1,\sigma_2$已知</a></li>
                      <li><a href="#sigma_1sigma_2未知但相等sigma_1sigma_2sigma" id="markdown-toc-sigma_1sigma_2未知但相等sigma_1sigma_2sigma">$\sigma_1,\sigma_2$未知但相等，$\sigma_1=\sigma_2=\sigma$</a></li>
                    </ol>
                  </li>
                </ol>
              </li>
              <li><a href="#正态总体方差的假设检验" id="markdown-toc-正态总体方差的假设检验">正态总体方差的假设检验</a>                <ol>
                  <li><a href="#单正态总体" id="markdown-toc-单正态总体">单正态总体</a></li>
                  <li><a href="#双正态总体f检验法" id="markdown-toc-双正态总体f检验法">双正态总体（F检验法）</a></li>
                </ol>
              </li>
            </ol>
          </li>
          <li><a href="#非正态总体均值的检验" id="markdown-toc-非正态总体均值的检验">非正态总体均值的检验</a>            <ol>
              <li><a href="#一个总体均值的检验" id="markdown-toc-一个总体均值的检验">一个总体均值的检验</a></li>
              <li><a href="#两个正态总体的检验" id="markdown-toc-两个正态总体的检验">两个正态总体的检验</a></li>
            </ol>
          </li>
        </ol>
      </li>
      <li><a href="#拟合优度检验分布拟合优度检验不考" id="markdown-toc-拟合优度检验分布拟合优度检验不考">拟合优度检验（分布拟合优度检验）(不考)</a>        <ol>
          <li><a href="#皮尔逊统计量" id="markdown-toc-皮尔逊统计量">皮尔逊统计量</a></li>
          <li><a href="#一般的假设检验问题" id="markdown-toc-一般的假设检验问题">一般的假设检验问题</a></li>
        </ol>
      </li>
      <li><a href="#期中之前的内容" id="markdown-toc-期中之前的内容">期中之前的内容</a>        <ol>
          <li><a href="#基本概念" id="markdown-toc-基本概念">基本概念</a></li>
          <li><a href="#分布函数" id="markdown-toc-分布函数">分布函数</a>            <ol>
              <li><a href="#随机变量函数的分布" id="markdown-toc-随机变量函数的分布">随机变量函数的分布</a></li>
              <li><a href="#随机向量的函数的分布" id="markdown-toc-随机向量的函数的分布">随机向量的函数的分布</a></li>
            </ol>
          </li>
          <li><a href="#随机变量的数字特征期望方差" id="markdown-toc-随机变量的数字特征期望方差">随机变量的数字特征（期望，方差）</a>            <ol>
              <li><a href="#期望的性质" id="markdown-toc-期望的性质">期望的性质</a></li>
              <li><a href="#方差的性质" id="markdown-toc-方差的性质">方差的性质</a></li>
              <li><a href="#协方差" id="markdown-toc-协方差">协方差</a></li>
              <li><a href="#x和y不相关" id="markdown-toc-x和y不相关">X和Y不相关</a></li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h1 id="概率论">概率论</h1>

<h2 id="大数定律">大数定律</h2>

<p>对于随机变量序列${X_n}$,对任意的$\epsilon &gt; 0$,有</p>

\[\lim\limits_{n\rightarrow \infty}P(\|\dfrac{1}{n}\sum\limits_{k=1}^nX_k-\dfrac{1}{n}\sum\limits_{k=1}^nE(X_k)\|\geq \epsilon) = 0\]

<p>切比雪夫大数定律</p>

<p>定理：对于独立同分布的随机变量${X_n}$,$E(X_n)=\mu,D(X_n)=\sigma^2$,则${X_n}$服从大数定律。</p>

<h2 id="中心极限定理">中心极限定理</h2>

<p>$X_i$独立同分布</p>

\[\dfrac{\sum\limits_{i=1}^nX_i - n\mu}{\sqrt{n}\sigma} \sim N(0,1)\]

<h2 id="统计量与抽样分布">统计量与抽样分布</h2>

<h3 id="统计量">统计量</h3>

<p>统计量是随机变量，且不含任何未知参数</p>

<h3 id="正态分布的一些性质">正态分布的一些性质</h3>

<p>两个独立的正态分布，和也是正态分布。</p>

<p>正态分布的k阶原点矩</p>

\[X\sim N(0,1),E(X^k)=(k-1)!!,k是偶数;E(X^k) = 0,k是奇数\]

<h3 id="正态总体">正态总体</h3>

<h4 id="chi2分布">$\chi^2$分布</h4>

<p>$\chi_n^2 = \sum\limits_{i=1}^nX_i^2$，$X_i$独立同分布，$X_i\sim N(0,1)$</p>

<p>性质:</p>

<ol>
  <li>
    <p>$\chi^2_1\sim\chi^2(n_1),\chi^2_2\sim \chi^2(n_2)$且$\chi^2_1,\chi^2_2$相互独立，则有$\chi^2_1+\chi^2_2\sim \chi^2(n_1+n_2)$</p>
  </li>
  <li>
    <p>$\chi^2\sim \chi^2(n)\Rightarrow E(\chi^2) = n,D(\chi^2) = 2n$</p>
  </li>
</ol>

<h4 id="t分布">t分布</h4>

<p>$T = \dfrac{X}{\sqrt{Y/n}},X\sim N(0,1),Y\sim \chi^2(n)$,且X和Y相互独立。</p>

<p>关于y轴对称。</p>

<h4 id="f分布">F分布</h4>

<p>$F=\dfrac{U/n_1}{V/n_2},U\sim\chi^2(n_1),V\sim\chi^2(n_2)$且U和V相互独立。$F\sim F(n_1,n_2)$</p>

<p>性质：</p>

<ol>
  <li>
    <p>$F\sim F(n_1,n_2)\Rightarrow \dfrac{1}{F}\sim F(n_2,n_1)$</p>
  </li>
  <li>
    <p>$T\sim t(n)\Rightarrow T^2\sim F(1,n)$</p>
  </li>
</ol>

<h3 id="上分位点">上分位点</h3>

<p>$P(X &gt; \lambda_\alpha) = \alpha$,$\lambda_\alpha$为X的$\alpha$分位点。</p>

\[u_{1-\alpha} = -u_{\alpha}\]

\[t_{1-\alpha}(n) = -t_{\alpha}(n)\]

\[F_{1-\alpha}(n_1,n_2) = \dfrac{1}{F_{\alpha}(n_2,n_1)}\]

<h3 id="正态总体的样本均值与样本方差的分布">正态总体的样本均值与样本方差的分布</h3>

<p>设$X_1,X_2,…,X_n$是来自正态总体$N(\mu,\sigma^2)$的一个样本，则</p>

\[\bar{X}\sim N(\mu,\dfrac{\sigma^2}{n})\]

\[\dfrac{nS_n^2}{\sigma^2}\sim \chi^2(n-1)\quad or \quad \dfrac{(n-1)S_{n-1}^2}{\sigma^2}\sim \chi^2(n-1)\]

\[\bar{X}与S^2相互独立\]

\[设X_1,X_2,...,X_n是来自正态总体N(\mu,\sigma^2)的一个样本。则T=\dfrac{(\bar{X}-\mu)}{S_{n-1}/\sqrt{n}}\sim t(n-1)\]

\[X_1,..,X_{n_1}是来自正态总体N(\mu_1,\sigma_1^2)的一个样本,Y_1,..,Y_{n_2}是来自正态总体N(\mu_2,\sigma_2^2)的一个样本，且两样本相互独立，\]

\[记S_1^2=\dfrac{1}{n_1 - 1}\sum\limits_{i=1}^{n_1}(X_i-\bar{X})^2\]

\[记S_2^2=\dfrac{1}{n_2 - 2}\sum\limits_{i=1}^{n_2}(Y_i-\bar{Y})^2\]

\[F=\dfrac{S_1^2/\sigma^2_1}{S_2^2/\sigma^2_2}\sim F(n_1-1,n_2-2)\]

\[\bar{X}-\bar{Y} \sim N(\mu_1,\mu_2,(\dfrac{1}{n_1} +\dfrac{1}{n_2})\sigma^2)\]

<h2 id="参数估计">参数估计</h2>

<h3 id="矩估计">矩估计</h3>

<p>以样本矩作为总体矩的估计从而得到参数的估计量</p>

<p>有几个参数就求几阶原点矩，然后得到方程组求解。</p>

<p>估计值在参数上面加一个$\hat{\lambda}$</p>

<p>注意：方差和期望之间的转换方式，以及样本方差$S_{n-1}^2$和$S_n^2$的不同，这里用的是后者。</p>

<h4 id="无论总体x服从何种分布总体均值exμ-总体方差dxσ2作为未知参数其矩估计量一定是样本均值和样本方差即">无论总体X服从何种分布，总体均值$EX=μ$, 总体方差$DX=σ^2$作为未知参数，其矩估计量一定是样本均值和样本方差，即</h4>

\[\hat{\mu} = \overline{X},\hat{\sigma}^2 = \dfrac{1}{n}\sum\limits_{i=1}^n(X_i-\overline{X})^2 = S_n^2\]

<p>相关系数的矩估计：</p>

\[\rho_{XY} = \dfrac{cov(X,Y)}{\sqrt{D(X)D(Y)}} = \dfrac{E((X-E(X))(Y-E(Y)))}{\sqrt{(E((X-EX)^2)E((Y-E(Y))^2)}}\]

<p>然后用$\bar{X}$和$S_n^2$替换.</p>

<h4 id="矩估计特殊情况">矩估计特殊情况</h4>

<p>一阶不行时求二阶。</p>

<h3 id="极大似然估计">极大似然估计</h3>

<p>选择出现样本情况概率最高的参数取值。</p>

<p>求出最大似然函数，对每个参数求偏导可得。</p>

<p>连续性随机变量，将概率密度相乘即可。</p>

<p>离散型随机变量将分布律相乘。</p>

<h4 id="极大似然估计的不变性">极大似然估计的不变性</h4>

<p>设$\hat{\theta}$是$\theta$的极大似然估计，$u(u(\theta))$是$\theta$的函数，且有单值反函数：$\theta = \theta(u)$,则$\hat{u}=u(\hat{\theta})$是$u(\theta)$的极大似然估计。</p>

<p>$\hat{\theta}$是$\theta$的极大似然估计，则$u(\hat{\theta})$是$u(\theta)$的极大似然估计</p>

<p>如果极大似然方程组无解，可以直接考虑极大似然函数，使其最大，求得其最大时参数的取值（例如均匀分布的极大似然估计）</p>

<h3 id="估计量的评选标准">估计量的评选标准</h3>

<h4 id="无偏性">无偏性</h4>

<p>$E(\hat{\theta}) = \theta$</p>

<p>设总体X方差$\sigma^2$未知,$\sigma^2$的据估计量</p>

<p>$S_n^2 = \dfrac{1}{n}\sum\limits_{i=1}^n(X_i-\bar{x})^2$是有偏的</p>

<p>$E(S_n^2) = \dfrac{n-1}{n}\sigma^2 \neq \sigma^2$,所以$\hat{\sigma}^2 = S_n^2$是有偏的。所以修正样本方差$\dfrac{n}{n-1}S_n^2 = S_{n-1}^2$是无偏的。</p>

<h4 id="有效性">有效性</h4>

<p>$\hat{\theta_1},\hat{\theta_2}$是$\theta$的无偏估计量，方差小的较为有效。这里指无偏估计量的方差。若$D(\hat{\theta_1})\leq D(\hat{\theta_2})$,则称$\hat{\theta_1}$较$\hat{\theta_2}$有效(对于任意的n)。</p>

<h4 id="一致性">一致性</h4>

<p>$\hat{\theta_n} = \hat{\theta (x_1,…,x_n)},\lim\limits_{n\rightarrow \infty} \hat{\theta_n}\rightarrow \theta$</p>

<p>$\lim\limits_{n\rightarrow \infty}P(|\hat{\theta_n}-\theta| &lt; \epsilon) = 1$</p>

<h5 id="样本k阶矩是总体k阶矩的一致性估计量由大数定律证明">样本k阶矩是总体k阶矩的一致性估计量（由大数定律证明）</h5>

<p>$\dfrac{1}{n}\sum\limits_{i=1}^nX_i^k\rightarrow \dfrac{1}{n}\sum\limits_{i=1}^nE(X_i^k)=E(X^k)$</p>

<h5 id="设theta_n是theta的无偏估计量且lim_nrightarrow-inftydhattheta_n--0则hattheta是theta的一致估计量">设$\theta_n$是$\theta$的无偏估计量，且$lim_{n\rightarrow \infty}D(\hat{\theta_n}) = 0$,则$\hat{\theta}$是$\theta$的一致估计量</h5>

<p>矩法得到的估计量一般为一致估计量</p>

<h3 id="区间估计">区间估计</h3>

<p>区间估计：根据样本给出未知参数的一个范围，并保证真参数以指定的较大概率属于这个范围。$P(\hat{\theta_1} &lt; \theta &lt; \hat{\theta_2}) = 1 - \alpha$</p>

<p>基本方式是找一个分布（正态分布 or t or $\chi^2$分布 or t分布 or F分布），这个分布中仅包含需要做区间估计得参数</p>

<h4 id="置信区间与置信度">置信区间与置信度</h4>

<p>定义：设总体 含未知参数 $\theta$；对于样本$X_1,…,X_n$找出统计量:</p>

\[\hat{\theta_i} = \theta_i(X_1,..,X_n) ,(i = 1,2),\hat{\theta_1} &lt; \hat{\theta_2}\]

<p>使得$P(\hat{\theta_1} &lt; \theta &lt; \hat{\theta_2}) = 1 - \alpha$，$0 &lt; \alpha &lt; 1$</p>

<p>称区间$[\hat{\theta_1},\hat{\theta_2}]$为$\theta$的<code class="language-plaintext highlighter-rouge">置信区间</code>，$1-\alpha$为该区间的<code class="language-plaintext highlighter-rouge">置信度</code>。</p>

<h4 id="正态总体求均值的μ区间估计">正态总体，求均值的μ区间估计</h4>

<h5 id="已知方差估计均值">已知方差，估计均值</h5>

<p>已知方差$\sigma^2$,则$U = \dfrac{\bar{X}-\mu}{\sigma/\sqrt{n}}\sim N(0,1)$</p>

\[P(\lambda_1 \leq U \leq \lambda_2) = 1 - \alpha\]

\[代入U得:[\bar{X}-u_{\alpha/2}\dfrac{\sigma}{\sqrt{n}},\bar{X}+u_{\alpha/2}\dfrac{\sigma}{\sqrt{n}}]\]

<h5 id="未知方差估计均值">未知方差，估计均值</h5>

\[T = \dfrac{\bar{X}-\mu}{S_{n-1}/\sqrt{n}} \sim t(n-1)\]

\[P(\lambda_1\leq T \leq \lambda_2) = 1-\alpha\]

\[[\bar{X}-t_{\alpha/2}(n-1)\dfrac{S_n}{\sqrt{n-1}},\bar{X}+t_{\alpha/2}(n-1)\dfrac{S_n}{\sqrt{n-1}}]\]

<h5 id="正态总体求方差sigma2的区间估计">正态总体，求方差$\sigma^2$的区间估计</h5>

\[\chi = \dfrac{nS_n^2}{\sigma^2} \sim \chi^2(n-1)\]

<p>使概率对称 $P(\chi^2 &lt; \lambda_1) = P(\chi^2 &gt; \lambda_2) = \dfrac{\alpha}{2}$</p>

\[\chi^2_{1-\dfrac{\alpha}{2}} \leq \dfrac{nS_n^2}{\sigma^2} \leq \chi^2_{\dfrac{\alpha}{2}}(n)\]

\[[\dfrac{nS_n^2}{\chi^2_{\alpha/2}(n-1)},\dfrac{nS_n^2}{\chi^2_{1-\alpha/2}(n-1)}]\]

<h4 id="双正态总体情形">双正态总体情形</h4>

<p>使用的是修正的样本方差$S_{n-1}^2$</p>

<p>求$\mu_1-\mu_2,\dfrac{\sigma^2_1}{\sigma^2_2}$的区间估计。</p>

<h5 id="sigma_12sigma_22已知求mu_1mu_2的置信区间">$\sigma_1^2,\sigma_2^2$已知，求$\mu_1,\mu_2$的置信区间</h5>

\[\bar{X}\sim N(\mu_1,\dfrac{\sigma_1^2}{n_1}),\bar{Y}\sim N(\mu_2,\dfrac{\sigma_2^2}{n_2})\]

\[\bar{X}-\bar{Y} \sim N(\mu_1-\mu_2,\dfrac{\sigma_1^2}{n_1}+\dfrac{\sigma_2^2}{n_2})\]

<p>化为标准正态分布后查表</p>

\[\dfrac{(\bar{X}-\bar{Y})-(\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma_1^2}{n_1}+\dfrac{\sigma_2^2}{n_2}}}\sim N(0,1)\]

\[[(\bar{X}-\bar{Y})-u_{\alpha/2}\sqrt{\dfrac{\sigma_1^2}{n_1}+\dfrac{\sigma_2^2}{n_2}},(\bar{X}-\bar{Y})+u_{\alpha/2}\sqrt{\dfrac{\sigma_1^2}{n_1}+\dfrac{\sigma_2^2}{n_2}}]\]

<p>如果$\sigma_1.\sigma_2$位置，但是$\sigma_1=\sigma_2=\sigma,\sigma未知$，取$\sigma^2=\dfrac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}$</p>

<h5 id="方差比dfracsigma_12sigma_22的置信区间">方差比$\dfrac{\sigma_1^2}{\sigma_2^2}$的置信区间</h5>

\[F=\dfrac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2} \sim F(n_1-1,n_2-1)\]

<p>置信区间$(\dfrac{S_1^2}{S_2^2}\dfrac{1}{F_{\alpha/2}(n_1-1,n_2-1)},\dfrac{S_1^2}{S_2^2}\dfrac{1}{F_{1-\alpha/2}(n_1-1,n_2-1)})$</p>

<h4 id="单侧置信区间">单侧置信区间</h4>

<p>在单侧置信区间中，都是分位点都是$\alpha$</p>

<p>对$0 &lt; \alpha &lt; 1$,样本$X_1,..,X_n$,确定统计量$\hat{\theta}(X_1,…,X_n)$使$P(\theta &gt; \hat{\theta_1}) = 1 - \alpha$,则称$(\hat{\theta_1},+\infty)$是$\theta$的置信度$1 -\alpha$的单侧置信区间，$\hat{\theta}$称为单侧置信下限。</p>

<p>类似有$P(\theta &lt;\hat{\theta_2}) = 1 -\alpha$，位单侧置信上限。</p>

<p>例如$X\sim N(\mu,\sigma^2)$，求$\mu$的单侧置信下限，$T= \dfrac{\bar{X} - \mu}{S_{n-1}/\sqrt{n}} \sim t(n-1)$</p>

<p>分布：求上限从大于入手，求小于从小于入手</p>

<p>求单侧置信区间但未说明求上下限，根据具体问题判断，例如寿命问题求下限</p>

<h3 id="非正态总体均值的区间估计大样本法">非正态总体均值的区间估计（大样本法）</h3>

<p>设$X_1,X_2,…,X_n$为来自均值为$\mu$，方差为$\sigma^2$的总体的一组杨本，给定置信度$1-\alpha$，求均值$\mu$的区间估计（注：非正态分布）</p>

<p>当n充分大时，根据中心极限定理有</p>

\[\dfrac{\sum\limits_{i=1}^nX_i-n\mu}{\sqrt{n}\sigma}\rightarrow N(0,1)\]

\[\dfrac{\bar{X}-\mu}{\sigma/\sqrt{n}}\rightarrow N(0,1)\]

<p>若$\sigma$未知，可以用样本标准差$S_{n-1}$代替</p>

\[U=\dfrac{\bar{X}-\mu}{S_{n-1}/\sqrt{n}} \sim N(0,1),(近似)\]

<p>注意使用的标准差，要给方差开方</p>

<h2 id="假设检验">假设检验</h2>

<p>简单假设:$H_0:x=a,H_1:x\neq a$</p>

<p>复合假设:$x &lt; a$</p>

<h3 id="u检验法">u检验法</h3>

<p>一般根据拒绝的概率计算出拒绝域，检查样本是否在拒绝域之中。</p>

<p>第一步：统计假设</p>

<p>第二步：$H_0$成立时，考虑一个统计量U。（统计量及分布）</p>

<p>第三步：由$P(|U| &gt; u_{\alpha/2}) = \alpha$,得到拒绝域</p>

<p>第四步：根据样本得到U的观测值</p>

<p>第五步：得出结论</p>

<h3 id="假设检验基本步骤">假设检验基本步骤</h3>

<ol>
  <li>
    <p>根据问题提出原假设$H_0$和对立假设$H_1$</p>
  </li>
  <li>
    <p>构造一个合适的统计量（往往由参数估计而来），并在$H_n$成立的条件下推导出该统计量的分布</p>
  </li>
  <li>
    <p>给出小概率$\alpha$，确定临界值和拒绝域W</p>
  </li>
  <li>
    <p>由样本算出统计量的观察值</p>
  </li>
  <li>
    <p>若观察值落在拒绝域W，则拒绝$H_0$,若在接受域，接受$H_0$</p>
  </li>
</ol>

<h3 id="正态总体均值的假设检验">正态总体均值的假设检验</h3>

<h4 id="单个正态总体均值的假设检验">单个正态总体均值的假设检验</h4>

<h5 id="sigma2已知u检验法">$\sigma^2$已知(u检验法)</h5>

\[U = \dfrac{\bar{X}-\mu_0}{\sigma/\sqrt{n}} \sim N(0,1)\]

<p>拒绝域为$W={|U|\geq u_{\alpha/2}}$</p>

<h5 id="单边检验">单边检验</h5>

<p>$H_0:\mu = \mu_0,H_1:\mu &gt; \mu_0$</p>

<p>拒绝域$W = {\dfrac{\bar{X}-\mu_0}{\sigma/\sqrt{n}}\geq u_{\alpha}}$</p>

<p>$H_0:\mu = \mu_0,H_1:\mu &lt; \mu_0$</p>

<p>拒绝域$W = {\dfrac{\bar{X}-\mu_0}{\sigma/\sqrt{n}}\leq -u_{\alpha}}$</p>

<h5 id="sigma2未知t检验法">$\sigma^2$未知（t检验法）</h5>

\[T = \dfrac{\bar{X}-\mu_0}{S/\sqrt{n}} \sim t(n-1)\]

<p>拒绝域$W={|T|\geq t_{\alpha/2}(n-1)}$</p>

<p>对于单边检验，判断大于号还是小于号后，使用的$t_{\alpha}(n-1)$</p>

<h5 id="双正态总体的情形">双正态总体的情形</h5>

<h6 id="sigma_1sigma_2已知">$\sigma_1,\sigma_2$已知</h6>

<p>$U=\dfrac{(\bar{X}-\bar{Y}) - (\mu_1-\mu_2)}{\sqrt{\dfrac{\sigma_1^2}{n_1}+\dfrac{\sigma_2^2}{n_2}}}\sim N(0,1)$</p>

<p>拒绝域(双边)$W={|U|\geq u_{\alpha/2}}$</p>

<p>单边($H_1:\mu_1 &lt; \mu_2$时)$W={U\leq -u_{\alpha}}$</p>

<p>单边($H_1:\mu_1 &gt; \mu_2$时)$W={U\geq u_{\alpha}}$</p>

<h6 id="sigma_1sigma_2未知但相等sigma_1sigma_2sigma">$\sigma_1,\sigma_2$未知但相等，$\sigma_1=\sigma_2=\sigma$</h6>

<p>$S_w = \sqrt{\dfrac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}$代替$\sigma$</p>

<p>$T=\dfrac{(\bar{X}-\bar{Y})-(\mu_1-\mu_2)}{S_w\sqrt{\dfrac{1}{n_1}+\dfrac{1}{n_2}}}\sim t(n_1+n_2-2)$</p>

<h4 id="正态总体方差的假设检验">正态总体方差的假设检验</h4>

<h5 id="单正态总体">单正态总体</h5>

<p>$H_0:\sigma^2 = \sigma_0^2,H_1:\sigma\neq\sigma_0^2$</p>

<p>$\chi^2=\dfrac{(n-1)S^2}{\sigma_0^2}\sim \chi^2(n-1)$</p>

<p>$W={\chi^2\leq\chi^2_{1-\alpha/2}(n-1)}\cup {\chi^2\geq \chi^2_{\alpha/2}(n-1)}$</p>

<h5 id="双正态总体f检验法">双正态总体（F检验法）</h5>

<p>$H_0:\sigma_1^2 = \sigma_2^2,H_1:\sigma_1^2 \neq \sigma_2^2$</p>

<p>$F=\dfrac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2} \sim F(n_1-1,n_2-1)$</p>

<p>在假设$H_0$成立的条件下，$F=\dfrac{S_1^2}{S_2^2}\sim F(n_1-1,n_2-1)$</p>

<p>拒绝域$W={F\leq F_{1-\alpha/2}(n_1-1,n_2-1)}\cup {F\geq F_{\alpha/2}(n_1-1,n_2-1)}$</p>

<h3 id="非正态总体均值的检验">非正态总体均值的检验</h3>

<h4 id="一个总体均值的检验">一个总体均值的检验</h4>

<p>假设X为任意总体，$EX=\mu,DX=\sigma^2$,$X_1,…,X_n$是一组样本，$\bar{X}是样本均值,S^2是修正的样本方差，\mu_0是已知参数，记U=\dfrac{\bar{X}-\mu_0}{\sigma/\sqrt{n}}或U=\dfrac{\bar{X}-\mu_0}{S/\sqrt{n}}$，当n充分大时，统计量U近似服从标准正态分布。</p>

<h4 id="两个正态总体的检验">两个正态总体的检验</h4>

<p>$X_1,…,X_m,S^2_1,Y_1,Y_2,…,Y_n,S^2_2$,修正样本方差</p>

\[U=\dfrac{\bar{X}-\bar{Y}}{\sqrt{\dfrac{\sigma_1^2}{m}+\dfrac{\sigma_2^2}{n}}}或U=\dfrac{\bar{X}-\bar{Y}}{\sqrt{\dfrac{S_1^2}{m}+\dfrac{S_2^2}{n}}}\]

<h2 id="拟合优度检验分布拟合优度检验不考">拟合优度检验（分布拟合优度检验）(不考)</h2>

<p>不知道总体的分布类型</p>

<p>$H_0:F(x)=F_0(x,\theta)$，$F_0$为某个已知的分布函数，$\theta = (\theta_1,…,\theta_r)$为未知参数</p>

<p>利用事件的频率与概率之间的偏差构造检验统计量</p>

<h3 id="皮尔逊统计量">皮尔逊统计量</h3>

\[H_0:O(X=x_i),i=1,2,...,k\]

<p>(1)计算$X_1,…,X_n$中取$x_i$的实际频数$n_i = {X_1,…,X_n中取x_i的个数}$</p>

<p>(2)计算实际频数与理论频数的偏差平方和$\chi^2=\sum\limits_{i=1}^k\dfrac{(n_i-np_i)^2}{np_i}\sim \chi^2(k-1)$</p>

<p>(3)拒绝域为$W={\chi^2\geq \chi^2_\alpha(k-1)}$</p>

<h3 id="一般的假设检验问题">一般的假设检验问题</h3>

<ol>
  <li>
    <p>将样本空间分为k个互不相交的事件$A_i,A_2,…,A_k$</p>
  </li>
  <li>
    <p>计算每个事件$A_i$上的理论频数，若参数$\theta$未知，先算出$\theta$的极大似然估计$\hat{\theta}$，计算理论上样本落在事件$A_i$中的概率$\hat{p_i}=P(X\in A_i|\theta = \hat{\theta}),i=1,2…,k$，最后得到每个事件的理论频数$n\hat{p_i}$</p>
  </li>
  <li>
    <p>计算$X_1,…,X_n$中取$x_i$的实际频数$n_i = {X_1,…,X_n中取x_i的个数}$</p>
  </li>
  <li>
    <p>计算实际频数与理论频数的偏差平方和$\chi^2=\sum\limits_{i=1}^k\dfrac{(n_i-n\hat{p_i})^2}{n\hat{p_i}}\sim \chi^2(k-1)$</p>
  </li>
  <li>
    <p>拒绝域为$W={\chi^2\geq \chi^2_\alpha(k-1)}$</p>
  </li>
</ol>

<p>注意：通常要求$n\geq 50$,将样本空间划分为事件，要求每个事件的理论频数不应太小</p>

<h2 id="期中之前的内容">期中之前的内容</h2>

<h3 id="基本概念">基本概念</h3>

<p>条件概率:$P(B|A) = \dfrac{P(AB)}{P(A)} \Leftrightarrow   P(AB) = P(A)P(B|A) = P(B)P(A|B)$</p>

<p>全概率公式与贝叶斯公式：</p>

<p>全概率公式：$A_i$是$\Omega$的一个划分，$P(B) = \sum\limits_{i=1}^nP(A_i)P(B|A_i)$</p>

<p>贝叶斯公式：$A_i$是$\Omega$的一个划分，$P(A_j|B) = \dfrac{P(A_j)P(B|A_j)}{\sum\limits_{i=1}^nP(A_i)P(B|A_i)}$</p>

<h3 id="分布函数">分布函数</h3>

<p>二项分布的峰值：当$(n+1)p$是整数时。$k_0=(n+1)p-1$或$(n+1)p$，当$(n+1)p$不是整数时，$k_0=[(n+1)p]$</p>

<p>若随机变量$X\thicksim B(n,p)$，则当n充分大，p充分小时，令$\lambda = np$，则有$P{X=k}=C_n^kp^k(1-p)^{n-k}\approx \dfrac{\lambda^k}{k!}e^{-\lambda}$</p>

<p>离散型：几何分布:$X\thicksim g(p)$</p>

<p>连续型：均匀分布$X\sim U[a,b]$，$E(x) = \dfrac{a+b}{2},D(x) = \dfrac{(b-a)^2}{12}$</p>

<p>二项分布$X\thicksim B(n,p)$,$E(x) = np,D(x) = npq$</p>

<p>超几何分布$X\thicksim H(n,N,M)$</p>

<p>泊松分布:$p{X=k} = \dfrac{\lambda^k}{k!}e^{-\lambda},k=0,1,2,…,\lambda &gt; 0$，记作$X\thicksim P(\lambda)$,$E(x) = \lambda,D(x) = \lambda$</p>

<p>指数分布（无记忆性）$X\thicksim E(\lambda)</p>

<p>$$</p>

<p>E(x) = \dfrac{1}{\lambda},D(x) = \dfrac{1}{\lambda^2}$</p>

<p>正态分布$p(x)=\dfrac{1}{\sqrt{2\pi}\sigma}e^{-\dfrac{(x-\mu)^2}{2\sigma^2}}$,$X\thicksim N(\mu,\sigma^2)$.</p>

<p>若$X\thicksim N(\mu,\sigma^2),Y=\dfrac{X-\mu}{\sigma}\thicksim N(0,1)$，以及$3\sigma$原理</p>

<p>$X\thicksim N(\mu,\sigma),Y=aX+b,Y\thicksim N(a\mu+b,a^2\mu^2)$</p>

<p>$F(x) = P(X\leq x) (-\infty &lt; x &lt; +\infty)$称为随机变量X的随机变量。</p>

<h4 id="随机变量函数的分布">随机变量函数的分布</h4>

<p>对于连续型随机变量，其密度函数为$p(x),y = g(x)$是x的连续函数，$Y = g(x)$是连续性随机变量。$求Y=g(X)$的密度函数$p_Y(y)$</p>

<ol>
  <li>
    <p>分布函数法：先求$Y=g(X)$的分布函数，再求导。</p>
  </li>
  <li>
    <p>公式法。</p>
  </li>
</ol>

<h4 id="随机向量的函数的分布">随机向量的函数的分布</h4>

<p>同样求出对应的分布函数，然后求导，如$Z = max{X,Y},F(Z&lt;z) = P(X &lt; z,y &lt; Z)$，然后积分</p>

<h3 id="随机变量的数字特征期望方差">随机变量的数字特征（期望，方差）</h3>

<h4 id="期望的性质">期望的性质</h4>

<p>期望的线性性质：不要求独立，$E(aX+bY)=aE(X)+bE(y)$</p>

<p>若X，Y相互独立，$E(XY)=E(X)E(Y)$</p>

<h4 id="方差的性质">方差的性质</h4>

<p>$D(aX+b)=a^2D(X)$</p>

<p>$D(X+Y)=D(x)+D(Y)+E((X-E(X))(Y-E(Y)))$ ，X和Y独立时$D(X+Y)=D(X)+D(Y)$</p>

<p>切比雪夫不等式$P(|X-EX|\geq \epsilon)\leq \dfrac{D(X)}{\epsilon^2}$</p>

<p>注意样本方差和总体方差的区别</p>

<h4 id="协方差">协方差</h4>

<p>$cov(X,Y)=E(XY)-E(X)E(Y)$</p>

<p>相关系数：$\rho=\dfrac{cov(X,Y)}{\sqrt{D(X)D(Y)}}$,$|\rho|=1\Leftrightarrow P(cX+aY=b)=1$,X和Y以概率1成线性关系。</p>

<h4 id="x和y不相关">X和Y不相关</h4>

<p>$\Leftrightarrow \rho_{XY} = 0\Leftrightarrow cov(X,Y)=0\Leftrightarrow E(XY)=E(X)E(Y)\Leftrightarrow D(X+Y)=D(X)+D(Y)$.</p>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="Courses" /><summary type="html"><![CDATA[计概率论总结]]></summary></entry></feed>