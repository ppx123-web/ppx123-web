<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/ppx123-web/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/ppx123-web/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-01-15T18:17:25+08:00</updated><id>http://localhost:4000/ppx123-web/feed.xml</id><title type="html">Zhao Chaoyi</title><subtitle>Notes
</subtitle><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><entry><title type="html">Archlinux install</title><link href="http://localhost:4000/ppx123-web/2022/01/15/Archlinux-install/" rel="alternate" type="text/html" title="Archlinux install" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/Archlinux-install</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/Archlinux-install/"><![CDATA[<blockquote>
  <p>Archlinux安装过程中的一些问题，后续配置需要注意的一些事项，以及linux中遇到的一些问题</p>
</blockquote>

<ul id="markdown-toc">
  <li><a href="#archlinux的安装" id="markdown-toc-archlinux的安装">Archlinux的安装</a>    <ul>
      <li><a href="#遇到的问题" id="markdown-toc-遇到的问题">遇到的问题</a>        <ul>
          <li><a href="#显卡驱动" id="markdown-toc-显卡驱动">显卡驱动</a></li>
          <li><a href="#独显下屏幕亮度调节" id="markdown-toc-独显下屏幕亮度调节">独显下屏幕亮度调节</a></li>
          <li><a href="#boot空间不足100m" id="markdown-toc-boot空间不足100m">boot空间不足（100M）</a></li>
          <li><a href="#选择kde" id="markdown-toc-选择kde">选择kde</a></li>
          <li><a href="#v2ray代理" id="markdown-toc-v2ray代理">v2ray代理</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="archlinux的安装">Archlinux的安装</h1>

<p>可以看这一篇：https://zhuanlan.zhihu.com/p/138951848  （注意：建议wiki，安装细节有可能随着更新改变）</p>

<ol>
  <li>
    <p>制作好镜像</p>
  </li>
  <li>
    <p>启动后，联网，更新，安装vim</p>
  </li>
  <li>
    <p>cfdisk分盘</p>
  </li>
  <li>
    <p>mount挂载，在有windows的情况下，分的硬盘挂到/mnt上，把efi挂载到/mnt/boot上，然后按照wiki开始安装</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacstrap /mnt base linux linux-firmware nano
</code></pre></div>    </div>
  </li>
  <li>
    <p>生成fstab文件</p>

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>genfstab <span class="nt">-U</span> /mnt <span class="o">&gt;&gt;</span> /mnt/etc/fstab
</code></pre></div>    </div>
  </li>
  <li>
    <p>配置系统</p>

    <ol>
      <li>
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arch-root /mnt
</code></pre></div>        </div>
      </li>
      <li>
        <p>建议swap文件，用于休眠</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">dd </span><span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/swapfile <span class="nv">bs</span><span class="o">=</span>2048 <span class="nv">count</span><span class="o">=</span>1048576 <span class="nv">status</span><span class="o">=</span>progress
<span class="nb">chmod </span>600 /swapfile
mkswap /swapfile
swapon /swapfile
vim /etc/fstab 在文件末尾输入 /swapfile none swap defaults 0 0
</code></pre></div>        </div>
      </li>
      <li>
        <p>设置时区</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timedatectl set-timezone Asia/Shanghai
hwclock
</code></pre></div>        </div>
      </li>
      <li>
        <p>取消/etc/locale.gen文件中的en_US UTF-8和zh_CN UTF-8的注释</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>locale-gen
</code></pre></div>        </div>

        <p>创建/etc/locale.cong, 输入LANG=en_US.UTF-8</p>

        <p>创建/etc/hostname   $name</p>
      </li>
      <li>
        <p>修改/etc/hosts</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>127.0.0.1	localhost
::1			localhost
127.0.1.1	<span class="nv">$name</span>.localdomain		<span class="nv">$name</span>
</code></pre></div>        </div>
      </li>
      <li>
        <p>root用户密码passwd</p>
      </li>
      <li>
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> grub efibootmgr networkmanager network-manager-applet dialog wireless_tools wpa_supplicant os-prober mtools dosfstools ntfs-3g base-devel linux-headers reflector git <span class="nb">sudo</span>
</code></pre></div>        </div>

        <p>使用grub作为启动器</p>

        <p>安装intel-ucode或amd-ucode</p>
      </li>
      <li>
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim /etc/default/grub
加一行 <span class="nv">GRUB_DISABLE_OS_PROBER</span><span class="o">=</span><span class="nb">false
</span>grub-install <span class="nt">--target</span><span class="o">=</span>x86_64-efi <span class="nt">--efi-directory</span><span class="o">=</span>/boot <span class="nt">--bootloader-id</span><span class="o">=</span>Arch
grub-mkconfig <span class="nt">-o</span> /boot/grub/grub.cfg
</code></pre></div>        </div>
      </li>
      <li>
        <p>退出，取消挂载，重启,使用root账户登录</p>
      </li>
      <li>
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemctl <span class="nb">enable</span> <span class="nt">--now</span> NetworkManager
nmtui联网
</code></pre></div>        </div>
      </li>
      <li>
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>useradd <span class="nt">-m</span> <span class="nt">-G</span> wheel <span class="nv">$user</span>
passwd <span class="nv">$user</span>
</code></pre></div>        </div>

        <p>创建用户</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">EDITOR</span><span class="o">=</span>vim visudo
取消wheel <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span> ALL的注释
</code></pre></div>        </div>
      </li>
      <li>
        <p>安装显卡驱动</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> nvidia nvidia-util
pacman <span class="nt">-S</span> xf86-video-amdgpu
</code></pre></div>        </div>
      </li>
      <li>
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> xorg
</code></pre></div>        </div>
      </li>
      <li>
        <p>桌面环境及后续</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> sddm
pacman <span class="nt">-S</span> plasma packagekit-qt5 kate git kconsole
</code></pre></div>        </div>
      </li>
      <li>
        <p>添加archlinuxcn源</p>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>archlinuxcn]
Server <span class="o">=</span> https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/<span class="nv">$arch</span>
并取消multilib的注释
</code></pre></div>        </div>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-Syu</span> <span class="o">&amp;&amp;</span> pacman <span class="nt">-S</span> archlinuxcn-keyring
</code></pre></div>        </div>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pacman <span class="nt">-S</span> ttf-sarasa-gothic noto-fonts-cjk
</code></pre></div>        </div>

        <p>重启</p>
      </li>
    </ol>
  </li>
</ol>

<h2 id="遇到的问题">遇到的问题</h2>

<h3 id="显卡驱动">显卡驱动</h3>

<p>如果安装时使用核显，则后续怎么都转不了独显的驱动</p>

<p>所以建议直接从头到尾使用独显，驱动问题轻松解决</p>

<h3 id="独显下屏幕亮度调节">独显下屏幕亮度调节</h3>

<p>wiki Nvidia中</p>

<p>创建/etc/X11/xorg.conf.d/20-nvidia.conf</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Section "Device"
        Identifier      "Device0"
        Driver          "nvidia"
        VendorName      "NVIDIA Corporation"
        Option "RegistryDwords" "EnableBrightnessControl=1"
EndSection
</code></pre></div></div>

<p>然后更新grub</p>

<h3 id="boot空间不足100m">boot空间不足（100M）</h3>

<p>https://wusiyu.me/archlinux-remove-initramfs-linux-fallback-img/</p>

<p>删除fallback.img</p>

<p>然后在/etc/mkinitcpio.d/linux.preset中去掉fall back的部分</p>

<h3 id="选择kde">选择kde</h3>

<p>新的gnome十分难用，不建议使用</p>

<h3 id="v2ray代理">v2ray代理</h3>

<p>开启系统代理，命令行用proxychains</p>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="ArchLinux" /><summary type="html"><![CDATA[Install Archlinux]]></summary></entry><entry><title type="html">高级算法作业</title><link href="http://localhost:4000/ppx123-web/2022/01/15/advanced-alogrithm-A3/" rel="alternate" type="text/html" title="高级算法作业" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/advanced-alogrithm-A3</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/advanced-alogrithm-A3/"><![CDATA[<h1 id="高级算法第三次作业">高级算法第三次作业</h1>

<p>匡亚明学院 赵超懿 191870271</p>

<h2 id="第一题">第一题</h2>

<h3 id="1">(1)</h3>

<p>显然当$a\in A\wedge a\in B\Rightarrow$，这样的位置$F_C$和$A\cap B$的bloom filters是一样的。</p>

<p>当$a\in A\wedge a\notin B$时，只要$\exists b\in B\wedge b\notin A,\exists i,j,1\leq i,j\leq k,s.t.\quad h_j(b)=h_i(a)$，且对于$A\cap B$中的元素没有哈希到$h_j(b)$这个位置，则$A\cap B$的bloom filters至少有一位和$F_A\wedge F_B$不同</p>

<h3 id="2">(2)</h3>

<p>记$a_i,b_i$分别是A和B的bloom filters产生的m个bit的第i位,a,b为A,B中元素</p>

<p>$相同的bit数 = \sum\limits_{i=1}^m I(a_i=b_i) \Rightarrow E[same]=\sum\limits_{i=1}^mPr[a_i=b_i]
$</p>

<p>$E[differ] = n - E[same]$</p>

<p>$Pr[a_i=b_i] = Pr[\exists p,q,h_p(a)=i\wedge h_q(b) = i] + Pr[\forall p,q,h_p(a)\neq i \wedge h_q(b)\neq i]$</p>

<p>$Pr[\exists p,q,h_p(a)=i\wedge h_q(b) = i]<br />
= Pr[\exists p,q,h_p(a)=i\wedge h_q(b)=i|a=b]Pr[a=b] + Pr[\exists p,q,h_p(a)\wedge h_q(b)=i|a\neq b]Pr[a\neq b]<br />
=(1-(1-\dfrac{1}{m})^k)\dfrac{|A\cap B|}{n^2} + (1-(1-\dfrac{1}{m})^k-(1-\dfrac{1}{m})^k+(1-\dfrac{1}{m})^{2k})(1-\dfrac{|A\cap B|}{n^2})$</p>

<p>$Pr[\forall p,q,h_p(a)\neq i \wedge h_q(b)\neq i]<br />
=Pr[\forall p,q,h_p(a)\neq i \wedge h_q(b)\neq i | a\neq b]Pr[a\neq b]+Pr[\forall p,q,h_p(a)\neq i \wedge h_q(b)\neq i|a\neq b]Pr[a\neq b]<br />
=(1-\dfrac{1}{m})^k\dfrac{|A\cap B|}{n^2}+(1-\dfrac{1}{m})^{2k}(1-\dfrac{|A\cap B|}{n^2})$</p>

<p>$Pr[a_i=b_i] = 2((1-\dfrac{1}{m})^k-(1-\dfrac{1}{m})^{2k})\dfrac{\|A\cap B\|}{n^2}+1-2(1-\dfrac{1}{m})^k+2(1-\dfrac{1}{m})^{2k}$</p>

<p>$E[differ] = n - n(2((1-\dfrac{1}{m})^k-(1-\dfrac{1}{m})^{2k})\dfrac{\|A\cap B\|}{n^2}+1-2(1-\dfrac{1}{m})^k+2(1-\dfrac{1}{m})^{2k})$</p>

<h2 id="第二题">第二题</h2>

<p>对于$\dfrac{n}{2}$个球,uniformly at random的期望为$\Theta(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}})$,two choice $\dfrac{n}{2}$的期望为$\Theta(\log\log \dfrac{n}{2})$，当某一半是uniformly at random的时候，期望则为uniformly at random的期望，因为 $\log\log\dfrac{n}{2} = o(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}}))$</p>

<h3 id="1-1">(1)</h3>

<p>前一半随机选择仍为$\Theta(\dfrac{\log n/2}{\log\log\dfrac{n}{2}})=\Theta(\dfrac{\log }{\log\log n})$</p>

<h3 id="2-1">(2)</h3>

<p>$\Theta(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}}) + \Theta(\log\log \dfrac{n}{2}) = \Theta(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}}) = \Theta(\dfrac{\log }{\log\log n})$</p>

<h3 id="3">(3)</h3>

<p>将一个随机选取和two choice视为一个操作，共有$\dfrac{n}{2}$个操作，记第i个盒子的球的个数为$X_i$</p>

<p>$Pr[\max\limits_{1\leq i\leq n} X_i \geq L] \leq nPr[X_1\geq L]$</p>

<p>$Pr[X_i \geq L] \leq \sum\limits_{i=0}^{L}\tbinom{m/2}{i}\dfrac{1}{n^i}\tbinom{m/2}{L-i}(1-(1-\dfrac{1}{n})(1-\dfrac{1}{n}))^{L-i})\(至少i个uniform的操作选择第一个bin，至少L-i个two choice中有一个选择了第一个bins)<br />
\leq \sum\limits_{i=0}^{L}\tbinom{m/2}{i}\tbinom{m/2}{L-i}\dfrac{1}{n^i}(\dfrac{2}{n})^{L-i}<br />
= 2\tbinom{m}{L}\dfrac{1}{n^L} (范德蒙德卷积,此时情形和上课讲的一样，略去细节)<br />
\leq 2\dfrac{m^L}{L!n^L}<br />
\leq 2\dfrac{e^Lm^L}{L^Ln^L}$</p>

<p>当$m=\Theta(n)$时有$存在c，L=\dfrac{c\log n}{\log\log n}$</p>

<p>$Pr[X_i\geq L] \leq (\dfrac{e}{L})^L\leq \dfrac{1}{n^2}$</p>

<p>所以最大值大于L的概率为$Pr[\max X_i \geq L] \leq \dfrac{1}{n},L=\dfrac{c\log n}{\log\log n}$
下界显然是随机选取$\dfrac{n}{2}$的下界$\Theta(\dfrac{\log \dfrac{n}{2}}{\log\log\dfrac{n}{2}}) = \Theta(\dfrac{\log n}{\log\log n})$，所以结果仍为$L=\Theta(\dfrac{\log n}{\log\log n})$</p>

<h2 id="第三题">第三题</h2>

<p>设$Y_i=I[(1-\epsilon)Z\leq \hat{Z_i}\leq (1+\epsilon)Z]$,$E[Y_i]\geq \dfrac{3}{4}$</p>

<p>$Y=\sum\limits_{i=1}^sY_i,\mu = E[Y]\geq \dfrac{3}{4}s$</p>

<p>当$Y\geq \dfrac{1}{2}s$时，${\hat{Z_i}}$的中位数X一定满足$(1-\epsilon)Z\leq X\leq (1+\epsilon)Z$</p>

<p>所以只要$Pr[(1-\epsilon)Z\leq X\leq (1+\epsilon)Z]\geq Pr[Y\geq \dfrac{1}{2}s]\geq 1-\delta$,即$\delta\geq Pr[Y\leq \dfrac{1}{2}s]$</p>

<p>只要$Pr[Y\leq \dfrac{1}{2}s]\leq Pr[\sum\limits_{i=1}^sT_i\leq (1-\dfrac{1}{3})\mu]\leq e^{-\dfrac{\mu/9}{2}}(chernoff bound)\leq e^{-\dfrac{s}{24}}$</p>

<p>即$e^{-\dfrac{s}{24}\leq \delta}\Rightarrow S\geq 24\ln \dfrac{1}{\delta},S=\Omega(\log \dfrac{1}{\delta})$</p>

<h2 id="第四题">第四题</h2>

<h3 id="1-2">(1)</h3>

<p>$Pr[\|X\|\geq \delta]\leq \dfrac{\sum\limits_{k=1}^{+\infty}\dfrac{t^k}{k!}E[\|X\|^k]}{\sum\limits_{k=1}^{+\infty}\dfrac{t^k}{k!}\delta^k}$</p>

<p>记$a_k = \dfrac{t^k}{k!}E[\|X\|^k],b_k = \dfrac{t^k}{k!}\delta^k$</p>

<p>$m=\mathop{argmin}\limits_{k}\dfrac{a_k}{b_k},c = \dfrac{a_k}{b_k}$</p>

<p>$\forall i\in N,\dfrac{a_i}{b_i}\geq c\Rightarrow a_i\geq cb_i$</p>

<p>得到$\dfrac{\sum\limits_{k=1}^{+\infty}\dfrac{t^k}{k!}E[<br />
|X\|^k]}{\sum\limits_{k=1}^{+\infty}\dfrac{t^k}{k!}\delta^k} \geq \dfrac{\sum\limits_{i=1}^{+\infty}cb_i}{\sum\limits_{i=1}^{+\infty}b_i}= c = \dfrac{a_m}{b_m}=\dfrac{E[\|X\|^k]}{\delta^k}$</p>

<p>所以一定存在k阶矩强于chernoff bound</p>

<h3 id="2-2">(2)</h3>

<p>矩阵生成函数容易计算，而特定的k阶矩难以找到</p>

<h2 id="第五题">第五题</h2>

<h3 id="1-3">(1)</h3>

<p>记$h_k=\prod\limits_{i=1}^{k}f_i(X_i)$，显然$h_k$不减</p>

<p>$E[h_n]=E[h_{n-1}\cdot f_n(X_n)]\leq E[h_{n-1}]E[f_n(X_n)]]\leq ……\leq \prod\limits_{i=1}^{k}E[f_i(x_i)]$</p>

<h3 id="2-3">(2)</h3>

<p>$X=\sum\limits_{i=1}^nX_i,E[x]=\mu$</p>

<p>$Pr[X\geq (1+\delta)\mu]\leq Pr[e^{\lambda X}\geq e^{(1+\delta)\mu\lambda}]\leq \dfrac{E[e^{\lambda X}]}{e^{\lambda(1+\delta)\mu}}\leq \dfrac{\prod\limits_{i=1}^nE[e^{\lambda X_i}]}{e^{\lambda(1+\delta)\mu}}$,其余和独立的情形一致，$Pr[X\geq (1+\delta)\mu]\leq \dfrac{e^{(e^{(\lambda-1)\mu})}}{e^{\lambda(1+\delta)\mu}}$</p>

<p>$Pr[X\leq (1-\delta)\mu]\leq Pr[e^{\lambda X}\geq e^{(1-\delta)\mu\lambda}]\leq \dfrac{E[e^{\lambda X}]}{e^{\lambda(1-\delta)\mu}},(\lambda &lt; 0)$,应用后面提到的性质，$X_i$是负相关的$f=e^{\lambda X_i},\lambda &lt; 0$单调递减，满足性质Disjoint monotone aggregation，有$E[e^{\lambda X}]\leq \prod\limits_{i=1}^nE[e^{\lambda X_i}]$,则$Pr[X\leq (1-\delta)\mu]\leq \dfrac{\prod\limits_{i=1}^nE[e^{\lambda X_i}]}{e^{\lambda(1-\delta)\mu}}$,其余和独立的情形一致，$Pr[X\leq (1-\delta)\mu]\leq \dfrac{e^{(e^{(\lambda-1)\mu})}}{e^{\lambda(1-\delta)\mu}}$</p>

<p>Qed.</p>

<h3 id="3-1">(3)</h3>

<p>记$p=\|I\|,q=\|J\|$,记$X_i\in I,X_{i_1},X_{i_2},…,X_{i_p}$,记$X_j\in J,X_{j_1},X_{j_2},…,X_{j_q}$.$I$和$J$对应将$B_{i,k}$划分后的集合</p>

<p>注意到$\sum\limits_{i=1}^nB_{i,k}=1$有且仅有一个为1.</p>

<p>当$X_{i_m}=1$时，其余$X_{i_k},X_{j_k},k\neq m$均为0.</p>

<p>记$f(X_i,i\in I)$为$f_m，其中X_{i_m}=1,f_0表示X_{i_k}均为0,\forall 1\leq k\leq p$，
同理有$g_m$的定义,记$f(X_j,j\in J)$为$g_m，其中X_{j_m}=1,g_0表示X_{j_k}均为0,\forall 1\leq k\leq q$.</p>

<p>记$A=\sum\limits_{m=1}^{\|I\|}f_m,B=\sum\limits_{m=1}^{\|J\|}g_m$</p>

<p>$S_1 = E[f(X_i,i\in I)g(X_j,j\in J)] = \dfrac{1}{n}g_0A+\dfrac{1}{n}f_0B+\dfrac{n-\|I\|-\|J\|}{n}f_0g_0$</p>

<p>$S_2=E[f(X_i)]E[g(X_j)]=(\dfrac{1}{n}A+(1-\dfrac{p}{n})f_0)(\dfrac{1}{n}B+(1-\dfrac{q}{n})f_0)<br />
=\dfrac{1}{n^2}AB+\dfrac{1}{n}g_0A-\dfrac{q}{n^2}g_0A+\dfrac{1}{n}f_0B-\dfrac{p}{n^2}f_0B+f_0g_0(\dfrac{n-p-q}{n}+\dfrac{pq}{n^2})<br />
=S_1 + \dfrac{1}{n^2}(AB-qg_0A-pf_0B+pqf_0g_0)<br />
=S_1+\dfrac{1}{n^2}(A-pf_0)(B-qg_0)$</p>

<p>由于$f$是非减函数，所以$\dfrac{1}{n^2}(A-pf_0)(B-qg_0) \geq 0\Rightarrow S_1\leq S_2$,Qed.</p>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="大三第一学期" /><summary type="html"><![CDATA[高级算法作业]]></summary></entry><entry><title type="html">数据库期末复习</title><link href="http://localhost:4000/ppx123-web/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/" rel="alternate" type="text/html" title="数据库期末复习" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%AE%BA/"><![CDATA[<blockquote>
  <p>主体来自于Maxwell：https://maxwell-lyu.github.io/，在其基础上简单修改</p>
</blockquote>

<h1 id="数据库概论期末复习">数据库概论期末复习</h1>

<h2 id="样卷总结">样卷总结</h2>

<h3 id="大题">大题</h3>

<p>关系代数与关系演算</p>

<p>SQL语言</p>

<p>关系规范化</p>

<p>数据库设计</p>

<p>事务处理</p>

<h2 id="证明">证明：</h2>

<h3 id="冲突冲突可串行化冲突可串行化的判定定理-证明">冲突，冲突可串行化，冲突可串行化的判定定理 证明：</h3>

<p>如果调度S的事务优先图中无环，则S是冲突可串行化调度。</p>

<p>归纳法：k-1时成立，k时，考虑没有入边的事务$T_i$，则$T_i$可非冲突交换到调度最前面，$T_i$，其他k-1个事务，由归纳假设Qed</p>

<p>如果调度S的事务优先图中有环，则S不是冲突可串行化调度。</p>

<p>反证法：假设存在一个冲突可串行化调度，冲突等价于串行调度$S={T_1,T_2,…,T_n}$，根据事务优先图$T_1$先于$T_2$,$T_2$先于$T_3$，$T_{n-1}$先于$T_n$，$T_n$先于$T_1$，产生矛盾</p>

<h3 id="两阶段封锁协议与冲突可串行化的关系证明">两阶段封锁协议与冲突可串行化的关系证明：</h3>

<p>归纳法：</p>

<p>k-1时成立，考虑k时，考虑第一个有解锁动作的事务$T_i$，则$T_i$可以冲突等价于$T_i$，和其他剩下的事务，后面k-1由归纳假设，也冲突等价于一个串行化调度，Qed</p>

<h3 id="bcnf-3nf的证明">BCNF-&gt;3NF的证明</h3>

<p>$R\in BCNF$,$R\notin 3NF$有三种情况</p>

<p>$R\notin 1NF$,显然不成立</p>

<p>$R\notin 2NF$,非主属性A部分依赖关键字$K\overset{p}{\to}A，W\overset{f}{\to}A,W\subset K$,则由BCNF，$W$包含关键字$K^{‘}\subset K$矛盾</p>

<p>$R\notin 3NF$,有传递函数依赖</p>

<h3 id="4nf与bcnf-证明">4NF与BCNF 证明</h3>

<p>4NF：函数依赖满足BCNF</p>

<p>不是函数依赖的多值依赖：只允许出现平凡多值依赖</p>

<h1 id="第一章数据库系统概述">第一章:数据库系统概述</h1>

<h2 id="基本概念">基本概念</h2>

<ul>
  <li><strong>数据库</strong>(DB): 是数据集合, 具有统一的结构形式并存放于统一的存储介质内, 它由多种应用数据集成, 并可被应用所共享</li>
  <li><strong>数据库管理系统</strong>(DBMS): 是管理数据库的系统软件</li>
  <li><strong>数据库系统</strong>(DBS): 是一个以对海量的、具有复杂数据结构的、可以持久保存的、可供多用户共享的数据进行统一管理为目标的计算机系统</li>
  <li><strong>数据库管理员</strong>(DBA): 对数据库进行规划、设计、维护、监视的专职人员</li>
  <li>
    <p>相互之间的关系</p>

    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /></pre></td><td class="code"><pre><span class="line">数据库应用系统---+-[数据库系统]---+-[数据库] &lt;------------+---------------+</span><br /><span class="line">                 |                |                       |               |</span><br /><span class="line">                 +-应用软件       +-[数据库管理系统] : 管理               |</span><br /><span class="line">                 |                |                                       |</span><br /><span class="line">                 +-应用界面       +-[数据库管理员] : 规划, 设计, 维护, 监视</span><br /><span class="line">                 |                |</span><br /><span class="line">                 +-数据库用户     +-软件平台</span><br /><span class="line">                                  |</span><br /><span class="line">                                  +-硬件平台</span><br /></pre></td></tr></tbody></table>
  </li>
</ul>

<h2 id="数据库系统的特点">数据库系统的特点</h2>

<ul>
  <li>数据<strong>集成化</strong>: 统一的数据结构/数据模式</li>
  <li>数据<strong>独立性</strong>: 数据或数据结构(物理, 逻辑) &lt;–&gt; 应用程序</li>
  <li>数据<strong>共享性</strong>: 高</li>
  <li>数据<strong>冗余性</strong>: 低</li>
  <li>数据的<strong>安全性，完整性和一致性</strong></li>
  <li><strong>并发控制和故障恢复</strong></li>
</ul>

<h2 id="数据库内部结构体系">数据库内部结构体系</h2>

<ul>
  <li><strong>数据模式</strong>: 数据库中数据结构的具体表示与描述</li>
  <li>三级模式
    <ul>
      <li><strong>概念模式</strong>: 整个数据库中数据的全局逻辑结构 -&gt; 概念数据库</li>
      <li><strong>外模式</strong>: 某个用户所需数据的逻辑结构 -&gt; 用户数据库</li>
      <li><strong>内模式</strong>: 物理存储结构和物理存取方法 -&gt; 物理数据库</li>
    </ul>
  </li>
  <li>二级映射
    <ul>
      <li><strong>概念-&gt;内</strong>: 全局逻辑结构 -&gt; 数据的物理存储结构</li>
      <li><strong>外-&gt;概念</strong>: 多个外模式 -&gt; 一个概念模式, 而每个外模式是概念模式的一个基本视图</li>
    </ul>
  </li>
  <li>三级模式与数据独立性的关系
    <ul>
      <li>概念-&gt;内: <strong>物理独立性</strong></li>
      <li>外-&gt;概念: <strong>逻辑独立性</strong></li>
    </ul>
  </li>
</ul>

<h1 id="第二章数据模型">第二章:数据模型</h1>

<h2 id="数据模型的基本概念">数据模型的基本概念</h2>

<ul>
  <li>
    <p><strong>数据模型</strong>: 数据基本特征的抽象</p>

    <ul>
      <li>描述<strong>数据结构</strong>: 数据的类型, 内容, 性质, 数据间联系</li>
      <li>定义<strong>数据操作</strong>: 操作的类型, 方式</li>
      <li>定义<strong>数据约束</strong>: 数据间的相互关系: 语法语义联系, 制约与依存, 动态变化规则</li>
    </ul>
  </li>
  <li>数据模型的<strong>核心</strong>: 数据结构</li>
  <li>不同类型数据模型的<strong>区分依据</strong>: 应用层次</li>
  <li>三个抽象层次
    <ul>
      <li>
        <p><strong>概念数据模型</strong>: 面向客观世界, 面向用户; 客观对象的数据特征及相互关系</p>

        <blockquote>
          <p>E-R模型, EE-R模型; 面向对象模型; 谓词模型</p>
        </blockquote>
      </li>
      <li>
        <p><strong>逻辑数据模型</strong>: 面向数据库系统; 事物及关系在选定的DBMS中的实现结构</p>

        <blockquote>
          <p>层次, 网状模型; 关系, 面向对象, 谓词模型; 对象关系模型</p>
        </blockquote>
      </li>
      <li>
        <p><strong>物理数据模型</strong>: 面向计算机物理表示; 数据模型的物理表示</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="数据模型的四个世界">数据模型的四个世界</h2>

<ul>
  <li><strong>现实世界</strong>: 客观世界中的应用环境</li>
  <li><strong>概念世界</strong>: 基于现实世界, 进一步的抽象而形成</li>
  <li><strong>信息世界</strong>: 基于概念世界, 用特定的DBMS构造而成的逻辑数据模型</li>
  <li>
    <p><strong>计算机世界</strong>: 逻辑数据模型在计算机中的物理实现</p>

    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /></pre></td><td class="code"><pre><span class="line">现实世界                           用户1    ...   用户n</span><br /><span class="line">  |                                  |              |</span><br /><span class="line">概念世界------&gt;概念模型              |              |     </span><br /><span class="line">  |              |                   |              |</span><br /><span class="line">  |              |            +---&gt;外模式1   ...  外模式n     </span><br /><span class="line">信息世界------&gt;逻辑模型-------|      |              |</span><br /><span class="line">  |              |            +---&gt;概念模式---------+</span><br /><span class="line">  |              |                   | </span><br /><span class="line">计算机世界----&gt;物理模型-----------&gt;内模式</span><br /></pre></td></tr></tbody></table>
  </li>
</ul>

<h2 id="概念世界与概念模型">概念世界与概念模型</h2>

<ul>
  <li>E-R模型与E-R图（包括扩充E-R模型）
    <ul>
      <li>实体: 客观存在且又能相互区别的事物</li>
      <li>属性: 实体所具有的某种特性或特征
        <ul>
          <li>多值属性: 一个实体, 多个取值(例如爱好, 可有多个)</li>
          <li>组合属性: 一个性质, 多个属性(名字 &lt;-&gt; 姓, 名, 中间名)</li>
        </ul>
      </li>
      <li>联系: 不同实体集中, 实体间的对应关系</li>
      <li>联系上的函数对应关系: 一一, 一多/多一, 多多</li>
      <li>参与方式
        <ul>
          <li>参与方式标一个数, 参与基数标范围</li>
          <li>考虑一个实体e, 在关系R的函数对应关系中, 有x条线与他相连, 则其参与基数为x</li>
          <li>考虑实体集E, min-card(E,R): 其中实体参与基数最小值, max-card(E,R)同理</li>
        </ul>
      </li>
      <li>IS-A联系: 实体间可以有继承关系，由子集指向超集</li>
      <li>弱实体: 依赖于其他某个实体, 多个弱实体依赖一个实体, 从弱实体到依赖联系的有向箭头</li>
    </ul>
  </li>
  <li>面向对象模型
    <ul>
      <li>对象: 客观世界中能够相互区别开来的事物</li>
      <li>对象标识符: OID: 每对象有仅有一个, 用以相互区别</li>
      <li>类: 具有相同属性, 方法的对象集合</li>
      <li>方法: 施加在对象上的程序, 可审视或改变属性值</li>
      <li>超类和子类: 类的子集叫做子类, 原来的类叫做超类</li>
      <li>聚合: 若干个简单类聚合成一个复杂的类的过程</li>
      <li>分解: 复杂类分解成若干层次上的简单类的过程</li>
      <li>继承: (超类与子类)单向不循环的层次结构, 共享实现和定义</li>
      <li>合成: (聚合与分解)</li>
    </ul>
  </li>
</ul>

<h2 id="信息世界和逻辑模型">信息世界和逻辑模型</h2>

<ul>
  <li>关系模型
    <ul>
      <li>关系: 由行和列组成的二维表格(表框架 + 元组*n)</li>
      <li>属性: 表框架中的每一列</li>
      <li>值域(域): 元组在某一属性下的取值范围</li>
      <li>元组: 关系中的每一行</li>
      <li>关系模式：一个关系的关系名及其属性名的集合构成该关系 的关系模式</li>
      <li>关系数据库模式: 该关系数据库中所有关系的关系模式的集合</li>
      <li>关键字: 能唯一标识关系中的一个元组, 且又不含多余的属性值的属性集，（一个关系可以有多个关键字）关键字也被称为候选关键字
        <ul>
          <li>主关键字：可以从关系的候选关键字中选取一个作为该关系 的主关键字</li>
          <li>外关键字：设关系R中的属性集F，其取值来自于关系S中的主关键字K，则称属性集F是关系R的外关键字。（S和R可以是同一个关系）</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="计算机世界与物理模型">计算机世界与物理模型</h2>

<ul>
  <li>逻辑模型的物理存储
    <ul>
      <li>项: 文件系统中最小基本单位, 项内符号是不能继续分割</li>
      <li>记录: 由若干项组成, 有内在语义联系</li>
      <li>文件: 记录的集合</li>
    </ul>
  </li>
  <li>提高文件访问效率的常用方法
    <ul>
      <li>索引: 将文件中的记录与其物理地址(即磁盘块)间建立一张对应关系表</li>
      <li>集簇: 将具有相同或相邻项值的记录聚集在相同磁盘块内或圆柱体内以减少读盘次数</li>
      <li>HASH: 通过一个hash函数, 将要查找的记录转换成该记录所在的物理地址</li>
    </ul>
  </li>
</ul>

<h1 id="第三章关系数据库系统">第三章:关系数据库系统</h1>

<h2 id="关系数据库系统概述">关系数据库系统概述</h2>

<h2 id="关系数据库系统的衡量准则">关系数据库系统的衡量准则</h2>

<ul>
  <li>完全关系型的十二条衡量准则
    <ol>
      <li>信息准则: 逻辑一级
        <ul>
          <li>所有信息 -&gt; 表中的值, 唯一且显式地表示</li>
          <li>结构描述信息 -&gt; 组织成关系形式</li>
        </ul>
      </li>
      <li>确保访问准则
        <ul>
          <li>表名+关键字值+列名 -&gt; 访问到每一个原子数据</li>
        </ul>
      </li>
      <li>空值的关系处理准则
        <ul>
          <li>空值: 无意义/当前未知</li>
          <li>系统应当可以处理有空值参与的: 比较运算, 表达式运算, 统计运算</li>
        </ul>
      </li>
      <li>基于资源管理的动态联机目录
        <ul>
          <li>数据库的描述信息(数据字典) 与 用户数据 有 相同的表示形式和操作方式</li>
          <li>被授权用户可对 数据库的描述信息 进行 查询与扩充</li>
        </ul>
      </li>
      <li>统一易用的数据子语言: 至少一种子语言支持以下功能
        <ul>
          <li>数据定义</li>
          <li>视图(view)定义</li>
          <li>数据操纵</li>
          <li>完整性约束能力</li>
          <li>授权机制</li>
          <li>事务处理能力</li>
        </ul>
      </li>
      <li>视图更新准则: 视图除查询外, 还可增加, 删除, 修改数据</li>
      <li>高级的插入、删除及修改操作: 一条命令可以插入、删除及修改操作多条元组</li>
      <li>物理数据独立性</li>
      <li>逻辑数据独立性</li>
      <li>数据完整性准则: 提供三类数据完整性约束的定义功能</li>
      <li>分布独立性: 数据分布的改变不影响原有的应用程序</li>
      <li>无损害原则: 对提供低级数据子语言的要求</li>
    </ol>
  </li>
  <li>空值（NULL）的定义: 无意义/当前未知的值</li>
</ul>

<h2 id="关系模型数学理论关系代数">关系模型数学理论—关系代数</h2>

<h3 id="关系模型概念">关系模型（概念）</h3>

<ul>
  <li>关系数据结构
    <ul>
      <li>表结构（表头）:
        <ul>
          <li>表框架: 属性组成表框架</li>
          <li>表的元数: n个属性&lt;-&gt;表的元数</li>
          <li>表的基数: m个元组&lt;-&gt;表的基数</li>
        </ul>
      </li>
      <li>关系：关系的性质
        <ul>
          <li>元组: 个数有限, 唯一, 次序无关, 分量原子性, 分量值域同一</li>
          <li>属性: 名称唯一, 次序无关</li>
        </ul>
      </li>
      <li>关键字：候选关键字，主关键字，外关键字
        <ul>
          <li>关键字: 唯一最小标识元组的属性集, 每张表至少一个</li>
          <li>主关键字: 被选中的关键字</li>
          <li>superkey: 可以唯一确定一个元组的属性的集合</li>
          <li>候选关键字: 一个关系中可以有多个关键字，都是候选关键字</li>
          <li>外关键字: 如果表A中的属性集F是表B的关键字, 则称该属性集F为表A的外关键字</li>
        </ul>
      </li>
      <li>关系数据库：关系子模式-视图（view）</li>
    </ul>
  </li>
  <li>关系操纵
    <ul>
      <li>数据查询：步骤
        <ul>
          <li>两个关系的合并: 有多张表, 先合并为单个关系</li>
          <li>单个关系内的元组选择: 选择符合条件的元组(行指定)</li>
          <li>单个关系内的属性指定: 执行属性(列指定)</li>
        </ul>
      </li>
      <li>元组: 单个关系内的操作
        <ul>
          <li>删除: 确定被删除的元组-&gt;执行删除</li>
          <li>插入: 添加元组</li>
          <li>修改: 删旧-&gt;插新</li>
        </ul>
      </li>
      <li>空值的处理
        <ul>
          <li>主键不允许空值</li>
          <li>算数表达式: 含空值, 结果为空值</li>
          <li>逻辑表达式: 含空值, 结果为false</li>
          <li>统计计算: 空值不计入(视而不见)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>关系中的数据约束
    <ul>
      <li>实体完整性约束: 主关键字属性不为空值</li>
      <li>参照完整性约束: 外键要么取空值, 要么是被引用表中的主键值</li>
      <li>用户定义的完整性: 用户自己定义的属性取值约束</li>
    </ul>
  </li>
</ul>

<h3 id="关系的表示">关系的表示</h3>

<ul>
  <li>
    <p>关系的表示
设属性域为$D_1,D_2,⋯,D_n$
关系$R\subseteq D_1\times D_2\times \cdots \times D_n$</p>
  </li>
  <li>
    <p>迪卡尔乘积
$D_1,D_2,\cdots,D_n$是$n$个集合</p>

    <p>$D_1\times D_2\times\cdots\times D_n={(d_1,d_2,\cdots,d_n):d_i\in D_i,i\in (1,2,\cdots,n)}$</p>

    <table>
      <tbody>
        <tr>
          <td>$</td>
          <td>D_1\times D_2\times \cdots\times D_n</td>
          <td>=\prod\limits_{i=1}^{n}</td>
          <td>D_i</td>
          <td>$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>关系代数中的五种基本运算：选择，投影，笛卡儿积，并，差（请注意每个运算符的执行条件和结果关系的关系模式）
    <ul>
      <li>投影运算: $\pi_A(R)$
        <ul>
          <li>略去某些列, 重排剩余列的次序
关系R有属性${A_1,A_2, \cdots, A_n}$, 在其中$m$个属性上的投影运算如下
$\pi_{B_1, B_2, \cdots, B_n}(R), B_i\in{A_1,A_2, \cdots, A_n}$</li>
          <li>注意消除可能出现的重复元组</li>
        </ul>
      </li>
      <li>选择运算: $\sigma_F(R)$
        <ul>
          <li>关系模式不变, 由属于$R$且满足条件$F$的元组构成</li>
        </ul>
      </li>
      <li>笛卡尔乘积 - 关系的合并: 交换律, 结合律
        <ul>
          <li>若有相同的属性名, 必须在结果关系中对其中一个换名
注意：交运算: 同类关系</li>
          <li>用$R\cap S = R-(R-S)$代替, 不是基本运算</li>
        </ul>
      </li>
      <li>并运算: $R\cup S$同类关系
        <ul>
          <li>关系模式不变, 属于$R$或者$S$</li>
        </ul>
      </li>
      <li>差运算: $R-S$同类关系
        <ul>
          <li>关系模式不变, 属于$R$且不属于$S$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>基本运算的应用
    <ul>
      <li>插入: $R^*=R\cup R_{new}$</li>
      <li>删除: $R^* = R-R_{old}$</li>
      <li>修改: $R^* = (R-R_{old})\cup R_{new}$</li>
      <li>查询: $\pi_A(\sigma_B(R))$简写为$\pi_A\sigma_B(R)$: 不能交换位置</li>
    </ul>
  </li>
</ul>

<h3 id="关系模型与关系代数">关系模型与关系代数</h3>

<ul>
  <li>关系: n元有序组的集合</li>
  <li>关系操纵: 关系上的集合运算</li>
  <li>关系代数: 关系集合AAA及5种基运算构成的代数</li>
  <li>关系模型
    <ul>
      <li>关系模型的数据结构</li>
      <li>关系模型上的数据操纵</li>
      <li>关系模型上的数据约束</li>
    </ul>
  </li>
</ul>

<h3 id="关系代数中的扩充运算">关系代数中的扩充运算</h3>

<ul>
  <li>交运算: 同类关系
    <ul>
      <li>$R\cap S = R-(R-S)$</li>
      <li>关系模式不变, 既属于R也属于S的元组组成的集合</li>
    </ul>
  </li>
  <li>除运算:$\textrm{Head}(S)\subset \textrm{Head}(R)$
    <ul>
      <li>关系模式:$\textrm{Head}(T)=\textrm{Head}(R) - textrm{Head}(S)$</li>
      <li>设$x\in T$, 则$\forall y\in S$, $(x,y)\in R$, 所有满足条件的$x$构成结果</li>
      <li>如果$R=Ttimes S$, 则$T=R\div S, S=R\div T$; 如果T=R\div S, 则$T\times S\subseteq R$</li>
    </ul>
  </li>
  <li>联接运算
    <ul>
      <li>根据联接条件合并: $R\mathop\bowtie\limits_F S=\sigma_F(R\times S)$</li>
      <li>自然联接: $R\bowtie S$所有同名属性上的取值都一样, 就联接元组, 同名属性保留一份</li>
      <li>外联接: 有”外”的一侧, 其所有元组均出现, 另一侧无匹配元组就用null代替</li>
    </ul>
  </li>
  <li>扩充运算与基本运算之间的关系
    <ul>
      <li>交: 可由差运算实现: $R\cap S=R-(R-S)=S-(S-R)$</li>
      <li>除:
        <ul>
          <li>$\textrm{Head}(R) = {A_1, \cdots, A_n, B_1, \cdots, B_m}$</li>
          <li>${Head}(S) = {B_1, \cdots, B_m}$</li>
          <li>$R\div S=\pi_{A_1,\cdots A_n}(R)-\pi_{A_1,\cdots A_n}((\pi_{A_1,\cdots A_n}(R)\times S)-R)$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>扩充运算的应用实例</li>
</ul>

<h3 id="关系代数的应用">关系代数的应用</h3>

<blockquote>
  <p>写在后面的大题部分</p>

  <ul>
    <li>综合的关系代数应用表示，复杂查询的关系代数表达式</li>
    <li>关系代数的应用
      <ul>
        <li>单个关系上的选择与投影</li>
        <li>两个关系的并、交、差</li>
        <li>两个关系的迪卡尔乘积、自然联接、θ-联接</li>
        <li>两个关系的除法</li>
      </ul>
    </li>
    <li>难点
      <ul>
        <li>查询条件带有‘否定’语义：‘不等’比较 &amp; 减法运算</li>
        <li>使用表联接查询，还是使用除法?</li>
        <li>正确使用自然连接运算 和 除法运算</li>
        <li>表的自联接</li>
      </ul>
    </li>
  </ul>
</blockquote>

<h3 id="关系演算">关系演算</h3>

<ul>
  <li>原子公式
    <ul>
      <li>谓词是原子公式</li>
      <li>$u(i) \theta v(j)$是原子公式, 其中$u(i), v(j)$是元组中属性的值, $\theta$是比较运算符</li>
      <li>$u(i) \theta a$是原子公式, 其中$a$是常量</li>
    </ul>
  </li>
  <li>公式的定义: 以下三种方式, 有限次数组合构成
    <ul>
      <li>原子公式是公式</li>
      <li>公式的与, 或, 蕴含, 非 均为公式</li>
      <li>量词约束一个公式, 构成新公式</li>
    </ul>
  </li>
  <li>基于关系演算的数据查询表示
    <ul>
      <li>投影
$\pi_{A_{1},A_{2},\cdots,A_{k}}(R)=\exists x_{k+1},x_{k+2},\cdots ,x_n(R(x_1,x_2,\cdots,x_n))$</li>
      <li>选择
$\sigma_F(R)=R(x_1,x_2,\cdots,x_n)\wedge F$
        <ul>
          <li>相等比较可以直接用常量代替: $\sigma_{x_1=’a’}(R)=R(‘a’,x_2,\cdots,x_n)\wedge F$</li>
        </ul>
      </li>
      <li>笛卡尔积
$R\times S = R(p)\wedge S(q)$</li>
      <li>$\theta$-联接
$R\underset{F}{\bowtie} S = R(p)\wedge S(q)\wedge F$</li>
      <li>自然联接
$R\bowtie S = R(x,y,z)\wedge S(t,u,v)$</li>
      <li>自联接, 重命名
$R(x, g_1)\wedge R(x, g_2)$</li>
      <li>除法
$R\div S=\forall y(S(y)\rightarrow R(x,y))$</li>
      <li>删除
$R-S = R(u)\wedge \neg S(u)$</li>
      <li>插入
$R\cup S = R(t)\vee S(t)$</li>
      <li>修改 = 删除再插入</li>
    </ul>
  </li>
  <li>公式的表示
    <ul>
      <li>$\phi_1\wedge\phi_2$
        <ul>
          <li>有公共变元, 等价于自然联接$R_1\bowtie R_2$</li>
          <li>无公共变元, 等价于笛卡尔乘积$R_1\times R_2$</li>
        </ul>
      </li>
      <li>$\phi_1\vee\phi_2: R_1\cup R_2$</li>
      <li>$\phi_1\rightarrow\phi_2$: $R_2\div R_1$</li>
      <li>$\neg\phi: (\prod^nD_i)-R, D_i$为第$i$个自由变元的值域</li>
      <li>$\exists r(\phi)$: $\pi_{A_1,A_2,\cdots,A_k}(R)$</li>
      <li>$\forall r(\phi):R\div S$</li>
    </ul>
  </li>
</ul>

<h2 id="关系数据库语言sql92">关系数据库语言SQL’92</h2>

<h3 id="sql概貌">SQL概貌</h3>

<ul>
  <li>SQL的基本概念: 结构化查询语言
    <ul>
      <li>使用方式
        <ul>
          <li>自含式: 独立的交互式命令行语言</li>
          <li>嵌入式: 嵌入到某种高级语言当中</li>
        </ul>
      </li>
      <li>基表: 关系</li>
      <li>虚表(视图): 关系子模式</li>
      <li>行: 元组</li>
      <li>列: 属性</li>
    </ul>
  </li>
</ul>

<h3 id="sql数据定义功能">SQL数据定义功能</h3>

<blockquote>
  <p>啥也没有?怎么回事啊, 算了写一点乱七八糟的吧</p>

  <ul>
    <li>
      <p>创建基表</p>

      <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tabname {</span><br /><span class="line">  colname datatype <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br /><span class="line">  colname2 datatype2</span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table>
    </li>
  </ul>

</blockquote>

<ul>
  <li>
    <p>修改基表</p>

    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="keyword">ADD</span> colname datatype</span><br /><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tabname <span class="keyword">DROP</span> colname</span><br /></pre></td></tr></tbody></table>
  </li>
  <li>
    <p>删除基表</p>

    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> tabname</span><br /></pre></td></tr></tbody></table>
  </li>
</ul>

<h3 id="sql数据操纵功能">SQL数据操纵功能</h3>

<ul>
  <li>SQL语言与关系代数的关系</li>
  <li>映像语句（select statement）的结构
    <ul>
      <li>
        <p>目标子句: <code class="language-plaintext highlighter-rouge">SELECT * | colname { , colname ... }</code></p>

        <blockquote>
          <p>最后执行, 有排序时倒数第二执行</p>
        </blockquote>
      </li>
      <li>
        <p>范围子句: <code class="language-plaintext highlighter-rouge">FROM tabname { , tabname ... }</code></p>

        <blockquote>
          <p>在SQL中, 这些表相当于被笛卡尔乘积连接, 因此联结时需要在where中给出条件</p>
        </blockquote>
      </li>
      <li>条件子句: <code class="language-plaintext highlighter-rouge">[ WHERE search_condition ]</code></li>
      <li>分组子句: <code class="language-plaintext highlighter-rouge">[ GROUP BY colname { , colname ... }</code></li>
      <li>分组查询子句: <code class="language-plaintext highlighter-rouge">[ HAVING group_condition ]</code></li>
      <li>
        <p>排序输出子句: <code class="language-plaintext highlighter-rouge">[ ORDER BY colname [ ASC | DESC ] { , colname [ ASC | DESC ] ... } ]</code></p>

        <blockquote>
          <p>最后执行</p>

          <ul>
            <li>两个必须的子句: <code class="language-plaintext highlighter-rouge">select</code>/<code class="language-plaintext highlighter-rouge">from</code></li>
            <li>having子句的前面必须有group by子句</li>
          </ul>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>基本查询功能
    <ul>
      <li>distinct谓词: <code class="language-plaintext highlighter-rouge">DISTINCT colname</code> 统计查询使用, 去重统计</li>
      <li>LIKE: <code class="language-plaintext highlighter-rouge">colname [NOT] LIKE val1 [ESCAPE val2]</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">val1</code>是模板, 其中<code class="language-plaintext highlighter-rouge">_</code>匹配任意一个字符, <code class="language-plaintext highlighter-rouge">%</code>匹配任意一个字符串</li>
          <li><code class="language-plaintext highlighter-rouge">val2</code>定义转义指示字符, 跟在其后的, <code class="language-plaintext highlighter-rouge">val1</code>中的通配符和转义字符将表示原义</li>
        </ul>
      </li>
      <li>IS NULL谓词: <code class="language-plaintext highlighter-rouge">colname IS [NOT] NULL</code>判断是否为NULL</li>
      <li>多表联接查询: <code class="language-plaintext highlighter-rouge">WHERE</code>当中, 通过属性的相等, 实现表与表之间的连接</li>
      <li>表的自联接查询: <code class="language-plaintext highlighter-rouge">tabname [[AS] alias]</code> 给表起别名</li>
    </ul>
  </li>
  <li>嵌套查询
    <ul>
      <li>IN: <code class="language-plaintext highlighter-rouge">expr [NOT] IN (subquery)</code>标量与集合量之间的属于比较</li>
      <li>SOME/ANY/ALL: <code class="language-plaintext highlighter-rouge">expr θ SOME|ANY|ALL (subquery)</code>标量与集合中元素之间的量化比较</li>
      <li>EXISTS: <code class="language-plaintext highlighter-rouge">[NOT] EXIST</code>是否为空集的判断谓词</li>
      <li>相关子查询与独立子查询: 子查询内部引用了外部查询的表或元组变量, 因此每当外部取值变化, 都要再运行子查询</li>
    </ul>
  </li>
  <li>子查询的合并: 带<code class="language-plaintext highlighter-rouge">ALL</code>意为允许重复
    <ul>
      <li>UNION: <code class="language-plaintext highlighter-rouge">(subquery) UNION [ALL] (subquery)</code>并</li>
      <li>INTERSECT: <code class="language-plaintext highlighter-rouge">(subquery) INTERSECT [ALL] (subquery)</code>交</li>
      <li>EXCEPT: <code class="language-plaintext highlighter-rouge">(subquery) EXCEPT [ALL] (subquery)</code>减</li>
    </ul>
  </li>
  <li>
    <p>复杂数据查询</p>

    <ul>
      <li>统计查询
        <ul>
          <li>
            <p><code class="language-plaintext highlighter-rouge">COUNT(colname)</code>: 计数, 空值忽略</p>

            <blockquote>
              <p><code class="language-plaintext highlighter-rouge">COUNT(DISTINCT colname)</code>: 计数互不相同的值, 空值忽略</p>
            </blockquote>
          </li>
          <li><code class="language-plaintext highlighter-rouge">SUM(colname)</code>: 求和, 空值忽略</li>
          <li><code class="language-plaintext highlighter-rouge">AVG(colname)</code>: 求平均, 空值忽略</li>
          <li><code class="language-plaintext highlighter-rouge">MIN(colname)</code>: 求最小, 空值忽略</li>
          <li><code class="language-plaintext highlighter-rouge">MAX(colname)</code>: 求最大, 空值忽略</li>
        </ul>
      </li>
      <li>
        <p>分组统计查询: <code class="language-plaintext highlighter-rouge">GROUP BY colname {, colname}</code>按照<code class="language-plaintext highlighter-rouge">colname</code>的取值不同, 分组统计</p>

        <blockquote>
          <p><code class="language-plaintext highlighter-rouge">SELECT</code>当中必须包括<code class="language-plaintext highlighter-rouge">GROUP BY</code>当中的属性</p>
        </blockquote>
      </li>
      <li>分组选择统计查询: <code class="language-plaintext highlighter-rouge">HAVING group_cond</code>必须先分组, 之后满足<code class="language-plaintext highlighter-rouge">group_confd</code>的组才会被保留</li>
      <li>
        <p>关系代数中的除法运算功能在SQL中的表示方法
待构造的除法: $\pi_{sno, cno}(SC)\div \pi_{cno}(C)$</p>

        <blockquote>
          <p>语义: 对于符合要求的SC中sno, (对于任意的C中cno, 都有sno选修过cno的记录)
等价于: 对于符合要求的SC中元组S, 对于任意C中元组x, 都能找到元组y,使得y.sno=S.sno and y.cno=x.cno</p>

          <p>任意-&gt;不存在不满足-&gt;不存在(不存在):</p>

          <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /></pre></td><td class="code"><pre><span class="line">对SC中S, 不存在  </span><br /><span class="line">  对C中x, 不存在</span><br /><span class="line">    SC中的S-x元组y, 即y.sno=S.sno and y.cno=x.cno</span><br /></pre></td></tr></tbody></table>
        </blockquote>

        <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /><span class="line">11</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> SC.sno                        <span class="comment"># </span></span><br /><span class="line"><span class="keyword">FROM</span> SC S                                     <span class="comment"># 被除数当中的元组, 作为目标元组, 将目标属性传入(S.sno)</span></span><br /><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (                            <span class="comment"># 不存在不满足条件的元组</span></span><br /><span class="line">    <span class="keyword">SELECT</span> *                                  <span class="comment"># </span></span><br /><span class="line">    <span class="keyword">FROM</span> C x                                  <span class="comment"># 除数当中的元组, 被要求对任意S.sno全都有</span></span><br /><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (                        <span class="comment"># 为了表示"不满足", 构造对S.sno不含有, 即不存在满足的元组</span></span><br /><span class="line">        <span class="keyword">SELECT</span> *                              <span class="comment"># </span></span><br /><span class="line">        <span class="keyword">FROM</span> SC y                             <span class="comment"># 被除数元组的任意元组, 寻找满足的元组</span></span><br /><span class="line">        <span class="keyword">WHERE</span> y.sno = S.sno <span class="keyword">AND</span> y.cno = x.cno <span class="comment"># 一个[除数,被除数]的元组, 两组相等关系, 分别约束: (对被除数进行查询), (对除数进行查询)</span></span><br /><span class="line">    )                                         <span class="comment"># 这个子查询可以由NOT IN代替, 表示不含有</span></span><br /><span class="line">)                                             <span class="comment">#</span></span><br /></pre></td></tr></tbody></table>
      </li>
      <li>在FROM子句中嵌入子查询: <code class="language-plaintext highlighter-rouge">FROM (subquery) [[AS] alias]</code>
&lt;!– + 查询结果输出</li>
      <li>结果元组去重：distinct</li>
      <li>结果元组排序：order by –&gt;</li>
    </ul>
  </li>
</ul>

<h3 id="sql的更新功能">SQL的更新功能</h3>

<ul>
  <li>元组删除: <code class="language-plaintext highlighter-rouge">DELETE FROM tabname [WHERE cond]</code></li>
  <li>
    <p>元组插入:</p>

    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tabname [(colname {,colname})]</span><br /><span class="line"><span class="keyword">VALUES</span> (expr | <span class="literal">NULL</span> {,expr | <span class="literal">NULL</span>}) | (subquery)</span><br /></pre></td></tr></tbody></table>
  </li>
  <li>
    <p>元组修改:</p>

    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tabname </span><br /><span class="line"><span class="keyword">SET</span> colname=expr | <span class="literal">NULL</span> | subquery, ...</span><br /><span class="line">[<span class="keyword">WHERE</span> cond]</span><br /></pre></td></tr></tbody></table>
  </li>
</ul>

<h3 id="视图">视图</h3>

<ul>
  <li>视图概念: 若干张表经映像语句构筑而成的表(导出表)</li>
  <li>视图与基表的区别: 同样有构造信息, 但视图不存储(虚表)</li>
  <li>
    <p>创建: <code class="language-plaintext highlighter-rouge">CREATE VIEW &lt;视图名&gt; [(&lt;列名&gt;{, &lt;列名&gt;})] AS &lt;映像语句&gt; [WITH CHECK OPTION]</code></p>

    <blockquote>
      <p>映像语句实际上就是子查询, CHECK OPTICON 不知道什么意思</p>
    </blockquote>
  </li>
  <li>删除: <code class="language-plaintext highlighter-rouge">DROP VIEW &lt;视图名&gt;</code></li>
  <li>视图的嵌套定义</li>
  <li>视图删除中的连锁反应: 视图的删除操作时，将连带删除定义在该视图上的其它视图</li>
  <li>可更新视图的判断准则: 视图每一行对应基表每一行, 视图每一列对应基表每一列</li>
  <li>视图的作用: 提高数据独立性, 简化用户观点, 自动的安全保护</li>
</ul>

<h1 id="第四章数据库的安全性与完整性保护">第四章:数据库的安全性与完整性保护</h1>

<h2 id="数据库的安全性保护">数据库的安全性保护</h2>

<ul>
  <li>数据库安全的基本概念: 防止非法使用数据库(规定的途径和规则)
    <ul>
      <li>主体: 数据访问者</li>
      <li>客体: 数据及其载体</li>
      <li>身份标识与鉴别: 主体具有标识符和口令</li>
      <li>
        <p>自主访问控制: 基于存取矩阵的安全控制模型(用户给定权限, 访问时检查权限)</p>

        <blockquote>
          <p>客体所有者(创建者)自动拥有全部权限, 有权限的可授予他人权限, 权限仅限这两种方法获得
登陆时检查: 是不是管理员-&gt;是不是所有者-&gt;有没有被授权
存储矩阵: 行标签: 客体; 列标签: 主体</p>
        </blockquote>
      </li>
      <li>
        <p>审计: 跟踪记录用户对数据的访问操作</p>

        <blockquote>
          <p>时间, 内容, 用户名, 终端名, 操作类型, 操作结果; 给出报警信息</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>SQL对数据库安全的支持
    <ul>
      <li>
        <p>SQL中的存取权限</p>

        <blockquote>
          <p>权限: SELECT INSERT DELETE UPDATE REFERENCE EXECUTE USAGE
对象: 表/视图 属性 域(数据类型) 存储过程/函数/触发器</p>
        </blockquote>
      </li>
      <li>授权命令: <code class="language-plaintext highlighter-rouge">GRANT &lt;权限列表&gt; ON &lt;对象&gt; TO &lt;用户名列表&gt; [WITH GRANT OPTION]</code></li>
      <li>
        <p>回收命令: <code class="language-plaintext highlighter-rouge">REVOKE &lt;权限列表&gt; ON &lt;对象&gt; FROM &lt;用户名列表&gt; [RESTRICT | CASCADE]</code></p>

        <blockquote>
          <p>CASCADE连锁回收; RESTRICT不连锁才回收, 否则拒绝回收</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h2 id="数据库的完整性保护">数据库的完整性保护</h2>

<ul>
  <li>数据库完整性保护: 对数据库中数据的正确性和一致性的维护</li>
  <li>功能: 设置功能; 检查功能; 处理功能</li>
  <li>目的: 及时发现错误-&gt;防止错误的蔓延-&gt;恢复到正确状态</li>
  <li>常用实现措施
    <ul>
      <li>完整性约束条件的定义及检查</li>
      <li>触发器</li>
      <li>并发控制技术</li>
    </ul>
  </li>
  <li>实体完整性: 关键字不为空</li>
  <li>参照完整性: 不能引用不存在的实体(外关键字要么与被引相同, 要么为空值)</li>
  <li>用户定义完整性: 用户自己定义</li>
  <li>完整的CREATE TABLE命令
    <ul>
      <li>基表的创建</li>
      <li>
        <p>完整性约束的定义：主关键字，外关键字，CHECK约束，UNIQUE，NOT NULL, DEFAULT</p>

        <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /></pre></td><td class="code"><pre><span class="line">{  NOT NULL   |</span><br /><span class="line">  [ CONSTRAINT constraint_name ] </span><br /><span class="line"><span class="comment"># 给约束起名</span></span><br /><span class="line">    UNIQUE</span><br /><span class="line">    | PRIMARY KEY</span><br /><span class="line">    | <span class="keyword">CHECK</span> ( search_condition )</span><br /><span class="line">    | <span class="keyword">REFERENCES</span> table_name [ ( column_name ) ]</span><br /><span class="line">    [ <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span> ]</span><br /><span class="line">    [ <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span> ] </span><br /><span class="line">}</span><br /></pre></td></tr></tbody></table>
      </li>
    </ul>
  </li>
</ul>

<table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /></pre></td><td class="code"><pre><span class="line">FOREIGN KEY ( colname { , colname ... } ) </span><br /><span class="line"><span class="comment"># 定义主外键的引用关系</span></span><br /><span class="line">  REFERENCES table_name [ ( colname { ,colname... } ) ] </span><br /><span class="line">    </span><br /><span class="line"><span class="comment"># 当在被引用表中删除元组或修改主键值时，需要维护引用表中外键值的正确性</span></span><br /><span class="line">    [ ON <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span> ]</span><br /><span class="line">    [ <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span> | RESTRICT | <span class="keyword">SET</span> <span class="literal">NULL</span> ]   }</span><br /><span class="line">    </span><br /><span class="line"><span class="comment"># CASCADE 同步改变 | RESTRICT 拒绝(默认模式) | SET NULL 外键设为空</span></span><br /></pre></td></tr></tbody></table>

<ul>
  <li>触发器: 在数据库系统中，一个事件的发生会导致另外一些事件的发生，这样的功能被称为触发器</li>
  <li>
    <p>创建命令</p>

    <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /><span class="line">8</span><br /><span class="line">9</span><br /><span class="line">10</span><br /><span class="line">11</span><br /><span class="line">12</span><br /><span class="line">13</span><br /></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name { <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span> } </span><br /><span class="line"><span class="comment"># 定义时机</span></span><br /><span class="line">{ <span class="keyword">INSERT</span> | <span class="keyword">DELETE</span>                              </span><br /><span class="line"><span class="comment"># 触发事件</span></span><br /><span class="line">  | <span class="keyword">UPDATE</span> [ <span class="keyword">OF</span> colname { , colname ... } ] }</span><br /><span class="line">    <span class="keyword">ON</span> table_name </span><br /><span class="line">  [ <span class="keyword">REFERENCING</span> corr_name_def { , ...... } ]</span><br /><span class="line">  [ <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> | <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">STATEMENT</span> ]        </span><br /><span class="line"><span class="comment"># 执行方式</span></span><br /><span class="line">  [ <span class="keyword">WHEN</span> ( search_condition ) ]</span><br /><span class="line">  { <span class="keyword">statement</span>                                  </span><br /><span class="line"><span class="comment"># 结果事件</span></span><br /><span class="line">  | BEGIN ATOMIC statement; { statement; ... } END</span><br /></pre></td></tr></tbody></table>
  </li>
</ul>

<h1 id="第五章事务处理并发控制与故障恢复技术">第五章:事务处理并发控制与故障恢复技术</h1>

<h2 id="事务处理概念">事务处理（概念）</h2>

<ul>
  <li>
    <p>事务的定义: 某个用户所执行的一个不能被打断的对数据库的操作序列</p>
  </li>
  <li>ACID性质
    <ul>
      <li>A原子性: 不可分割的操作序列, 要么全部, 要么不执行</li>
      <li>C一致性: 执行前后都满足一致性</li>
      <li>I隔离性: 并发结果与某种串行执行结果相同, 即相互独立</li>
      <li>D持久性: 事务完成，它对数据库的所有更新应永久地反映在数据库中</li>
    </ul>
  </li>
  <li>
    <p>事务活动图
<img src="https://maxwell-lyu.github.io/2019/12/19/Learn-DB-20191219-DB-FIN/01.png" alt="image" /></p>
  </li>
  <li>
    <p>状态转换图</p>

    <p><img src="https://maxwell-lyu.github.io/2019/12/19/Learn-DB-20191219-DB-FIN/02.png" alt="image" /></p>
  </li>
  <li>事务控制语句
    <ul>
      <li>commit transaction</li>
      <li>rollback transaction: 可以恢复到存在的保存点, 或者回到事务起点</li>
      <li>savepoint: 设置保存点</li>
    </ul>
  </li>
  <li>相关的参数设置语句
    <ul>
      <li>自动提交: <code class="language-plaintext highlighter-rouge">SET AUTOCOMMIT ON|OFF</code></li>
      <li>读写: <code class="language-plaintext highlighter-rouge">SET TRANSACTION READONLY|READWRITE</code></li>
      <li>
        <p>隔离级别: <code class="language-plaintext highlighter-rouge">SET TRANSACTION ISOLATION LEVEL READUNCOMMITTED|READCOMMITTED| READREPEATABLE|SERIALIZABLE</code></p>

        <blockquote>
          <p>READUNCOMMITTED无封锁; READCOMMITTED读加共享锁到读完; READREPEATABLE读加共享锁到事务结束; SERIALIZABLE串行化调度执行</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>事务的语句组成成分: 开始, 结束(正常结束-&gt;提交事务, 非正常结束-&gt;回滚)</li>
</ul>

<h2 id="并发控制技术概念">并发控制技术（概念）</h2>

<ul>
  <li>事务
    <ul>
      <li>事务的并发性: 数据库是一个多用户共享系统, 以事务为单位访问</li>
      <li>并发控制: 实现多个用户事务的并发执行的技术</li>
      <li>调度: DBMS中事务执行的操作序列, 按时间排序</li>
      <li>串行调度: 做完一个接下一个事务(首先是一个事务的所有操作，然后是另一个事务的所有操作, 原句真啰嗦)</li>
      <li>可串行化调度: 一个调度对数据库状态的影响和某个串行调度相同</li>
      <li>冲突: 调度中一对相邻操作, 交换顺序，涉及的事务中至少有一个的行为会改变</li>
      <li>
        <p>冲突可串行化(可串行化的充分条件): 冲突可串行化调度”冲突等价”于一个串行调度</p>

        <blockquote>
          <p>冲突等价: 如果通过一系列相邻操作的非冲突交换能够将一个调度转换为另一个调度，则我们称这两个调度是冲突等价的</p>
        </blockquote>
      </li>
      <li>
        <p>视图可串行化: 视图可串行化调度”视图等价”于一个串行调度</p>

        <blockquote>
          <p>视图等价
[视图等价]相同的一组事务，两个不同的调度S与H。S和H被称为“视图等价”当且仅当满足下列三个条件：
对每一个数据项D
如果在调度S中事务$T_k$读到D的初始值，则在调度H中事务$T_k$也必须读到D的初始值；
如果在调度S中事务$T_k$执行了rk(D)，并且读到的是由事务$T_j$写入的D的值，则在调度H中事务$T_k$的rk(D)读到的也必须是由事务$T_j$ 所写入的D的值；
如果在调度S中是由事务$T_k$来执行最后一条关于D的写操作wk(D)，则在调度H中也一定是事务$T_k$执行最后一条关于D的写操作wk(D)。</p>
        </blockquote>
      </li>
      <li>
        <p>冲突可串行化的判定方法: 事务优先图没环 &lt;-&gt; 是冲突可串行化</p>

        <blockquote>
          <p>事务优先图
优先: 给出的调度H中, 两个动作来自不同事务, 若其涉及同一个数据库对象且至少一个为写, 则这两个事务不可交换, 定义了优先关系
优先关系画出有向图
盲写: 没读就写</p>
        </blockquote>
      </li>
      <li>不正确的事务并发所导致的数据不一致现象</li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>不一致现象</th>
      <th>描述</th>
      <th>原因</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>丢失修改</td>
      <td>一个修改破坏另一个修改结果</td>
      <td>多个事务并发修改同一个数据</td>
    </tr>
    <tr>
      <td>脏读</td>
      <td>读到错误的数据</td>
      <td>其他事务未提交的修改</td>
    </tr>
    <tr>
      <td>不可重复读</td>
      <td>前后两次读不一致</td>
      <td>其他事务已提交的写操作</td>
    </tr>
    <tr>
      <td>幻像读</td>
      <td>一个事务中, 执行相同的查询多次, 结果不同</td>
      <td>其他事务已提交的插入操作</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>封锁
    <ul>
      <li>
        <p>排它锁（X锁）: 一个对象同时只能上一次, 维持到事务结束</p>

        <blockquote>
          <p>自己可以读写, 别人啥也不行</p>
        </blockquote>
      </li>
      <li>
        <p>共享锁（S锁）: 可以与其他S锁并存</p>

        <blockquote>
          <p>全员只读</p>
        </blockquote>
      </li>
      <li>锁申请: 能锁就锁, 锁了就睡, 被叫醒且能锁就锁</li>
      <li>锁释放: 解锁, 唤醒</li>
      <li>基于封锁技术的并发控制实现方法
        <ul>
          <li>过程: 访问发给调度器-&gt;调度器申请锁, 封锁管理器-&gt;管理器返回结果-&gt;(成功, 操作发给执行引擎; 失败, 进队列)</li>
          <li>三级封锁协议
            <ul>
              <li>一级: 写之前加X锁, 事务结束释放</li>
              <li>二级: 一级 + 读前加S锁, 读完释放</li>
              <li>三级: 二级 + 读前加S锁, 事务结束释放</li>
            </ul>
          </li>
          <li>三级封锁协议防止的不一致
            <ul>
              <li>一级: 丢失修改</li>
              <li>二级: 丢失修改, 脏读</li>
              <li>三级: 丢失修改, 脏读, 不可重复读</li>
            </ul>
          </li>
          <li>两阶段封锁协议
            <ul>
              <li>在一个事务T中，如果它的所有封锁请求都先于它的所有解锁请求，则该事务被称为‘两阶段封锁事务’ ，简称‘2PL事务’</li>
              <li>一阶段: 申请整个过程需要的锁</li>
              <li>二阶段: 释放所有锁, 不能再申请</li>
            </ul>
          </li>
          <li>两阶段封锁协议与冲突可串行化的关系: 两阶段任意合法调度S都是冲突可串行化的</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>多粒度封锁
    <ul>
      <li>封锁粒度/并发度/并发控制实现开销 之间的关系
        <ul>
          <li>锁粒度大, 并发度低, 控制开销小</li>
          <li>锁粒度小, 并发度高, 控制开销大</li>
        </ul>
      </li>
      <li>多粒度封锁: 同时支持多种封锁粒度供事务选择</li>
      <li>多粒度树: 按照封锁粒度的大小构造出一棵 ‘多粒度树’，以树中的每个结点作为封锁对象，可以构成一个‘多粒度封锁协议’</li>
      <li>基于意向锁的多粒度封锁协议
        <ul>
          <li>意向锁: 节点加意向锁, 其下层节点正被加锁(必须上层先加意向锁, 才能给下层加锁)
            <ul>
              <li>IS: 下层打算加S</li>
              <li>IX: 下层打算加X</li>
              <li>SIX: 当前加S, 下层加X</li>
            </ul>
          </li>
          <li>意向锁锁相容矩阵</li>
          <li>意向锁锁申请算法，意向锁锁释放算法: 对任何一个节点加锁, 必须先对其父节点加意向锁(也就是从根开始加)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>已经有的锁</th>
      <th>S</th>
      <th>X</th>
      <th>IS</th>
      <th>IX</th>
      <th>SIX</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>已经持有S</td>
      <td>✔</td>
      <td> </td>
      <td>✔</td>
      <td> </td>
      <td> </td>
      <td>S加了, 当前及其下层没有X</td>
    </tr>
    <tr>
      <td>已经持有X</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>X排他, 加了别的都没有</td>
    </tr>
    <tr>
      <td>已经持有IS</td>
      <td>✔</td>
      <td> </td>
      <td>✔</td>
      <td>✔</td>
      <td>✔</td>
      <td>IS加了, 当前没X</td>
    </tr>
    <tr>
      <td>已经持有IX</td>
      <td> </td>
      <td> </td>
      <td>✔</td>
      <td>✔</td>
      <td> </td>
      <td>IX加了, 当前没S没X</td>
    </tr>
    <tr>
      <td>已经持有SIX</td>
      <td> </td>
      <td> </td>
      <td>✔</td>
      <td> </td>
      <td> </td>
      <td>SIX加了, 相当于同时S和IX</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>死锁的检测与预防
    <ul>
      <li>死锁: 每个事务持有部分锁, 循环等待</li>
      <li>活锁: 有部分事务长期等待锁, 其他事务可以继续运行</li>
      <li>死锁的检测及其处理办法
        <ul>
          <li>等待图法</li>
          <li>超时死锁检测法
            <ul>
              <li>锁申请等待超时</li>
              <li>事务执行超时</li>
            </ul>
          </li>
          <li>时间戳死锁检测法: (时间戳反映事务已经执行的时间)当T要等待U持有的锁
            <ul>
              <li>等待-死亡方案: T比U老, T等待; U比T老, 则T被回滚</li>
              <li>伤害-等待方案: T比U老, U回滚; U比T老, T等待</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="数据库恢复技术">数据库恢复技术</h2>

<ul>
  <li>数据库恢复的含义: 在数据库遭受破坏后及时进行恢复的功能</li>
  <li>方法: 不同介质上冗余存储，利用冗余信息恢复</li>
  <li>常用措施: 数据转储, 日志, 数据库镜像</li>
  <li>数据库故障的分类
    <ul>
      <li>小型: 事务内部故障, 不影响系统</li>
      <li>中型: 系统停止, 磁盘不坏, 重启靠日志能恢复
        <ul>
          <li>系统故障</li>
          <li>外部影响</li>
        </ul>
      </li>
      <li>大型: 内存磁盘严重破坏, 需要彻底恢复
        <ul>
          <li>磁盘故障</li>
          <li>计算机病毒</li>
          <li>黑客入侵</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>数据库故障恢复三大技术
    <ul>
      <li>数据转储: 定期将数据库中的内容复制到其它存储设备中去的过程</li>
      <li>日志: 自动记载数据库中修改型操作的数据更新情况的文件</li>
      <li>数据库镜像: 整个数据库中的数据实时复制到另一个磁盘</li>
    </ul>
  </li>
  <li>数据转储
    <ul>
      <li>静态转储</li>
      <li>
        <p>动态转储: 修改前记录原值</p>

        <blockquote>
          <p>需要结合日志恢复(记录转储开始和结束点, 事务更新的对象和前后值, 事务结束状态)</p>
        </blockquote>
      </li>
      <li>海量转储</li>
      <li>增量转储</li>
    </ul>
  </li>
  <li>日志：
    <ul>
      <li>内容: 事务标识、更新对象、更新前的值 和/或 更新后的值; 每个事务执行情况; 其他</li>
      <li>组成: 日志记录 的序列, 并发时, 各个事务的日志是交错的</li>
      <li>作用: 确保原子性, 实现增量转储, 实现故障恢复</li>
      <li>记载原则: 操作执行的先后次序, 先写日志, 后修改数据库</li>
      <li>在日志中设置检查点的作用: 降低数据库故障恢复的开销, 到<code class="language-plaintext highlighter-rouge">&lt;CKPT&gt;</code>就可以结束恢复过程
        <ul>
          <li>停止接收新任务 -&gt; 等待当前所有事物提交或终止 -&gt; 刷新日志到磁盘</li>
          <li>写入<code class="language-plaintext highlighter-rouge">&lt;CKPT&gt;</code> -&gt; 刷新日志到磁盘</li>
          <li>继续接收新事务</li>
        </ul>
      </li>
      <li>事务的撤销（UNDO）与重做（REDO）</li>
      <li>UNDO日志
        <ul>
          <li>UNDO日志的内容
            <ul>
              <li>开始事务: <code class="language-plaintext highlighter-rouge">&lt;Start T&gt;</code></li>
              <li>提交事务: <code class="language-plaintext highlighter-rouge">&lt;Commit T&gt;</code></li>
              <li>放弃事务: <code class="language-plaintext highlighter-rouge">&lt;Abort T&gt;</code></li>
              <li>更新记录: <code class="language-plaintext highlighter-rouge">&lt;T, X, V&gt;</code>事务T修改了X, 原值是V</li>
            </ul>
          </li>
          <li>记载规则: 更新记录 先于 更新操作; 事务提交 先于 提交日志</li>
          <li>作用: 用于被放弃事务(故障时中断的事务)的撤消工作</li>
          <li>基于UNDO日志的故障恢复流程
            <ul>
              <li>从后向前扫, 对每一个<code class="language-plaintext highlighter-rouge">&lt;T, X, V&gt;</code>:
                <ul>
                  <li>若<code class="language-plaintext highlighter-rouge">&lt;Commit T&gt;</code>被扫到过, 则继续扫</li>
                  <li>否则将X改成V</li>
                </ul>
              </li>
              <li>日志尾部为所有未结束事务写入<code class="language-plaintext highlighter-rouge">&lt;Abort T&gt;</code>, 刷新日志</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>REDO日志
        <ul>
          <li>REDO日志的内容: 跟UNDO一样, 唯一不同: 更新记录<code class="language-plaintext highlighter-rouge">&lt;T, X, V&gt;</code>中记载的是更新后的值</li>
          <li>记载规则: 修改前, 必须有更新记录和事务提交记录</li>
          <li>作用: 已提交事务的重做工作</li>
          <li>基于REDO日志的故障恢复流程
            <ul>
              <li>确定所有已提交的事务</li>
              <li>从前向后扫, 对每条更新
                <ul>
                  <li>如果未提交, 继续扫</li>
                  <li>如果提交了, 写入新值</li>
                </ul>
              </li>
              <li>日志尾部为所有未结束事务写入<code class="language-plaintext highlighter-rouge">&lt;Abort T&gt;</code>, 刷新日志</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>UNDO/REDO日志
        <ul>
          <li>UNDO/REDO日志的内容: 跟UNDO一样, 唯一不同: 更新记录<code class="language-plaintext highlighter-rouge">&lt;T, X, V, W&gt;</code>中记载前与后的值</li>
          <li>记载规则: 修改前需要有更新记录</li>
          <li>作用: 兼有两者</li>
          <li>基于UNDO/REDO日志的故障恢复流程
            <ul>
              <li>根据提交记录, 确定事务是否被提交
                <ul>
                  <li>按照从后往前的顺序，撤消(undo)所有未提交的事务</li>
                  <li>按照从前往后的顺序，重做(redo)所有已提交的事务</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>恢复策略
    <ul>
      <li>小型: 未结束的事务的undo</li>
      <li>中型: 非正常终止: undo; 完成提交: redo</li>
      <li>大型: 先用后备副本恢复, 之后用日志undo + redo</li>
    </ul>
  </li>
</ul>

<h1 id="第六章第七章">第六章&amp;第七章</h1>

<ul>
  <li>
    <p>游标管理</p>

    <ul>
      <li>游标的作用: 集合量逐个取出后送入应用程序变量内供其使用</li>
      <li>
        <p>定义: 查询结果为多个元组时, 必须使用游标获取每个元组</p>

        <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /></pre></td><td class="code"><pre><span class="line">EXEC SQL <span class="keyword">DECLARE</span> <span class="keyword">cursor</span>-<span class="keyword">name</span> <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br /><span class="line">	subquery</span><br /><span class="line">	[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> ...... ]</span><br /><span class="line">	[ <span class="keyword">FOR</span> { <span class="keyword">READ</span> <span class="keyword">ONLY</span> |</span><br /><span class="line">		   <span class="keyword">UPDATE</span> [ <span class="keyword">OF</span> columnname, ...... ] } ] ;</span><br /></pre></td></tr></tbody></table>
      </li>
      <li>
        <p>打开: <code class="language-plaintext highlighter-rouge">EXEC SQL OPEN agent_dollars</code></p>
      </li>
      <li>
        <p>使用</p>

        <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /></pre></td><td class="code"><pre><span class="line">while (TRUE) {		/* loop to fetch rows */</span><br /><span class="line">    exec  sql  fetch agent_dollars</span><br /><span class="line">                     into :agent_id, :dollar_sum;</span><br /><span class="line"></span><br /><span class="line">    printf("%s %11.2fn", agent_id, dollar_sum);</span><br /><span class="line">}				/* end fetch loop */</span><br /></pre></td></tr></tbody></table>
      </li>
      <li>
        <p>关闭: <code class="language-plaintext highlighter-rouge">exec sql whenever not found goto finish</code>定义结束, <code class="language-plaintext highlighter-rouge">exec sql close agent_dollars</code>关闭游标</p>
      </li>
      <li>
        <p>可滚动游标的定义</p>

        <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /><span class="line">5</span><br /><span class="line">6</span><br /><span class="line">7</span><br /></pre></td><td class="code"><pre><span class="line">EXEC  SQL  <span class="keyword">DECLARE</span>  cursor_name</span><br /><span class="line">  [ INSENSITIVE ]  [ <span class="keyword">SCROLL</span> ]</span><br /><span class="line">  <span class="keyword">CURSOR</span>  [ <span class="keyword">WITH</span>  HOLD ]  <span class="keyword">FOR</span></span><br /><span class="line">    subquery  { <span class="keyword">UNION</span>  subquery }</span><br /><span class="line">    [ <span class="keyword">ORDER</span>  <span class="keyword">BY</span> ...... ]</span><br /><span class="line">  [ <span class="keyword">FOR</span>  <span class="keyword">READ</span>  <span class="keyword">ONLY</span>  |</span><br /><span class="line">    <span class="keyword">FOR</span>  <span class="keyword">UPDATE</span>  <span class="keyword">OF</span>  columnname ...... ];</span><br /></pre></td></tr></tbody></table>
      </li>
      <li>
        <p>在数据更新命令中的使用</p>

        <table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br /><span class="line">2</span><br /><span class="line">3</span><br /><span class="line">4</span><br /></pre></td><td class="code"><pre><span class="line">EXEC  SQL  FETCH</span><br /><span class="line">  [ { NEXT | PRIOR | FIRST | LAST |</span><br /><span class="line">    { ABSOLUTE | RELATIVE } value_spec } FROM ]</span><br /><span class="line">  cursor_name INTO ......;</span><br /></pre></td></tr></tbody></table>
      </li>
    </ul>
  </li>
  <li>
    <p>索引 (index)</p>

    <ul>
      <li>B+索引的数据结构: 定义秩为n
        <ul>
          <li>结点: 取$m\leq n$, 结点含有m个键$K_i$和m+1个指针$P_i$, 五花肉式存放,</li>
          <li>约束
            <ul>
              <li>叶节点: $\lfloor (n+1)/2\rfloor\leq m\leq n, P_i$指向$K_i$, $P_{m+1}$指向下一个叶子</li>
              <li>根结点: $1\leq m\leq n$; 内部结点: $\lceil (n-1)/2\rceil\leq m\leq n, P_i$均指向子树根节点</li>
            </ul>
          </li>
          <li>性质
            <ul>
              <li>非叶节点, 在$P_i$所指子树的任意关键字K, 有$K_{i-1}\leq K&lt; K_i$</li>
              <li>只有一个结点, 则根节点也是叶节点; 否则, 根节点跟内部节点类似</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>搜索算法
        <ul>
          <li>随机查找
            <ul>
              <li>结点上的关键字划分了值域, 层层向下在相应区间中搜索合适的叶节点, 最后在叶结点遍历搜索</li>
            </ul>
          </li>
          <li>区间查找
            <ul>
              <li>先找区间下限a, 之后在叶节点(类似链表)中遍历, 直到超过上限b</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="第八章关系数据库规范化理论">第八章:关系数据库规范化理论</h1>

<h2 id="概述">概述</h2>

<ul>
  <li>模式设计质量的评价指标
    <ul>
      <li>数据冗余度: 合理的数据冗余度</li>
      <li>插入/删除等更新异常: 没有插入和删除操作异常</li>
    </ul>
  </li>
  <li>关系的规范化
    <ul>
      <li>按照给定范式要求设计关系模式</li>
      <li>
        <p>范式: 对一个关系中允许存在的函数依赖的要求</p>

        <h2 id="规范化理论">规范化理论</h2>
      </li>
    </ul>
  </li>
</ul>

<h3 id="函数依赖fd">函数依赖（FD）</h3>

<ul>
  <li>函数依赖: 一个关系中 两组属性之间的 取值约束
    <ul>
      <li>表示: $X\to Y$: Y函数依赖于X</li>
      <li>直观: 在关系$R$中, 每个$X$的值都有唯一的一个$Y$值与之对应</li>
      <li>定义: 关系模式$R(U)$中, 关系$r$中元组$r_i$在$X$中的取值确定后, $Y$中取值必被确定, 则$X\to Y$</li>
      <li>$X$决定因素, $Y$依赖因素</li>
    </ul>
  </li>
  <li>发现函数依赖
    <ul>
      <li>直接根据语义</li>
      <li>根据取值对应关系
        <ul>
          <li>一一对应: $X\to Y, Y\to X$</li>
          <li>一多对应/多一对应: $Y\to X, X\to Y$</li>
          <li>多多对应: 没有</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>平凡函数依赖
    <ul>
      <li>非平凡函数依赖: $X\to Y, Y\not\subseteq X$, 默认是这个</li>
      <li>平凡函数依赖: 反之</li>
    </ul>
  </li>
  <li>完全函数依赖
    <ul>
      <li>完全函数依赖: $X\to Y, \forall X’\subset X, X’\not\to Y$, 则$X\overset{f}{\to}Y$</li>
      <li>部分函数依赖: $X\to Y, \exists X’\subset X, X’\to Y$, 则$X\overset{p}{\to}Y$</li>
    </ul>
  </li>
  <li>传递函数依赖
    <ul>
      <li>$X\to Y, Y\not\subset X, Y\not\to X, Y\to Z$, 则 $X\to Z$为传递函数依赖</li>
    </ul>
  </li>
  <li>Armstrong公理系统
    <ul>
      <li>基本规则
        <ul>
          <li>自反规则: $Y\subseteq X$, 则$X\to Y$</li>
          <li>增广规则: $X\to Y$, 则$XZ\to YZ$</li>
          <li>传递规则: $X\to Y\wedge Y\to Z$, 则$X\to Z$</li>
        </ul>
      </li>
      <li>扩充规则
        <ul>
          <li>分解规则: $X\to YZ$, 则$X\to Y\wedge X\to Z$</li>
          <li>合并规则: $X\to Y\wedge X\to Z$则$X\to YZ$</li>
          <li>伪传递规则:$X\to Y\wedge WY\to Z$, 则$WX\to Z$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>函数依赖的逻辑蕴含概念
    <ul>
      <li>F为关系模式R(U)的一个函数依赖集</li>
      <li>从已有的函数依赖出发, 利用公理系统可以推导出$X\to Y$, 则$F\vDash X\to Y$</li>
    </ul>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>函数依赖集F的闭包$F^+$: $F^+={X\to Y</td>
          <td>F\vDash X\to Y}$</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>函数依赖集的等价
    <ul>
      <li>可以互相推导出其中的函数依赖</li>
    </ul>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>属性集X在函数依赖集$F^+$上的闭包$X_F^+$: $X_F^+={A</td>
          <td>F\vDash X\to A}$</td>
        </tr>
      </tbody>
    </table>
    <ul>
      <li>[解题] 计算闭包
        <ul>
          <li>$X^+=X$</li>
          <li>不断重复: 对每一个F中的依赖$Y\to Z$, 若$Y\subseteq X^+$, 则$X^+ = X^+ \cup Z$</li>
          <li>直到不再变化</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>关键字
    <ul>
      <li>若$K\subseteq U$, $K\overset{f}{\to}U$, 则K是R的关键字</li>
      <li>主属性集: 所有关键字中的属性构成的集合</li>
      <li>非主属性集: 不属于任何一个关键字的属性构成的集合</li>
      <li>关键字与闭包: $K_F^+=U, \forall Z\subset F, Z_F^+\ne U$</li>
      <li>[解题] 寻找关键字
        <ul>
          <li>计算最小依赖集</li>
          <li>不断重复从U中删除属性, 直到其闭包不等X于U</li>
          <li>将得到一个关键字</li>
          <li>技巧
            <ul>
              <li>只在左边出现过的属性 属于 每一个关键字</li>
              <li>只在右边出现过的属性 不属于 任何一个关键字</li>
              <li>只需要对两边都有的属性尝试删除即可</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="与函数依赖有关的范式">与函数依赖有关的范式</h3>

<ul>
  <li>模式分解
    <ul>
      <li>分解结果: 子关系模式, 满足
        <ul>
          <li>$\textrm{Head}(R)=\bigcup^n\textrm{Head}(R_i)$</li>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>$F_i={X\to Y</td>
                  <td>X\to Y\in F^+ \wedge (X\cup Y)\in \textrm{Head}(R_i)}$</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
      <li>分解方法
        <ul>
          <li>找出所有不满足范式的依赖</li>
          <li>选择一个依赖, 设$X\overset{f}{\to}Y$为这个依赖, 则将这个依赖所在的关系R分解为
            <ul>
              <li>$R_1={X\cup Y, {X\to Y}}$</li>
              <li>$R_2={\textrm{Head}(R)-Y, F_2}$</li>
              <li>
                <table>
                  <tbody>
                    <tr>
                      <td>其中$F_2={A\to B</td>
                      <td>A\to B\in F^+\wedge (A\cup B)\subseteq \textrm{Head}(R_2)}$</td>
                    </tr>
                  </tbody>
                </table>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>1NF: 属性值不可分割, 全都满足</li>
  <li>2NF: 满足1NF, 每个非主属性都完全依赖于关键字
    <ul>
      <li>检查:
        <ul>
          <li>找到所有非主属性和所有候选关键字</li>
          <li>检查每一个非主属性A和每一个候选关键字K之间的函数依赖, 看看有没有部分依赖</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3NF: 满足2NF, 每个非主属性都不传递依赖于关键字
    <ul>
      <li>检查: 不满足3NF, 则必然存在下列情况之一, 其中$X\overset{f}{\to} Y$,$Y$是非主属性
        <ul>
          <li>X是某个关键字的真子集</li>
          <li>X不是关键字</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>BCNF: 满足1NF, 若$X\to Y$则X必含有该模式的关键字
    <ul>
      <li>检查: 每个函数依赖, 是否满足X含有关键字</li>
      <li>BCNF -&gt; 3NF</li>
    </ul>
  </li>
  <li>理解各级范式与数据冗余度、插入/删除异常的关系
    <ul>
      <li>插入删除异常: 3NF消除异常</li>
      <li>冗余: 2NF存在冗余, 3NF冗余较小</li>
    </ul>
  </li>
</ul>

<h3 id="多值依赖与第四范式">多值依赖与第四范式</h3>

<ul>
  <li>多值依赖: $X\to\to Y$
    <ul>
      <li>定义: 对X的一个取值, 存在一组Y与其对应; Y的取值与$U-X-Y$不相关</li>
      <li>成因: 两个一对多关系$C\to T$, $C\to L$, 其合并后T与L就是多值依赖</li>
      <li>平凡多值依赖
        <ul>
          <li>非平凡多值依赖: $U-X-Y$不为空集</li>
          <li>平凡多值依赖: 反之</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>多值依赖有关的推理规则(需要掌握)
    <ul>
      <li>求补规则: 若$X\to\to Y$, 则$U-X-Y\to\to Y$</li>
      <li>转换规则: 若$X\to Y$, 则$X\to\to Y$</li>
    </ul>
  </li>
  <li>4NF
    <ul>
      <li>定义: 若$X\to\to Y$是非平凡多值依赖, 则X必含有关键字</li>
      <li>特点: 函数依赖需要满足BCNF; 不是函数依赖的多值依赖只有平凡多值依赖</li>
    </ul>
  </li>
</ul>

<h2 id="规范化所引起的一些问题">规范化所引起的一些问题</h2>

<ul>
  <li>函数依赖的逻辑蕴涵: 函数依赖集的逻辑蕴含</li>
  <li>函数依赖集的等价: 可以互相推导出其中的函数依赖</li>
  <li>最小函数依赖集
    <ul>
      <li>与F等价的, 最小的集合</li>
    </ul>
  </li>
  <li>最小函数依赖集的计算算法
    <ul>
      <li>首先得到题目中的所有函数依赖, 分解成右端只有一个的依赖</li>
      <li>消除部分函数依赖: 右边相同, 左边更多; 左边含右</li>
      <li>消除冗余函数依赖: 能推导就是冗余</li>
      <li>合并依赖</li>
    </ul>
  </li>
  <li>无损联结性
    <ul>
      <li>设$\rho={R_1,\cdots,R_k}$是对$R$的一个分解</li>
      <li>如果对每个满足F的关系实例r都满足$r=\pi_{R_1}(r)\Join\cdots\Join\pi_{R_k}(r)$</li>
      <li>则$\rho$是无损联接分解</li>
      <li>充要条件($\rho={R_1,R_2}$)
        <ul>
          <li>$R_1\cap R_2\to (R_1-R_2)$ 或 $R_1\cap R_2\to (R_2-R_1)$</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>依赖保持性
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>表示$\pi_Z(F)={X\to Y</td>
              <td>X\to Y\in F^+\wedge (X\cup Y)\subseteq Z}$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>$F^+=(\pi_{R_1}(F)\cup\cdots\cup\pi_{R_1}(F))^+$</li>
    </ul>
  </li>
  <li>直接到3NF且满足无损联结性和依赖保持性的模式分解算法
    <ul>
      <li>计算最小依赖集, 代替FFF进行分解</li>
      <li>$S=\emptyset$</li>
      <li>对每一个函数$X\to Y$依赖进行
        <ul>
          <li>若在S中找不到子关系模式Z, 使得$X\cup Y\subseteq\textrm{Head}(Z)$</li>
          <li>X和Y合并成新的子关系模式, 加入S</li>
        </ul>
      </li>
      <li>如果R中的每个候选关键字K均不在S中, 则任选一个关键字, 其属性单独构成一个子关系模式, 加入S</li>
    </ul>
  </li>
  <li>从3NF到BCNF、4NF的分解方法
    <ul>
      <li>找不满足所求NF的函数依赖(多值依赖), 分解之</li>
    </ul>
  </li>
</ul>

<h1 id="第九章数据库设计">第九章:数据库设计</h1>

<h2 id="数据库设计概述">数据库设计概述</h2>

<ul>
  <li>数据库设计的基本任务
    <ul>
      <li>根据用户对象的信息需求、处理需求和数据库的支持环境（包括硬件、操作系统与DBMS）设计出数据模式</li>
    </ul>
  </li>
  <li>数据库的生命周期
    <ul>
      <li>需求分析: 数据库设计的第1阶段</li>
      <li>概念设计: 数据库设计的第2阶段</li>
      <li>逻辑设计: 数据库设计的第3阶段 &lt;—– DBMS模型</li>
      <li>物理设计: 数据库设计的第4阶段 &lt;—– 软件, 硬件和网络</li>
      <li>编码</li>
      <li>测试</li>
      <li>运行</li>
      <li>进一步修改</li>
    </ul>
  </li>
</ul>

<h2 id="数据库设计的需求分析">数据库设计的需求分析</h2>

<ul>
  <li>需求说明书
    <ul>
      <li>用户单位对数据的需求 -&gt;</li>
      <li>需求分析(确定数据库中保存信息的客观事物和相互关系) -&gt;
        <ul>
          <li>事物, 事物属性, 事物关系</li>
        </ul>
      </li>
      <li>需求分析说明书</li>
    </ul>
  </li>
</ul>

<h2 id="数据库的概念设计">数据库的概念设计</h2>

<ul>
  <li>数据库概念设计的过程
    <ul>
      <li>用户分解: 用户 -&gt; 功能独立的用户组</li>
      <li>视图设计: 根据用户需求设计视图</li>
      <li>视图集成: 局部视图*n -&gt; 全局视图</li>
    </ul>
  </li>
  <li>E-R模型: 实体，属性，联系</li>
  <li>EE-R模型: E-R + 嵌套（实体集属性）、继承</li>
</ul>

<h2 id="数据库的逻辑设计">数据库的逻辑设计</h2>

<ul>
  <li>从E－R模型和扩充E－R模型向关系模型的转换
    <ul>
      <li>实体集: 关系模式</li>
      <li>联系: 关系</li>
    </ul>
  </li>
  <li>对转换得到的关系模式进行规范化设计
    <ul>
      <li>根据给定的数据完整性约束发现函数依赖（最小函数依赖集）: 第八章内容</li>
      <li>关键字的计算: 第八章内容</li>
      <li>范式的判断及分解: 第八章内容, 至少满足3NF才行</li>
    </ul>
  </li>
</ul>

<h2 id="数据库的物理设计">数据库的物理设计</h2>

<ul>
  <li>索引: 将文件中的记录与其物理地址(即磁盘块)间建立一张对应关系表</li>
  <li>作用: 加速</li>
  <li>设计策略
    <ul>
      <li>在主关键字及外关键字上建立索引: 提速联接查询; 利于检查完整性</li>
      <li>读为主的关系应尽可能多地建立索引</li>
      <li>属性的等值查询所得到的结果元组数量较少，则可以考虑对该属性建立索引</li>
      <li>经常用于统计查询的属性建立索引</li>
    </ul>
  </li>
</ul>

<h1 id="答题解法">答题解法</h1>

<hr />

<ul>
  <li>基本概念表示: 图形内写名称
    <ul>
      <li>实体集: 矩形框</li>
      <li>属性: 椭圆
        <ul>
          <li>关键字: 椭圆, 属性名加下划线</li>
        </ul>
      </li>
      <li>联系: 菱形框</li>
    </ul>
  </li>
  <li>连线与标注
    <ul>
      <li>属性与实体: 无向线段, 一个实体&lt;-&gt;多个属性; 连线上标注 属性基数( , )</li>
      <li>联系上的属性: 无向线段, 一个联系&lt;-&gt;多个属性; 因联系而产生的属性</li>
      <li>实体与联系: 无向线段, 多个实体&lt;-&gt;多个联系; 连线上标注 参与基数( , )</li>
    </ul>
  </li>
  <li>其他
    <ul>
      <li>联系上有太多属性和实体, 可以把这个联系变成实体, 与实体的连线变成新的联系</li>
    </ul>
  </li>
</ul>

<h2 id="关系代数和关系演算">关系代数和关系演算</h2>

<h3 id="关系代数">关系代数</h3>

<ul>
  <li>解题步骤
    <ul>
      <li>确定查询目标（结果关系中的属性）</li>
      <li>明确查询条件</li>
      <li>选择从条件到目标的查找路径，并据此确定操作对象，即:
        <ul>
          <li>在操作过程中需要使用到那些关系?</li>
          <li>这些关系又是如何被联接成一个关系的?</li>
        </ul>
      </li>
      <li>关系的合并
        <ul>
          <li>根据步骤 3) 的分析结果进行关系的联接</li>
        </ul>
      </li>
      <li>元组的选择
        <ul>
          <li>根据步骤 2) 的分析结果(查询条件)进行元组的选择: 用不着的尽快投影掉, 夜长梦多警告</li>
        </ul>
      </li>
      <li>属性的指定
        <ul>
          <li>根据步骤 1) 的分析结果执行投影操作: 别tm漏属性啊啊啊啊啊啊</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>解题技巧
    <ul>
      <li>“所有A都…的B”, 用除法, 被除的对象应当先投影, 以免遗漏</li>
      <li>用公共属性查私有属性, 先笛卡尔积, 之后用选择, 条件设为同名属性取值相等, 最后投影</li>
      <li>正面难构造, 就构造反面, 然后用笛卡尔积减去反面</li>
      <li>最大值最小值, 例子: 取C中最大, C为key-value对
D := C
$M = C - \pi_{C.key,C.val}\sigma_{C.val &lt; D.val}(C\times D)$
原理: 每取值跟所有取值比较, 存在更大就会保留, 找出所有的非最大值, 之后减去</li>
      <li>同时满足多个条件, 则取交; 满足多个条件中的一个, 则取并</li>
      <li>联接可以实现”之一”的效果, 也可以实现相等关系</li>
      <li>差运算
        <ul>
          <li>当查询条件带有‘否定’语义，或者具有明显的‘排它性’的时候，通常需要使用两个子查询之间的‘差’运算</li>
          <li>‘差’运算的运算对象（关系）中，通常需要包含其关键字</li>
        </ul>
      </li>
      <li>“笛卡尔积/θ-连接/自然连接”的使用方法
        <ul>
          <li>都是关系的合并运算
            <ul>
              <li>笛卡尔积是基本运算，θ-连接和自然连接则是扩充运算, 请注意三者的结果关系的关系模式之间的区别</li>
            </ul>
          </li>
          <li>笛卡尔积
            <ul>
              <li>是实现跨不同关系表进行数据访问的基础, 在笛卡尔积的结果关系中，存在着很多无意义的结果元组，通常需要通过后续的选择运算过滤掉</li>
            </ul>
          </li>
          <li>θ-连接
            <ul>
              <li><strong>相邻的“笛卡尔积+选择运算”可以合并为一个θ-连接</strong></li>
            </ul>
          </li>
          <li>自然连接
            <ul>
              <li>如果连接条件是基于“两张表中的所有同名属性的相等比较”，可以将θ-连接进一步简写为自然连接</li>
            </ul>
          </li>
          <li>一般方法: 笛卡尔积+选择 or θ-连接
            <ul>
              <li>不存在同名属性，或者连接条件不是基于同名属性的相等比较</li>
              <li>在结果关系中可能存在同名属性，需要加以区别</li>
            </ul>
          </li>
          <li>常用方法: 自然连接
            <ul>
              <li>连接条件是隐含的（所有同名属性的相等比较）</li>
              <li>如果在两个关系之间存在多对‘同名属性’，而本次查询又不需要‘所有’的同名属性都相等，此时有两种选择:</li>
              <li>采用前述的一般方法来实现关系的合并</li>
              <li><strong>先对其中的一个关系执行投影运算</strong>，过滤掉其中不需要相等的那些同名属性，然后再使用自然连接运算</li>
            </ul>
          </li>
          <li>难点: 关系的自连接
            <ul>
              <li>使用<strong>赋值运算定义‘同质不同名’的两个中间关系</strong>(元组集合相同，但关系名不同)，当然也可以对中间关系中的属性进行重命名</li>
              <li>然后再使用前述的一般方法实现两个中间关系的合并</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>除
        <ul>
          <li>‘除’ 运算与‘联接’运算的区别</li>
          <li>我们将查询的结果关系称为‘目标对象’，用于定义查询条件的关系称为‘条件对象’</li>
          <li>在决定某个元组t是否属于结果关系时，
            <ul>
              <li>如果只需要从条件对象中找到<strong>一个元组</strong>c并使得查询条件成立，那么就直接使用‘联接’运算（包括笛卡尔积、θ-连接和自然连接）</li>
              <li>如果需要条件对象集中的<strong>所有元组</strong>都能使得查询条件成立，那么就使用‘除’运算</li>
            </ul>
          </li>
          <li>‘除’ 运算表达式的表示方法
            <ul>
              <li>被除数关系中必须包含目标对象和条件对象的<strong>关键字</strong></li>
              <li>除数关系中只含条件对象的关键字</li>
              <li>被除数和除数关系中<strong>不能含其它‘不必要’的多余属性</strong>, 先投影再除</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="关系演算-1">关系演算</h3>

<ul>
  <li>从关系代数进行转换
    <ul>
      <li>基于关系演算的数据查询表示</li>
      <li>投影
$\pi_{A_{1},A_{2},\cdots,A_{k}}(R)=\exists x_{k+1},x_{k+2},\cdots ,x_n(R(x_1,x_2,\cdots,x_n))$</li>
      <li>选择
$\sigma_F(R)=R(x_1,x_2,\cdots,x_n)\wedge F$
        <ul>
          <li>相等比较可以直接用常量代替: $\sigma_{x_1=’a’}(R)=R(‘a’,x_2,\cdots,x_n)\wedge F$</li>
        </ul>
      </li>
      <li>笛卡尔积
$R\times S = R(p)\wedge S(q)$</li>
      <li>$\theta$-联接
$R\underset{F}{\bowtie} S = R(p)\wedge S(q)\wedge F$</li>
      <li>自然联接
$R\bowtie S = R(x,y,z)\wedge S(t,u,v)$</li>
      <li>自联接, 重命名
$R(x, g_1)\wedge R(x, g_2)$</li>
      <li>除法
$R\div S=\forall y(S(y)\rightarrow R(x,y))$</li>
      <li>删除
$R-S = R(u)\wedge \neg S(u)$</li>
      <li>插入
$R\cup S = R(t)\vee S(t)$</li>
      <li>修改 = 删除再插入</li>
    </ul>
  </li>
  <li>直接构造: 不会玩
    <ul>
      <li>根据题目中的约束, 直接构造公式, 约束元组</li>
      <li>刚刚才学到的技巧：蕴含
        <ul>
          <li>之前说是除法嘛, 其实不仅仅是除法, 表示 任意-都/仅仅 都可以</li>
          <li>在全称量词后面, 使用蕴含, 记得把蕴含条件的多余变元先 存在掉, 只留下前面限定过的(之前有谓词/量词), 被蕴含的那个也是</li>
          <li>全称蕴含外面, 有必要的话, 再补一个谓词</li>
          <li>别TM在全称里面用 且, 根本不可能满足的</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="规范化设计">规范化设计</h2>

<h3 id="函数依赖">函数依赖</h3>

<ul>
  <li>找函数依赖: 随缘, 真的很迷, 不考虑常识, 做卷子的一点体会
    <ul>
      <li>一对多, 多-&gt;一应该有一个函数依赖</li>
      <li>一对一, 2个依赖妥妥的</li>
      <li>多值依赖: 两个一多, 这里可能会有一个多值依赖, 那两个一之间</li>
    </ul>
  </li>
  <li>最小依赖集
    <ul>
      <li>拆 -&gt; 消部分/平凡 -&gt; 消冗余(楞猜) -&gt; 合并</li>
    </ul>
  </li>
  <li>关键字
    <ul>
      <li>
        <p>只在左, 必在关键字; 只在右, 不在关键字; 都有, 挨个讨论</p>

        <h3 id="规范化设计-1">规范化设计</h3>
      </li>
    </ul>
  </li>
  <li>条件: 关键在于非主属性(不在任何关键字的属性)
    <ul>
      <li>不满足2NF: 非主属性依赖于一个关键字的子集</li>
      <li>不满足3NF: 非主属性依赖于一个关键字的子集 或 非主属性依赖于非关键字</li>
      <li>不满足4NF: 能找到多值依赖(非平凡)</li>
      <li>不满足BCNF: 任何依赖左边不是其关键字</li>
    </ul>
  </li>
  <li>注意!分解得到的新关系, 得重新找关键字和非主属性, 在判断满不满足更高要求的范式</li>
</ul>

<h2 id="事务和并发">事务和并发</h2>

<h3 id="能不能冲突串行">能不能冲突串行</h3>

<ul>
  <li>优先图: 顶点是事务, 有向边是优先关系</li>
  <li>找出全部对象, 对每个对象
    <ul>
      <li>列出所有对这个对象的操作, 看每一对相邻的操作</li>
      <li>有至少一个是写操作, 则构成一个优先关系, 优先图画一个有向边</li>
    </ul>
  </li>
  <li>
    <p>图中有向边有环, 则不能冲突串行化, 否则可以, 按照图中的偏序关系, 依次执行各个事务就得到可行的串行调度</p>

    <h3 id="能不能视图串行">能不能视图串行</h3>
  </li>
  <li>整一个串行调度出来, 一般按照每个对象谁先读, 定一个初步的优先关系</li>
  <li>三个条件, 若原调度视图等价于这个串行调度, 那就视图可串行
    <ul>
      <li>对每个对象, 哪个事务读初始值, 两个调度一样</li>
      <li>对每个事务的每次读, 两个调度的读取结果一样(指来自同一个事务的同一次写)</li>
      <li>对每个对象, 哪个事务最后写, 两个调度一样</li>
    </ul>
  </li>
</ul>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="大三第一学期" /><summary type="html"><![CDATA[数据库期末复习总结]]></summary></entry><entry><title type="html">机器学习导论总结</title><link href="http://localhost:4000/ppx123-web/2022/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/" rel="alternate" type="text/html" title="机器学习导论总结" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/"><![CDATA[<h1 id="机器学习期末复习总结">机器学习期末复习总结</h1>

<h2 id="第二章-基本术语和模型评估">第二章 基本术语和模型评估</h2>

<h3 id="任务">任务</h3>

<p>分类任务：标记为离散值</p>

<p>回归任务：标记为连续纸</p>

<p>聚类任务：标记为空值</p>

<h3 id="预测任务根据标记的完整情况">预测任务：根据标记的完整情况</h3>

<p>监督学习：所有示例有标记，分类、回归</p>

<p>无监督学习：所有实例没有标记，聚类</p>

<p>半监督学习：少量有标记，大量没有标记。</p>

<p>噪音标记学习：有标记，但不完全准确</p>

<h3 id="概念学习">概念学习</h3>

<p>假设空间：所有可能属性的组合</p>

<p>版本空间：与训练集一致的“假设集合”</p>

<p>归纳偏好：学习过程中对某种类型假设的偏好称作归纳偏好</p>

<p>No Free Lunch：总误差与学习算法无关</p>

<h3 id="模型评估与选择">模型评估与选择</h3>

<p>学习器在训练集上的误差称为训练误差或经验误差，在新样本上的误差称为测试误差或泛化误差。</p>

<h4 id="评估方法">评估方法：</h4>

<p>留出法：将数据集划分为两个互斥的集合</p>

<p>交叉验证法：将数据集划分为k个互斥子集，每次用k-1个子集的并作为训练集，余下的作为测试集，k常取10</p>

<p>自助法：从数据集有放回的随机采样m次、</p>

<p>自助法：数据集小，难以划分训练、测试集很有用；产生多个训练集，对集成学习有用</p>

<p>数据量足够，一般采用留出法和交叉验证</p>

<h4 id="性能度量">性能度量</h4>

<p>均方误差（MSE），错误率、精度，P，R，ROC(AUC)，$F_\beta$度量，代价敏感错误率。</p>

<p>ROC：</p>

<p>P：(Precision)查准率$\dfrac{TP}{TP+FP}$，预测结果正例中真实情况为正例占的比例</p>

<p>R：(Recall)查全率$\dfrac{TP}{TP+FN}$，真实情况正例中预测结果为正例占的比例</p>

<p>P-R曲线：P=R，平衡点，可用来度量P-R曲线有交叉的分类器性能的高低</p>

<p>$F_{\beta}=\dfrac{(1+\beta^2)\times P\times R}{(\beta^2\times P)+R}$,$F_\beta$度量，$\beta=1$，标准$F_1$度量。</p>

<p>比较检验（比较评价两个模型）：假设检验：二项检验、T-检验</p>

<p>偏差与方差</p>

<p>泛化误差可分解为方差、偏差与噪声之和</p>

<h2 id="第三章-线性模型">第三章 线性模型</h2>

<h3 id="回归任务掌握">回归任务（掌握）</h3>

<p>最小二乘法原理和推导</p>

<h3 id="二分类任务">二分类任务</h3>

<p>对数几率回归、线性判别分析的建模原理</p>

<p>线性判别分析</p>

<h3 id="多分类任务">多分类任务</h3>

<p>一对一</p>

<p>一对其余</p>

<p>多对多</p>

<h3 id="类别不平衡任务">类别不平衡任务</h3>

<p>欠采样、过采样、阈值移动</p>

<h2 id="第四章-决策树">第四章 决策树</h2>

<h3 id="决策树基本流程">决策树基本流程</h3>

<p>掌握决策树基本流程和原理</p>

<h4 id="基本流程">基本流程</h4>

<p>递归过程，当以下条件停止：</p>

<p>（1）当前节点包含的样本全部属于同一类别</p>

<p>（2）当前属性集为空，或所有样本在所有树性上取值相同</p>

<p>（3）当前节点包含的样本集合为空</p>

<h3 id="决策树算法的关键划分选择">决策树算法的关键：划分选择</h3>

<p>熟悉三种划分准则</p>

<h4 id="划分选择-信息增益">划分选择-信息增益</h4>

<p>信息熵：样本集合D中第k类样本所占的比例为$p_k,(k=1,2,…,|y|)$.
$
Ent(D)=-\sum\limits_{k=1}^{|y|}p_k\log_2{p_k}
$
$Ent(D)$表示集合的纯度  越小越纯</p>

<h4 id="信息增益">信息增益</h4>

<p>离散属性$a$，可能取值有$V$类，产生V个分支节点，第$v$个分支节点包含了D中所有在属性$a$上取值为$a^v$的样本，记为$D^v$。计算用属性a
$
Gain(D,a)=Ent(D)-\sum\limits_{v=1}^V\dfrac{|D^v|}{|D|}Ent(D^v)
$
选择$Gain(D,a)$最大的属性$a$来进行划分。</p>

<p>不足：若编号作为一个属性，信息增益一般远大于其他属性。信息增益指标偏好取值数目较多的属性</p>

<h4 id="基尼指数cart决策树">基尼指数——CART决策树</h4>

<p>C4.5：使用增益率，用属性的取值范围对信息增益做一个规范化。</p>

<p>基尼指数：$Gini(D)=1-\sum\limits_{k=1}^{|y|}p_k^2$.越小越纯</p>

<p>$Gini_index(D,a)=\sum\limits_{v=1}^V\dfrac{|D^v|}{|D|}Gini(D^v)$.选择使得$Gini_index(D,a)$最小的属性</p>

<h3 id="克服过拟合的问题剪枝处理">克服过拟合的问题：剪枝处理</h3>

<p>预剪枝 vs 后剪枝</p>

<p>原因：决策树容易过拟合</p>

<p>预剪枝：决策树生成过程中，对每个结点在划分前先进⾏估计，若当前结点的划分不能带来决策树泛化性能提升，则停⽌划分并将当前结点记为叶结点，其类别标记为训练样例数最多的类别。（边建树，边剪枝）（留出法，用一部分进行验证）</p>

<p>优点：降低过拟合风险，减少时间开销。缺点：欠拟合风险。</p>

<p>后剪枝：先建树，后剪枝</p>

<p>优点：欠拟合风险小 缺点：时间开销大</p>

<h3 id="处理多种类型数据连续与缺失值">处理多种类型数据：连续与缺失值</h3>

<p>了解基本原理</p>

<p>连续：连续属性离散化</p>

<p>缺失：Q1 划分 考虑一个属性时，仅使用当前属性无缺失样本学习</p>

<p>Q2：划分后样本的处理：将样本划分到每一个分支，赋予不同的权重</p>

<h3 id="决策树的变体多变量决策树">决策树的变体：多变量决策树</h3>

<p>了解基本原理</p>

<p>每一个非叶节点是一个线性分类器</p>

<h2 id="第五章-神经网络">第五章 神经网络</h2>

<h3 id="神经元模型熟悉">神经元模型：熟悉</h3>

<p>输入：来自其他n个神经云传递过来的输入信号。</p>

<p>处理：输入信号通过带权重的连接进行传递，神经元接收到总输入值将与神经元的阈值进行比较。</p>

<p>输出：通过激活函数的处理以得到输出。</p>

<h3 id="感知机与多层网络熟悉">感知机与多层网络：熟悉</h3>

<h4 id="感知机">感知机</h4>

<p>两层神经元组成，只能处理线性可分问题。</p>

<h4 id="多层前馈神经网络">多层前馈神经网络</h4>

<p>定义：每层神经元与下一层神经元全互联, 神经元 之间不存在同层连接也不存在跨层连接。</p>

<p>前馈：输入层接受外界输入, 隐含层与输出层神经 元对信号进行加工, 最终结果由输出层神经元输出。</p>

<h4 id="多层前馈网络表示能力">多层前馈网络表示能力</h4>

<p>只需要一个包含足够多神经元的隐含层，多层前馈神经网络就能以任意精度逼近任意复杂度的连续函数。</p>

<h4 id="多层前馈网络局限">多层前馈网络局限</h4>

<p>容易过拟合</p>

<p>如何设置隐层神经元的个数仍然是个未决问题</p>

<h4 id="缓解过拟合策略">缓解过拟合策略</h4>

<p>早停：在训练中，若训练误差降低，但验证误差升高，则停止训练。</p>

<p>正则化：在误差目标函数中增加一项描述网络复杂程度的部分，例如连接权重与阈值的平方和。($E=\lambda\dfrac{1}{m}\sum\limits_{k=1}^mE_k+(1-\lambda)\sum\limits_iw_i^2$)</p>

<h3 id="误差逆传播算法熟悉">误差逆传播算法：熟悉</h3>

<h4 id="bp算法">BP算法</h4>

<p>推导注意链式法则，计算输入层的变化时要对所有的$\beta_j$分别链式法则求和。</p>

<h5 id="标准bp算法">标准BP算法</h5>

<p>每次针对单个训练样例更新权值与阈值。</p>

<p>参数更新频繁，不同样例可能抵消们需要多次迭代。</p>

<h5 id="累计bp算法">累计BP算法</h5>

<p>优点：其优化的目标是最小化整个训练集上的累计误差$E=\dfrac{1}{m}\sum\limits_{k=1}^mE_k$.</p>

<p>缺点：读取整个训练集一遍才对参数进行更新，参数更新频率较低。</p>

<h5 id="实际应用">实际应用</h5>

<p>但在很多任务中，累计误差下降到一定程度后，进一步下降会非常缓慢，这时标准BP算法往往会获得较好的解，尤其当训练集非常大时效果更明显。</p>

<h3 id="全局最与局部最了解">全局最⼩与局部最⼩：了解</h3>

<p>跳出局部最小的策略</p>

<ol>
  <li>多组不同的初始参数优化</li>
  <li>模拟退火技术</li>
  <li>随机梯度下降</li>
  <li>遗传算法</li>
</ol>

<h3 id="其他常见神经网络了解">其他常见神经网络：了解</h3>

<p>RBF网络：是哟个径向基函数$\rho(x,c_i)=e^{-\beta_i||x-c_i||^2}$作为激活函数</p>

<p>ART:竞争学习，无监督学习</p>

<p>SOM网络：竞争型无监督学习</p>

<p>级联相关网络：将网络结构也作为学习目标</p>

<p>Elman网络:递归神经网络,有反馈.</p>

<h3 id="深度学习了解">深度学习：了解</h3>

<p>深层神经网络最为典型</p>

<p>训练方法:预训练+微调. 预训练:每次训练一层,微调:对整个网络进行微调训练</p>

<p>权共享 (CNN)</p>

<p>理解深度学习:特征工程 VS 特征学习或表示学习</p>

<p>特征工程:手工设计特征</p>

<p>特征学习:通过深度学习自动产生分类的特征</p>

<h2 id="第六章-支持向量机-svm">第六章 支持向量机 SVM</h2>

<h3 id="间隔与支持向量">间隔与支持向量</h3>

<p>寻找超平面将样本划分，找最中间的超平面。
$
\mathop{\arg\max}<em>{w,b} \dfrac{2}{||w||}<br />
s.t.\quad y_i(w^Tx_i+b)\geq 1,i=1,2.,…,m<br />
\Leftrightarrow<br />
\mathop{\arg\min}</em>{w,b} \dfrac{||w||^2}{2}<br />
s.t.\quad y_i(w^Tx_i+b)\geq 1,i=1,2.,…,m
$</p>

<h3 id="对偶问题">对偶问题</h3>

<p>拉格朗日乘子法
$
L(w,b,\alpha)=\dfrac{1}{2}||w||^2-\sum\limits_{i=1}^{m}\alpha_i(y_i(w^Tx_i+b)-1)
$
令$L$对$w,b$的偏导为0可得
$
w=\sum\limits_{i=1}^m\alpha_iy_ix_i,\sum\limits_{i=1}^m\alpha_iy_i=0
$
回代
$
\min_\alpha\quad \dfrac{1}{2}\sum\limits_{i=1}^m\sum\limits_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum\limits_{i=1}^m\alpha_i<br />
s.t.\quad \sum\limits_{i=1}^m\alpha_iy_i=0<br />
\alpha_i\geq 0,i=1,2,…,m.
$
最终模型
$
f(x)=w^Tx+b=\sum\limits_{i=1}^m\alpha_iy_ix_i^Tx+b
$
KKT条件
$
\alpha_i\geq 0<br />
y_if(x_i)\geq 1<br />
\alpha_i(y_if(x_i)-1)=0
$</p>

<h4 id="求解smo">求解SMO</h4>

<p>基本思路：不断执行如下</p>

<ol>
  <li>选取一对需要更新的变量$\alpha_{i},\alpha_j$.</li>
  <li>固定$\alpha_i,\alpha_j$以外的参数，求解对偶问题更新$\alpha_i,\alpha_j$.注意仅考虑两个变量，约束也视为两个变量的约束，其他视为常数，显然有闭式解。</li>
</ol>

<p>b通过支持向量来计算。（对任意支持向量$x_s$，$y_s(\sum\limits_{i=1}^m\alpha_iy_ix_i^Tx_s+b)=1$）</p>

<p>支持向量机解的稀疏性：训练后，模型仅与支持向量有关，及$\alpha_i$不等于0的对应的向量有关。</p>

<h3 id="核函数">核函数</h3>

<p>当空间不线性可分时，将样本从低维映射到一个更高维的特征空间。</p>

<p>样本$x$映射后$\phi(x)$，超平面$f(x)=w^T\phi(x)+b$。在模型中仅以内积的形式出现。</p>

<p>Mercer定理(充分非必要)：只要一个对称函数所对应的核矩阵半正定, 则它就能作为核函数来使用.
$
k(x_i,x_j)=\phi(x_i)^T\phi(x_j)
$</p>

<h4 id="常用的核函数"><strong>常用的核函数</strong></h4>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211225202119165.png" alt="image-20211225202119165" /></p>

<h3 id="软间隔与正则化">软间隔与正则化</h3>

<h4 id="软间隔">软间隔</h4>

<p>现实中, 很难确定合适的核函数使得训练样本在特征空间中线性可分; 同时一个线性可分的结果也很难断定是否是有过拟合造成的.</p>

<p>引入”软间隔”的概念, 允许支持向量机在一些样本上不满足约束.</p>

<p>基本想法：最大化间隔的同时, 让不满足约束的样本应尽可能少
$
\min_{w,b}\quad \dfrac{1}{2}||w||^2+C\sum\limits_{i=1}^ml_{0/1}(y_i(w^T\phi(x_i)+b)-1)
$
$l_{0/1}$是损失函数
$
l_{0/1}(z)=1, z &lt; 0
<br />
l_{0/1}(z)=0,otherwise
$
替代函数（因为0-1函数不连续）
$
l_{hinge(z)}=\max(0,1-z)
$
模型</p>

<p>原始问题
$
\mathop{\arg\min}<em>{w,b} \dfrac{||w||^2}{2}+C\sum\limits</em>{i=1}^m\max(0,1-y_i(w^T\phi(x_i)+b))<br />
s.t.\quad y_i(w^Tx_i+b)\geq 1,i=1,2.,…,m
$
对偶问题
$
\min_\alpha\quad \dfrac{1}{2}\sum\limits_{i=1}^m\sum\limits_{j=1}^m\alpha_i\alpha_jy_iy_jx_i^Tx_j-\sum\limits_{i=1}^m\alpha_i<br />
s.t.\quad \sum\limits_{i=1}^m\alpha_iy_i=0<br />
C\geq \alpha_i\geq 0,i=1,2,…,m.
$</p>

<h4 id="正则化">正则化</h4>

<p>$
\min_f\quad \Omega(f)+C\sum\limits_{i=1}^ml(f(x_i),y_i)
$</p>

<p>第一项是结构风险（描述模型的某些性质），第二项是经验风险（描述模型与训练数据的契合程度）</p>

<h3 id="支持向量回归">支持向量回归</h3>

<p>特点: 允许模型输出和实际输出间存在$2\epsilon$的偏差</p>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211225203203092.png" alt="image-20211225203203092" /></p>

<p>损失函数</p>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211225203230958.png" alt="image-20211225203230958" /></p>

<h3 id="核方法">核方法</h3>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211225203439450.png" alt="image-20211225203439450" /></p>

<p>推广：核LDA（线性模型中提到），核PCA</p>

<h2 id="第七章-贝叶斯分类器">第七章 贝叶斯分类器</h2>

<h3 id="掌握贝叶斯决策论">掌握贝叶斯决策论</h3>

<p>给定N个类别，令$\lambda_{ij}$代表将第$j$类样本误分类为第$i$类所产生的损失，</p>

<p>将样本$x$分到第$i$类的条件风险为：
$
R(c_i|\mathbf{x})=\sum\limits_{j=1}^N\lambda_{ij}P(c_j|\mathbf{x})
$
贝叶斯判定准则
$
h^<em>(\mathbf{x})=\mathop{\arg\min}_{c\in Y}R(c|\mathbf{x})
$
$h^</em>$成为被贝叶斯最优分类器，总风险成为贝叶斯风险，反应学习性能的理论上限。</p>

<h4 id="判别式-vs-生成式">判别式 vs 生成式</h4>

<h5 id="判别式">判别式</h5>

<p>直接对$P(c|\mathbf{x})$建模如决策树，BP神经网络，SVM</p>

<h5 id="生成式">生成式</h5>

<p>先对$P(\mathbf{x},c)$建模，再由次获得$P(c|\mathbf{x})$.
$
P(c|\mathbf{x})=\dfrac{P(\mathbf{x},c)}{P(\mathbf{x})}=\dfrac{P(c)P(\mathbf{x}|c)}{P(\mathbf{x})}
$
代表：贝叶斯分类器，（贝叶斯分类器$\neq$贝叶斯学习）</p>

<h3 id="熟悉极大似然估计">熟悉极大似然估计</h3>

<p>先假设某种概率分布形式，再基于训练样例对参数进行估计</p>

<p>设$P(x|c)$具有某种概率分布，参数$\theta_c$.</p>

<p>$\theta_c$对训练集D中第c类样本组成的集合$D_c$的似然为
$
P(D_c|\theta_c)=\prod_{x\in D_c}P(x|\theta_c)
$
连乘容易下溢，故通常使用对数似然LL
$LL(\theta_c)=\log{P(D_c|\theta_c)}=\sum_{x\in D_c}\log{P(x|\theta_c)}$</p>

<p>$\hat{\theta}_c=\arg\max_{\theta_c}{LL(\theta)}$</p>

<h3 id="熟悉朴素贝叶斯拉普拉斯修正">熟悉朴素贝叶斯（拉普拉斯修正）</h3>

<p>主要障碍：所有属性上的联合概率难以从有限训练样本估计获得</p>

<p>组合爆炸；样本稀疏</p>

<p>基本思路：假定属性独立
$
P(c|x)=\dfrac{P(c)P(x|c)}{P(x)}=\dfrac{P(c)}{P(x)}\prod_{i=1}^dP(x_i|c)
$</p>

<h4 id="估计">估计</h4>

<p>$P(c)=\dfrac{|D_c|}{|D|}$.</p>

<p>$P(x|c)$:</p>

<p>对离散属性，$D_{c,x_i}$表示$D_c$在第i个属性上取值为$x_i$的样本组成的集合，则$P(x_i|c)=\dfrac{|D_{c,x_i}|}{|D_c|}$.</p>

<p>对连续属性，考虑概率密度函数，假定$P(x_i|c)\sim N(\mu_{c,i},\sigma^2_{c,i})$.</p>

<h4 id="拉普拉斯修正">拉普拉斯修正</h4>

<p>若某个属性值在训练集中没有与某个类同时出现过，则直接计算会出现 问题，因为概率连乘将“抹去”其他属性提供的信息。</p>

<p>$P(c)=\dfrac{|D_c|+1}{|D|+N}$.$P(x_i|c)=\dfrac{|D_{c,x_i}|+1}{|D_c|+N_i}$.</p>

<h4 id="朴素贝叶斯分类器的使用">朴素贝叶斯分类器的使用</h4>

<p>若对预测速度要求高：预计算所有概率估值，使用时“查表”</p>

<p>若数据更替频繁：不进行任何训练，收到预测请求时再估值 (懒惰学习, lazy learning)</p>

<p>若数据不断增加：基于现有估值，对新样本涉及的概率估值进行修正 (增量学习, incremental learning)</p>

<h3 id="掌握半朴素贝叶斯">掌握半朴素贝叶斯</h3>

<p>基本思路：适当考虑一部分属性间的相互依赖信息</p>

<p>最常用策略：独依赖估计 (One-Dependent Estimator, ODE)</p>

<p>假设每个属性在类别之外最多仅依赖一个其他属性
$
P(c|x)\propto P(c)\prod_{i=1}^d P(x_i|c,pa_i)
$</p>

<h4 id="spode">SPODE</h4>

<p>假设所有属性都依赖于同一属性，称为“超父” (Super-Parent)， 然后通过交叉验证等模型选择方法来确定超父属性</p>

<h4 id="tan">TAN</h4>

<p>以属性间的条件”互信息”(mutual information)为边的权重，构建完全图，再利用最大带权生成树算法，仅保留强相关属性间的依赖性</p>

<h4 id="aode">AODE：</h4>

<p>尝试将每个属性作为超父构建 SPODE</p>

<p>将拥有足够训练数据支撑的 SPODE 集成起来作为最终结果
$
P(c|x)\propto \sum_{i=1,|D_{x_i}|\geq m’}^d P(c,x_i)\prod_{j=1}^d P(x_j|c,x_i)<br />
\hat{P}(c,x_i)=\dfrac{|D_{c,x_i}|+1}{|D|+N_i}<br />
\hat{P}(x_j|c,x_i)=\dfrac{|D_{c,x_i,x_j}|+1}{|D_{c,x_i}|+N_j}
$</p>

<h4 id="高阶依赖">高阶依赖</h4>

<p>需要充分的样本</p>

<h3 id="掌握贝叶斯网">掌握贝叶斯网</h3>

<h3 id="了解em算法">了解EM算法</h3>

<h2 id="第八章-集成学习">第八章 集成学习</h2>

<h3 id="个体与集成知道个体分类器的定义和集成学习的定义">个体与集成：知道个体分类器的定义和集成学习的定义</h3>

<p>集成学习通过构建并结合多个学习器来提升性能</p>

<h3 id="boosting知道boosting的思想和adaboost的实现">Boosting：知道Boosting的思想和adaboost的实现</h3>

<h4 id="boosting">Boosting</h4>

<p>个体学习器存在强依赖关系，串行生成，每次调整训练数据样本分布</p>

<h4 id="adaboost">AdaBoost</h4>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211226162942021.png" alt="image-20211226162942021" /></p>

<p>($Z_t$是规范化因子，保证权重之和是1)</p>

<p>基学习器的线性组合
$
H(x)=\sum_{t=1}^T\alpha_th_t(x)
$
最小化指数损失函数
$
l_{exp}(H|D)=E_{x\sim D}[e^{-f(x)H(x)}]
$</p>

<h5 id="注意事项">注意事项</h5>

<p>数据分布的学习：重赋权法，重采样法</p>

<p>重启动，避免训练过程过早停止，（8.5处，如果学习的分类器不佳）</p>

<h3 id="bagging与随机森林知道思想和实现的方式">Bagging与随机森林：知道思想和实现的方式</h3>

<p>个体学习器不存在强依赖关系</p>

<p>并行化生成</p>

<p>自助采样法</p>

<h4 id="bagging算法">Bagging算法</h4>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211226164842877.png" alt="image-20211226164842877" /></p>

<p>($D_{bs}$是自助采样产生的样本分布)</p>

<p>时间复杂度低 :</p>

<ol>
  <li>
    <p>假定基学习器的计算复杂度为O(m)，采样与投票/平均过程的复杂度 为O(s)，则bagging的复杂度大致为T(O(m)+O(s))</p>
  </li>
  <li>
    <p>由于O(s)很小且T是一个不大的常数</p>
  </li>
  <li>
    <p>因此训练一个bagging集成与直接使用基学习器的复杂度同阶</p>
  </li>
</ol>

<p>可使用包外估计</p>

<h4 id="包外估计">包外估计</h4>

<p>可以计算泛化误差等</p>

<h4 id="随机森林">随机森林</h4>

<p>采样的随机性，属性的随机性</p>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20211226165628669.png" alt="image-20211226165628669" /></p>

<h3 id="结合策略知道集中常用策略以及stacking的优缺点">结合策略：知道集中常用策略以及stacking的优缺点</h3>

<p>平均法：如加权平均法</p>

<p>投票法：绝对多数投票法和相对多数投票法</p>

<p>学习法：Stacking 先从初始数据集训练出初级学习器，然后”生成”一个新数据集用于训练次级学习器.</p>

<p>在训练阶段，次级训练集是利用初级学习器产生的，若直接用初级学习器 的训练集来产生次级训练集，则过拟合风险会比较大;因此一般是通过使用交叉验证或留一法这样的方式，用训练初级学习器未使用的样本来产生次级学习器的训练样本.</p>

<h3 id="多样性知道多样性扰动的几种办法">多样性：知道多样性扰动的几种办法</h3>

<h4 id="误差-分歧分解">误差-分歧分解</h4>

<p>$
E=\bar{E}-\bar{A}
$</p>

<p>($\bar{E}$表示个体学习器泛化误差的加权评分，$\bar{A}$表示个体学习器的加权分歧值。)</p>

<p>个体学习器精确性越高、多样性越大，则集成效果越好</p>

<h4 id="多样性增强方法">多样性增强方法</h4>

<p>数据样本扰动：</p>

<ol>
  <li>采样</li>
</ol>

<p>输入属性扰动：</p>

<ol>
  <li>随机子空间算法</li>
</ol>

<p>输出表示扰动：</p>

<ol>
  <li>翻转法：随机改变输入样本的标记</li>
  <li>输出调剂法：分类输出改为回归输出得到分类器</li>
  <li>ECOC法：多类任务分解为一系列两类任务来求解</li>
</ol>

<p>算法参数扰动：</p>

<ol>
  <li>负相关法：强制要求个体神经网络采用不同的参数</li>
  <li>不同的多样性增强机制同时使用</li>
</ol>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="大三第一学期" /><summary type="html"><![CDATA[机器学习导论期末复习总结，建议复习再多看看细节的概念]]></summary></entry><entry><title type="html">毛概总结</title><link href="http://localhost:4000/ppx123-web/2022/01/15/%E6%AF%9B%E6%A6%82/" rel="alternate" type="text/html" title="毛概总结" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/%E6%AF%9B%E6%A6%82</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/%E6%AF%9B%E6%A6%82/"><![CDATA[<h1 id="毛概复习">毛概复习</h1>

<p>[TOC]</p>

<h1 id="考试内容及复习方式">考试内容及复习方式</h1>

<p>名词解释：4pt  x 5   不需要答太多，也不能太少</p>

<p>简答题：10pt x 4       答要点</p>

<p>论述题：一道材料题，一道仅题干。需要观点，要点，结合实际。</p>

<p>1-7章 看ppt，教材均可，8-10 看ppt，11-13  看教材</p>

<p>注意课件中的侧重点</p>

<h1 id="第一章-第二节-毛泽东思想的主要内容和活的灵魂">第一章 第二节 毛泽东思想的主要内容和活的灵魂</h1>

<h2 id="毛泽东思想的主要内容">毛泽东思想的主要内容</h2>

<p>1.新民主主义革命理论：指明了新民主主义革命的对象、动力、领导力量、性质和前途等基本问题。</p>

<p>两个基本点： 一是关于中国资产阶级双重性的分析；二是关于中国革命主要形式是长期武装斗争的科学判断。</p>

<p>2.社会主义革命和社会主义建设理论</p>

<p>（1）社会主义革命理论：三大改造，社会主义现代化。——非暴力的社会主义革命新路。</p>

<p>（2）社会主义建设理论：尝试突破“苏联模式”的限制，探索中国社会主义的建设道路；社会主义矛盾理论、社会主义工业化道路、文化发展理论，等等。</p>

<p>3.革命军队建设和军事战略的理论</p>

<p>4.政治和策略理论</p>

<p>5.思想政治工作和文化工作理论</p>

<p>6.党的建设理论</p>

<h2 id="毛泽东思想活的灵魂">毛泽东思想活的灵魂</h2>

<p>贯穿于毛泽东思想各个组成部分的立场、观点和方法，是毛泽东思想的活的灵魂，</p>

<p>三个基本方面，即<strong>实事求是，群众路线，独立自主</strong>。</p>

<p>1.实事求是：党的思想路线是一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理</p>

<p>2.群众路线：一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动。</p>

<p>3.独立自主：坚持独立思考，走自己的路，就是坚定不移地维护民族独立、捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物。</p>

<h1 id="第二章-第二节-新民主主义革命的总路线和基本纲领">第二章 第二节 新民主主义革命的总路线和基本纲领</h1>

<h2 id="总路线的内容">总路线的内容</h2>

<p>1948年在《在晋绥干部会议上的讲话》提出：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命。</p>

<h2 id="新民主主义革命的动力">新民主主义革命的动力</h2>

<p>动力：人民大众，包括⽆产阶级、农⺠阶级、城市⼩资产阶级和 ⺠族资产阶级。</p>

<p>无产阶级是中国革命最基本的动力</p>

<p>农民是中国民主革命的主力军（中农20%、贫农70%）</p>

<p>小资产阶级是中国无产阶级可靠的同盟者</p>

<p>民族资产阶级也是中国革命的动力之一（两面性）</p>

<h2 id="革命的领导阶级是无产阶级">革命的领导阶级是无产阶级</h2>

<h2 id="新民主主义革命的性质和前途">新民主主义革命的性质和前途</h2>

<p>性质：资产阶级民主主义革命。</p>

<p>新民主主义革命已经成为世界无产阶级革命的一个重要组成部分；新民主主义革命的领导力量是中国无产阶级及其先锋队——中国共产党；</p>

<p>新民主主义革命的指导思想是马克思列宁主义；新民主主义革命的前途是通过新民主主义社会最终实现向社会主义的过渡。</p>

<h2 id="基本纲领">基本纲领</h2>

<p>新民主主义的政治纲领：推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义的共和国。</p>

<p>回答了：1.国体问题。2.政体问题。</p>

<p>新民主主义经济纲领：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业。</p>

<p>新民主主义的文化纲领：无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化。</p>

<h1 id="第三章-第三节-社会主义制度在中国的确立">第三章 第三节 社会主义制度在中国的确立</h1>

<p>1956年底我国对农业、手工业和资本主义工商业的社会主义改造基本完成，标志着中国历史上长达数千年的阶级剥削制度的结束，实现了我国社会由新民主主义向社会主义的转变，社会主义制度在我国初步确立，我国进入社会主义初级阶段。</p>

<h2 id="社会主义基本制度的确立及其理论根据">社会主义基本制度的确立及其理论根据</h2>

<p>社会主义经济制度的确立：社会主义改造的基本完成，以生产资料公有制为基础的社会主义基本经济制度已经建立起来。</p>

<p>社会主义政治制度的确立：第一届人大，《中华人民共和国宪法》。</p>

<p>人民代表大会制度这一根本政治制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度这些基本政治制度的确立，表明我国由一个新民主主义的国家转变为社会主义国家。</p>

<p>社会的阶级关系和主要矛盾发生根本变化：剥削阶级已经被消灭，工人阶级成为国家的领导阶级；人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾，成为国内的主要矛盾。</p>

<h2 id="重大意义">重大意义</h2>

<p>第一，社会主义基本制度的确立，为当代中国一切发展进步奠定了制度基础。</p>

<p>第二、社会主义制度的确立极大地提高了工人阶级和广大劳动人民的积极性和创造性，促进社会生产力的发展。</p>

<p>第三，社会主义基本制度的确立，初步显示了社会主义制度的优越性。</p>

<p>第四，中国社会主义基本制度的确立，使占世界人口四分之一的东方大国进入了社会主义社会，这是世界社会主义运动历史上又一个历史性的伟大胜利。</p>

<p>第五，在一个经济文化落后的东方大国中顺利地实现了从新民主主义到社会主义的转变，建立了社会主义的基本制度，是马克思列宁主义关于社会主义革命理论在中国正确运用和创造性发展的结果。</p>

<p>从新民主主义社会向社会主义社会过渡是一个历史发展的必然。中国共产党坚持马克思主义基本理论的指导，结合中国社会主义革命的具体实践，成功完成了“三大改造”的任务，实现了中国历史上最深刻最伟大的社会变革。为当代中国一切发展进步奠定了根本的政治前提和制度基础，实现了中华民族由近代不断衰落到根本扭转命运、持续走向繁荣富强的伟大飞跃。</p>

<h1 id="第四章-第二节-初步探索的意义和经验教训">第四章 第二节 初步探索的意义和经验教训</h1>

<h2 id="初步探索的意义">初步探索的意义</h2>

<p>巩固和发展了我国的社会主义制度</p>

<p>为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础</p>

<p>丰富了科学社会主义的理论和实践</p>

<h2 id="初步探索的经验教训">初步探索的经验教训</h2>

<p>必须把马克思主义与中国实际相结合，探索符合中国特点的社会主义建设道路。</p>

<p>必须正确认识社会主义社会的主要矛盾和根本任务，集中力量发展生产力。</p>

<p>必须从实际出发进行社会主义建设，建设规模和速度要和国力相适应，不能急于求成。</p>

<p>必须发展社会主义民主，健全社会主义法制。</p>

<p>必须坚持党的民主集中制和集体领导制度，加强执政党建设。</p>

<p>必须坚持对外开放，借鉴和吸收人类文明成果建设社会主义，不能关起门来搞建设。</p>

<p>总结：初步探索时期我们对如何建设社会主义的问题展开了重要的理论与实践探索，这一过程中既取得了宝贵的经验、也留下了深刻的教训，这些成功的经验与深刻的教训都构成了我们在继续推进中国特色社会主义的伟大历史征程中所必须要加以珍视的宝贵财富。不能采取形而上学的态度将改革开放前后两个历史时期割裂开来，这两个时期都是我们党领导人民进行社会主义建设的实践探索，是相互衔接、有机统一的整体。</p>

<h1 id="第五章-第二节-邓小平理论的基本问题和主要内容">第五章 第二节 邓小平理论的基本问题和主要内容</h1>

<h2 id="基本问题">基本问题</h2>

<p>什么是社会主义,怎样建设社会主义.</p>

<p>关键要认清社会主义的本质,社会主义本质:社会主义本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。</p>

<h2 id="主要内容">主要内容</h2>

<p>解放思想,实事求是													改革开放理论</p>

<p>社会主义初级阶段理论					 						社会主义市场经济理论</p>

<p>党的基本路线									 						“两手抓,两手都要硬”</p>

<p>社会主义根本任务的理论（发展生产力）			“一国两制”</p>

<p>“三步走”战略									 						中国问题的关键在于 党</p>

<h1 id="第七章-第二节-科学发展观的科学内涵和主要内容">第七章 第二节 科学发展观的科学内涵和主要内容</h1>

<h2 id="科学内涵">科学内涵</h2>

<p>科学发展观，第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。</p>

<p>1.推动经济社会发展是科学发展观的第一要义</p>

<p>2.以人为本是科学发展观的核心立场</p>

<p>3.全面协调可持续是科学发展观的基本要求</p>

<p>4.统筹兼顾是科学发展观的根本方法</p>

<h2 id="主要内容-1">主要内容</h2>

<p>加快转变经济发展方式。</p>

<p>发展社会主义民主政治。</p>

<p>推进社会主义文化强国建设。</p>

<p>构建社会主义和谐社会。</p>

<p>推进生态文明建设。</p>

<p>全面提高党的建设科学化水平。</p>

<h1 id="第八章-习近平新时代中国特社会主义思想及其历史地位">第八章 习近平新时代中国特⾊社会主义思想及其历史地位</h1>

<h2 id="第一节-习近平新时代中国特色社会主义思想创立的社会历史条件重点是新时代和大变局">第一节 习近平新时代中国特色社会主义思想创立的社会历史条件（重点是新时代和大变局）</h2>

<h3 id="中国特色社会主义新时代的变与不变">中国特色社会主义新时代的变与不变</h3>

<p>新的历史方位</p>

<p>我国社会的主要矛盾发生了变化</p>

<p>我国仍处于并将长期处于社会主义初级阶段的基本国情没有改变</p>

<p>我国仍是世界最大发展中国家的国际地位没有改变</p>

<p>共产党人“为中国人民谋幸福，为中华民族谋复兴”的初心和使命没有变</p>

<p>社会主要矛盾的变化：已转变为人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾。</p>

<h3 id="世界正经历百年未有之大变局">世界正经历百年未有之大变局</h3>

<p>世界经济版图之变，科技与产业之变，国际力量对比之变，全球治理之变（中西共治），人类前途命运之变，公共卫生安全之变。</p>

<h2 id="第三节-习近平新时代中国特色社会主义思想的历史地位">第三节 习近平新时代中国特色社会主义思想的<strong>历史地位</strong></h2>

<p>当代中国马克思主义、21世纪马克思主义</p>

<p>实现现中华民族伟大复兴的行动指南</p>

<p>建设美好世界的中国智慧和中国方案</p>

<h1 id="第九章-坚持和发展中国特色社会主义的总任务">第九章 坚持和发展中国特色社会主义的总任务</h1>

<h2 id="第二节-建成社会主义现代化强国的战略安排">第二节 建成社会主义现代化强国的战略安排</h2>

<p>第一个阶段，从2020年到2035年，在全面建成小康社会的基础上，再奋斗15年，基本实现社会主义现代化。</p>

<p>第二个阶段，从2035年到本世纪中叶；在基本实现现代化的基础上，再奋斗15年，把我国建成富强民主文明和谐美丽的社会主义现代化强国。</p>

<h2 id="第三节-建设社会主义现代化国家的战略导向">第三节 建设社会主义现代化国家的战略导向</h2>

<p>《中共中央关于制定国民经济和社会发展第十四个五年规划和二〇三五年远景目标的建议》（以下简称《建议》）</p>

<p>《建议》的核心要义是新发展阶段、新发展理念、新发展格局。</p>

<h3 id="新发展阶段">新发展阶段</h3>

<p>新发展阶段的基本特征：新的历史起点、发展不平衡不充分的问题仍然突出、高质量发展将成为发展主题、构建新发展格局的发展路径、推动改革向更深层次挺进。</p>

<h3 id="新发展理念">新发展理念</h3>

<p>新发展理念是在深刻分析国内外发展形势的基础上形成的，也是针对我国发展中的突出矛盾和问题提出来的。集中反映了我们党对经济社会发展规律认识的深化。</p>

<p>(1) 创新：创新是引领发展的第一动力。</p>

<p>1.创新的顶层设计。2.创新发展的现实依据。3.创新的理论基础。4.实施创新驱动发展战略的具体措施。</p>

<p>(2) 协调：协调是持续健康发展的内在要求，解决发展不平衡问题。</p>

<p>(3) 绿色：绿色是永续发展的必要条件。绿色发展，就其要义就是要解决好人与自然和谐共生问题。</p>

<p>(4) 开放：开放是国家繁荣发展的必由之路。</p>

<p>(5) 共享：共享是中国特色社会主义的本质要求。全民共享、全面共享、共建共享、剪进共享。</p>

<h3 id="新发展格局">新发展格局</h3>

<p>构建以国内大循环为主体、国内国际双循环相互促进的新发展格局。</p>

<h1 id="第十章-五位一体总布局">第十章 “五位一体”总布局</h1>

<h2 id="第一节-实现经济高质量发展">第一节 实现经济高质量发展</h2>

<h3 id="坚持习近平经济思想">坚持习近平经济思想</h3>

<p>坚持加强党对经济工作的集中统一领导 （首位）</p>

<p>坚持以人民为中心的发展思想  （经济发展的根本目的）</p>

<h4 id="实现高质量发展的途径ppt无书上的">实现高质量发展的途径（ppt无，书上的）</h4>

<p>坚持适应把握引领经济发展新常态</p>

<p>坚持使市场在资源配置中起决定性作用，更好发挥作用</p>

<p>坚持适应我国经济发展主要矛盾变化，完善宏观调控</p>

<p>坚持问题导向部署经济发展新战略</p>

<p>坚持正确工作策略和方法</p>

<h3 id="供给侧结构性改革">供给侧结构性改革</h3>

<h4 id="内涵">内涵</h4>

<p>供给侧结构性改革就是用改革的方法推进结构调整， 从生产端入手，减少无效和低端供给，提高扩大有效和中高端供给，增强供给侧结构对需求变化的适应性和灵活性，提高全要素生产率，推动我国经济朝着更高质量和更有效率的方向发展。</p>

<p>处理好四方面的关系：处理好政府和市场的关系，处理好加法和减法的关系，处理好短期和长期的关系， 处理好供给侧改⾰和需求侧管理的关系。</p>

<h4 id="背景">背景</h4>

<p>引领经济发展新常态</p>

<p>推动经济高质量发展</p>

<p>适应国际竞争新形势</p>

<h4 id="举措">举措</h4>

<p>推进增长动能转化，加快实施创新驱动战略。</p>

<p>深化要素市场化配置改革，由以价取胜转向以质取胜。</p>

<p>加大人力资本培育力度，调动和保护人的积极性。</p>

<p>激发各类市场主体活力，加快建设世界一流企业。</p>

<p>持续推进“三去一降一补”，优化市场供给结构。（去产能、去库存、去杠杆，降成本，补短板）</p>

<h2 id="第二节-发展社会主义民主政治">第二节 发展社会主义民主政治</h2>

<h3 id="坚持中国特色社会主义政治发展道路">坚持中国特色社会主义政治发展道路</h3>

<h3 id="健全人民当家做主制度体系">健全人民当家做主制度体系</h3>

<p>四梁八柱：人民代表大会制度，中国共产党领导的多党合作和政治协商制度，民族区域自治制度，基层群众自治制度。</p>

<p>⼈⺠代表⼤会制度是我国根本政治制度。</p>

<p>中国共产党领导的多党合作和政治协商制度、中国共产党领导的多党合作和政治协商制度、基层群众⾃治制度是我国的基本政治制度。</p>

<h3 id="巩固和发展爱国统一战线非主要">巩固和发展爱国统一战线（非主要）</h3>

<p>重要任务</p>

<p>1.坚持长期共存、互相监督、肝胆相照、荣辱与共，支持民主党派按照中国特色社会主义参政党要求更好履行职能。</p>

<p>2.深化民族团结进步教育，铸牢中华民族共同体意识。</p>

<p>3.全面贯彻党的宗教工作基本方针，坚持我国宗教的中国化方向。</p>

<p>4.牢牢把握大团结大联合的主题，做好统战工作。</p>

<h2 id="第三节-建设社会主义文化强国">第三节 建设社会主义文化强国</h2>

<h3 id="坚持马克思主义在意识形态领域指导地位的根本制度">坚持马克思主义在意识形态领域指导地位的根本制度</h3>

<h3 id="社会主义核心价值观">社会主义核心价值观</h3>

<p>与历史文化相契合</p>

<p>正在进行的奋斗相结合</p>

<p>与需要解决的时代问题相适应。</p>

<h4 id="做法">做法</h4>

<ol>
  <li>把社会主义核⼼价值观融⼊社会⽣活各个⽅⾯。</li>
  <li>坚持全⺠⾏动、⼲部带头，从家庭做起、从娃娃抓起。</li>
  <li>⽴⾜中华优秀传统⽂化和⾰命⽂化。</li>
</ol>

<h3 id="坚定文化自信繁荣发展社会主义文化">坚定文化自信，繁荣发展社会主义文化</h3>

<p>文化是一个国家、一个⺠族的灵魂，是人⺠的精神家园。</p>

<h3 id="ppt补充做法">（ppt补充）做法</h3>

<p>针对不同受众（差异化传播）</p>

<p>推动融合发展（新媒体）</p>

<p>选择新议题</p>

<p>加强内容建设</p>

<h3 id="推进社会主义文化强国建设">推进社会主义文化强国建设</h3>

<p>培养高度的文化自信。</p>

<p>提升公共⽂化服务⽔平。</p>

<p>健全现代文化产业体系。</p>

<p>提高国家文化软实力。</p>

<h2 id="第四节-加强以民生为重点的社会建设">第四节 加强以民生为重点的社会建设</h2>

<h3 id="发展中保障和改善民生提高保障和改善民生水平">发展中保障和改善民生（提高保障和改善民生水平）</h3>

<p>建设高质量教育体系</p>

<p>实施就业优先策略</p>

<p>优化收入分配结构</p>

<p>健全多层次社会保障体系</p>

<p>全面推进健康中国建设</p>

<h3 id="加强和创新社会治理">加强和创新社会治理</h3>

<p>社会治理目标是保护安全稳定，打基础谋长远。</p>

<h3 id="社会治理面临新挑战">社会治理面临新挑战</h3>

<p>各种风险交织。</p>

<p>国内社会矛盾和问题交织叠加。</p>

<p>社会阶层结构分化，贫富差距。</p>

<p>移动互联网时代的到来。</p>

<h3 id="加强和创新社会治理的举措">加强和创新社会治理的举措</h3>

<p>创新社会治理体系。</p>

<p>完善正确处理新形势下人民内部矛盾有效机制。</p>

<p>完善社会治安防控体系。</p>

<p>加强社会心理服务体系建设。</p>

<p>加强构建基层社会治理新格局。</p>

<h2 id="第十章思考题">第十章思考题</h2>

<h3 id="1如何准确把握习近平经济思想的主要内容">1.如何准确把握习近平经济思想的主要内容?</h3>

<h3 id="2供给侧结构性改革的背景内涵及对策">2.供给侧结构性改革的背景、内涵及对策?</h3>

<h3 id="3保障人民当家作主的制度体系包括哪些内容">3.保障人民当家作主的制度体系包括哪些内容?</h3>

<h3 id="4如何提升文化软实力建设中国特色的文化强国">4.如何提升文化软实力，建设中国特色的文化强国?</h3>

<h3 id="5如何加强制度建设推进共同富裕">5.如何加强制度建设推进共同富裕?</h3>

<p>改革初次分配制度，提升中低收入群体收入水平</p>

<p>完善再分配制度，将共享发展理念落到实处</p>

<p>发挥第三次分配的调节作用</p>

<h3 id="6如何加强和创新社会治理">6.如何加强和创新社会治理?</h3>

<h1 id="第十一章-第一节-全面建设社会主义现代化国家">第十一章 第一节 全面建设社会主义现代化国家</h1>

<h2 id="从全面建成小康社会到全面建设社会主义现代化国家">从全面建成小康社会到全面建设社会主义现代化国家</h2>

<p>全面建成小康社会是战略目标，在“四个全面”中居于引领地位；全面深化改革、全面依法治国、全面从严治党是三大战略举措，为如期全面建成小康社会提供重要保障。</p>

<h2 id="脱贫攻坚经验">脱贫攻坚经验</h2>

<p>坚持党的领导， 为脱贫攻坚提供坚强政治和组织保证。</p>

<p>坚持以人民为中心的发展思想，坚定不移的走共同富裕道路。</p>

<p>坚持发挥我国社会主义制度能够集中力量办大事的政治优势，形成脱贫攻坚的共同意志、共同行动。</p>

<p>坚持精准扶贫方略，用发展的办法消除贫困根源。</p>

<p>坚持调动广大贫困群众积极性、主动新、创造性，激发脱贫内生动力。</p>

<p>坚持弘扬和衷共济、团结互助美德，营造全社会扶危济困的浓厚氛围。</p>

<p>坚持求真务实、较真碰硬，做到真扶贫、扶真贫、脱真贫。</p>

<h2 id="中国社会主义现代化国家的基本特征">中国社会主义现代化国家的基本特征</h2>

<p>1.中国的现代化是人口规模巨大的现代化。</p>

<p>2.中国的现代化是全体人民共同富裕的现代化。</p>

<p>3.中国的现代化是物质文明和精神文明相协调的现代化。</p>

<p>4.中国的现代化是人与自然和谐共生的现代化。</p>

<p>5.中国的现代化是走和平发展道路的现代化。</p>

<h1 id="第十二章-第一节-坚持总体国家安全观">第十二章 第一节 坚持总体国家安全观</h1>

<h2 id="国家安全是安邦定国的重要基石">国家安全是安邦定国的重要基石</h2>

<h2 id="国家总体安全观">国家总体安全观</h2>

<p>总体国家安全观关键在“总体”，突出的是“大安全” 理念，涵盖诸多领域，而且随着社会发展不断拓展。</p>

<h2 id="坚持总体国家安全观的意义">坚持总体国家安全观的意义</h2>

<p>适应了进⾏具有许多新的历史特点的伟大斗争的新要求。</p>

<p>回应了人民对国家安全的新期待。</p>

<p>顺应了世界发展变化的新趋势。</p>

<h2 id="坚持走中国特色社会国家安全道路">坚持走中国特色社会国家安全道路</h2>

<p>坚持统筹发展和安全的两件大事。</p>

<p>坚持人民安全、政治安全、国家利益至上有机统一。</p>

<p>坚持维护和塑造国家安全。</p>

<p>坚持科学统筹的根本方法。</p>

<p>坚持党对国家安全工作的绝对领导。</p>

<h2 id="着力防范化解重大风险">着力防范化解重大风险</h2>

<p>加强战略预判和风险预警</p>

<p>坚持立足于防，又有效处置风险。</p>

<h1 id="第十三章-第二节-坚持走和平发展道路">第十三章 第二节 坚持走和平发展道路</h1>

<h2 id="坚持独立自主和平外交政策">坚持独立自主和平外交政策</h2>

<p>中国坚定不移地奉⾏独立自主的和平外交政策，坚持互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处五项原则，走和平发展道路。</p>

<h2 id="推动建设新型国际关系">推动建设新型国际关系</h2>

<p>新型国际关系，“ 新” 在相互尊重，“ 新” 在公平正义，特别是“ 新” 在合作共赢。</p>

<p>新型国际关系，核心是维护联合国宪章宗旨和原则，维护不干涉别国内政和尊重国家主权、独立、领土完整等国际关系基本准则，维护联合国及其安理会对世界和平承担的首要责任，开展对话、合作而不是对抗，实现双赢、共赢而不是单赢。</p>

<p>推动建设新型国际关系：</p>

<p>1.要坚决维护国家核⼼利益。</p>

<p>2.要在和平共处五项原则基础上发展，同世界各国的友好合作。</p>

<p>3.要积极参与全球治理体系改革和建设。</p>

<p>4.要加强涉外法律⼯作，完善涉外法律法规体系。</p>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="大三第一学期" /><summary type="html"><![CDATA[毛概期末总结]]></summary></entry><entry><title type="html">数据库期末复习</title><link href="http://localhost:4000/ppx123-web/2022/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="alternate" type="text/html" title="数据库期末复习" /><published>2022-01-15T00:00:00+08:00</published><updated>2022-01-15T00:00:00+08:00</updated><id>http://localhost:4000/ppx123-web/2022/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C</id><content type="html" xml:base="http://localhost:4000/ppx123-web/2022/01/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><![CDATA[<blockquote>
  <p>主体来自于Maxwell：https://maxwell-lyu.github.io/，在其基础上简单修改</p>
</blockquote>

<h1 id="计算机网络期末复习">计算机网络期末复习</h1>]]></content><author><name>Chaoyi Zhao</name><email>&lt;191870271@smail.nju.edu.cn&gt;</email></author><category term="大三第一学期" /><summary type="html"><![CDATA[数据库期末复习总结]]></summary></entry></feed>