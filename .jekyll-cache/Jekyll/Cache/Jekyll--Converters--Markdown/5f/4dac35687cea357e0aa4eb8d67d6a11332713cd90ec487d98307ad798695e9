I"<blockquote>
  <p>主体来自于Maxwell：https://maxwell-lyu.github.io/，在其基础上简单修改</p>
</blockquote>

<h1 id="计网复习">计网复习</h1>

<ul>
  <li>[重点]  1.x</li>
  <li>[概念]  3.2 3.3</li>
  <li>[重点]  3.5 3.6 3.7</li>
  <li>[重点]  4.2 4.3</li>
  <li>[重点]  5.2 5.3</li>
  <li>[概念]</li>
  <li>[重点]  CSMA/CD</li>
  <li>[概念]</li>
  <li>[概念]  9.x QoS相关内容</li>
</ul>

<p>距离向量算法，可能出现的问题</p>

<p>LS算法</p>

<p>TCP reno协议  三次握手，四次挥手</p>

<p>默写ALOHA</p>

<p>流媒体</p>

<p>CSMA/CA   CSMA/CD</p>

<p>了解：SDN，ICMP，网桥</p>

<h1 id="第一章">第一章</h1>

<h2 id="什么是因特网">什么是因特网</h2>

<h3 id="具体构成描述">具体构成描述</h3>

<ul>
  <li>主机 / 端系统: 与因特网相连的设备</li>
  <li>通信链路: 同轴电缆, 铜缆, 光纤, 无线电频谱</li>
  <li>分组交换机
    <ul>
      <li>路由器: 通常在网络核心</li>
      <li>链路层交换机: 通常在接入网</li>
    </ul>
  </li>
  <li>传输速率: 比特/秒 bps</li>
  <li>分组: 数据分段并加上首部字节(发送系统)</li>
  <li>路径: 分组经历的通信链路和分组交换机</li>
  <li>因特网服务提供商(ISP): 因特网接入服务</li>
  <li>协议: 控制因特网中信息的接收和发送
    <ul>
      <li>TCP: 传输控制协议</li>
      <li>IP: 网际协议</li>
    </ul>
  </li>
  <li>因特网标准: 由IETF研发</li>
  <li>RFC: 请求评论, 因特网标准文档</li>
</ul>

<h3 id="服务描述">服务描述</h3>

<ul>
  <li>分布式应用程序: 涉及到多个相互交换数据的端系统</li>
  <li>套接字接口: 规定了端系统上的程序, 请求因特网基础设施, 向另一个端系统上程序, 交付数据的方式</li>
</ul>

<h3 id="什么是协议">什么是协议</h3>

<ul>
  <li>协议定义了:
    <ul>
      <li>在两个或多个通信实体之间, 交换报文的格式和顺序</li>
      <li>报文发送和/或接收报文, 或其他事件, 所采取的动作</li>
    </ul>
  </li>
</ul>

<h2 id="网络边缘">网络边缘</h2>

<ul>
  <li>端系统: 运行应用程序</li>
  <li>P2S模型
    <ul>
      <li>客户端: 发送请求, 接受服务</li>
      <li>服务器: 响应请求, 提供服务, 始终在线, 性能更强</li>
    </ul>
  </li>
  <li>P2P模型
    <ul>
      <li>无专用服务器, 每设备既是客户端也是服务器</li>
    </ul>
  </li>
</ul>

<h3 id="接入网">接入网</h3>

<ul>
  <li>
    <p>接入网: 端系统物理连接到边缘路由器的网络</p>
  </li>
  <li>
    <p>边缘路由器: 端系统接入到远程端系统的第一台路由器</p>
  </li>
  <li>
    <p>接入链路与接入环境</p>

    <ul>
      <li>
        <p>家庭接入</p>

        <ul>
          <li>
            <p>拨号</p>

            <ul>
              <li>介质: 电话线, 有调制解调器, 执行的操作相当于给接入号(服务台)打个电话, 独占一个线路</li>
              <li>速率: 56kbps</li>
            </ul>
          </li>
          <li>
            <p>卫星: 1Mbps</p>
          </li>
          <li>
            <p>DSL: 数字用户线</p>

            <ul>
              <li>
                <p>介质: 电话线</p>
              </li>
              <li>
                <p>拓扑</p>

                <p><img src="C:\Users\zhaochaoyi\AppData\Roaming\Typora\typora-user-images\image-20211222112530253.png" alt="image-20211222112530253" /></p>
              </li>
              <li>
                <p>DSLAM: 数字用户线接入复用器, 位于中心局, 许多端系统共享</p>
              </li>
              <li>
                <p>频段分布</p>

                <ul>
                  <li>高速下行: 50kHz - 1MHz 12Mbps 55Mbps</li>
                  <li>中速上行: 4kHz - 50kHz 1.8Mbps 15Mbps</li>
                  <li>双向话音: 0 - 4kHz</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>HFC: 混合光纤同轴/电缆因特网接入</p>

            <ul>
              <li>
                <p>介质: 同轴电缆 + 光纤</p>
              </li>
              <li>
                <p>拓扑</p>

                <p><img src="C:\Users\zhaochaoyi\AppData\Roaming\Typora\typora-user-images\image-20211222112541475.png" alt="image-20211222112541475" /></p>
              </li>
              <li>
                <p>CMTS: 电缆调制解调器端接系统, 位于电缆头端</p>
              </li>
              <li>
                <p>速率: 42.8Mbps下行, 30.7Mbps上行</p>
              </li>
              <li>
                <p>有碰撞</p>
              </li>
            </ul>
          </li>
          <li>
            <p>FTTH: 光纤到户(PON: 被动光纤网络)</p>

            <ul>
              <li>
                <p>介质: 光纤</p>
              </li>
              <li>
                <p>拓扑</p>

                <p><img src="C:\Users\zhaochaoyi\AppData\Roaming\Typora\typora-user-images\image-20211222112605837.png" alt="image-20211222112605837" /></p>
              </li>
              <li>
                <p>ONT: 光纤网络端接器; OLT: 光纤线路端接器</p>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>企业(家庭)接入</p>

        <ul>
          <li>LAN
            <ul>
              <li>介质: 双绞线</li>
              <li>拓扑: 设备接入以太网交换机, 通过路由器接入因特网</li>
              <li>速率: 10Mbps 100Mbps, 1Gbps, 10Gbps</li>
            </ul>
          </li>
          <li>WiFi(802.11b/g/ac)
            <ul>
              <li>11Mbps, 54Mbps, 100Mbps+</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>广域无线接入: 通信运营商</p>

        <ul>
          <li>3G: 1Mbps</li>
          <li>4G LTE / WiMAX(淘汰): 10Mbps+</li>
          <li>5G: 20Gbps?</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="物理媒体">物理媒体</h3>

<ul>
  <li>导向型
    <ul>
      <li>双绞铜线</li>
      <li>同轴电缆(可用作共享媒体)</li>
      <li>光纤</li>
    </ul>
  </li>
  <li>非导向型
    <ul>
      <li>陆地无线电</li>
      <li>卫星无线电</li>
    </ul>
  </li>
</ul>

<h2 id="网络核心">网络核心</h2>

<h3 id="分组交换">分组交换</h3>

<ul>
  <li>数据切分成分组, 加首部</li>
  <li>每个分组发送时独占带宽</li>
  <li>交换机: 链路层交换机, 路由器</li>
  <li>存储转发传输
    <ul>
      <li>交换机先接收并存储整个分组, 之后再发出</li>
      <li>端到端时延(N个交换机, 分组长度L, 速率R): $d_{e2e}=N\frac{L}{R}$</li>
    </ul>
  </li>
  <li>排队时延和分组丢失
    <ul>
      <li>输出缓存/输出队列: 位于输出链路前</li>
      <li>拥塞: 分组排队等待链路</li>
      <li>排队时延: 入队到出队的时延</li>
      <li>分组丢失: 队列近满, 概率丢失; 队列满, 直接丢失</li>
    </ul>
  </li>
  <li>转发表和路由选择协议
    <ul>
      <li>转发表: 目的地址映射到输出链路</li>
      <li>路由选择协议: 自动设置转发表</li>
    </ul>
  </li>
</ul>

<h3 id="电路交换">电路交换</h3>

<ul>
  <li>预留资源, 需要建立连接/断开连接</li>
  <li>端到端连接: 专用电路, 恒定时延/速率, 稳定的性能</li>
  <li>电路交换中的复用
    <ul>
      <li>频分复用
        <ul>
          <li>分频段, 每个电路独占一个频率范围</li>
        </ul>
      </li>
      <li>时分复用
        <ul>
          <li>划分时隙, 每个电路轮流得到时隙</li>
          <li>统计时分复用: 划分时隙, 高数据率的源得到更多时隙</li>
        </ul>
      </li>
      <li>对比
        <ul>
          <li>电路: 时延固定</li>
          <li>分组: 时延不可预测, 共享带宽更高, 更简单有效成本低</li>
          <li>电路预先分配, 分组按需分配</li>
        </ul>
      </li>
      <li>虚电路
        <ul>
          <li>电路交换 + 分组交换</li>
          <li>虚电路建立时, 固定路由, 无需路由选择</li>
          <li>共享资源, 需要拥塞控制</li>
          <li>保证分组按序到达</li>
          <li>可预留资源, 可区别服务(有快有慢, 优先级等)</li>
          <li>需要连接建立和拆除</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="网络的网络">网络的网络</h3>

<ul>
  <li>粗略的层次结构
    <ul>
      <li>Tier-1 ISP与内容提供商</li>
      <li>区域ISP(与多个Tier-1相连)</li>
      <li>接入ISP: 接入网, 连接端系统和Tier-2 ISP</li>
      <li>IXP: 连接ISP, 可以来自不同级</li>
    </ul>
  </li>
</ul>

<h2 id="分组交换网中的时延丢包和吞吐量">分组交换网中的时延丢包和吞吐量</h2>

<h3 id="时延概述">时延概述</h3>

<ul>
  <li>处理时延: 节点检查首部, 决定转发, 进行校验的时间, 微秒-$d_{proc}$</li>
  <li>排队时延: 在链路前的队列等待传输, 微秒~毫秒,$d_{queue}$</li>
  <li>传输时延: $L/R$, 将所有比特推向链路的时间, 微秒~毫秒，$d_{tran}$.</li>
  <li>传播时延: $d/s$, 速度s略小于光速, 毫秒,$d_{prop}$.</li>
</ul>

<h3 id="排队时延和丢包">排队时延和丢包</h3>

<ul>
  <li>排队时延对不同的分组不相通, 以统计量衡量</li>
  <li>流量强度: $La/R$, $a$为分组到达的速率, 流量强度不能大于1。($a$是分组到达的速率，$L$是分组的长度,比特到达队列的平均速率是$La$ $bps$)</li>
  <li>流量强度增加, 平均排队时延迅速增加($x^2$)</li>
  <li>丢包
    <ul>
      <li>(上课提到)队列近满, 部分设备采取按照概率丢弃分组, 队列越长概率越大</li>
      <li>队列满, 再来就丢, 用丢包率衡量</li>
    </ul>
  </li>
</ul>

<h3 id="端到端时延">端到端时延</h3>

<ul>
  <li>$N-1$个路由器, 则端到端时延$d_{e2e}=N(d_{proc}+d_{trans}+d_{prop})$</li>
  <li>traceroute: ttl递增的一系列分组, 分别测试到第i跳的时延</li>
  <li>端系统, 应用程序和其他时延
    <ul>
      <li>向共享媒体传输的端系统, 有意延迟传输</li>
      <li>媒体分组化(AD-DA转换, 填充分组)延迟</li>
    </ul>
  </li>
</ul>

<h3 id="吞吐量">吞吐量</h3>

<ul>
  <li>瞬时吞吐量: 主机B接收的速率</li>
  <li>平均吞吐量: $F/T$, 文件大小除以传输时间</li>
  <li>瓶颈链路: 吞吐量是各个子链路吞吐量的最小值
    <ul>
      <li>因特网中, 吞吐量瓶颈在接入网</li>
    </ul>
  </li>
  <li>共享链路: 多个链路共享某一段链路, 则需要共享这个链路的吞吐量</li>
</ul>

<h2 id="协议层级及其服务模型">协议层级及其服务模型</h2>

<h3 id="分层的协议结构">分层的协议结构</h3>

<ul>
  <li>协议分层
    <ul>
      <li>每层向上提供服务， 各层所有协议称为协议栈</li>
      <li>PDU: protocol data units, 也就是分组(控制信息 + 数据)</li>
    </ul>
  </li>
  <li>因特网(TCP/IP)协议栈
    <ul>
      <li>应用层：网络应用程序及它们的应用层协议停留的地方
        <ul>
          <li>支持网络应用程序: FTP(端系统文件传输), SMTP(电子邮件报文传输), HTTP(Web文档请求和传送)</li>
          <li>信息分组: 报文</li>
        </ul>
      </li>
      <li>运输层：在应用程序端点之间传递报文
        <ul>
          <li>进程间数据传输: TCP, UDP</li>
          <li>信息分组: 报文段</li>
        </ul>
      </li>
      <li>网络层：负责将称为数据报的网络层分组从一台主机移动到另一台主机
        <ul>
          <li>路由数据报: IP</li>
          <li>信息分组: 数据报</li>
        </ul>
      </li>
      <li>链路层：沿着路径将数据报传递给下一个节点
        <ul>
          <li>在邻接的主机或路由器间传输: Ethernet, PPP</li>
          <li>信息分组: 帧</li>
        </ul>
      </li>
      <li>物理层：将该帧中的一个个比特从一个节点移动到下一个节点
        <ul>
          <li>线路上的比特</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>OSI模型
    <ul>
      <li>应用层: 应用访问OSI模型的环境</li>
      <li>表示层, 会话层: 并入应用层</li>
      <li>表示层：表示层的作用是使通信的应用程序能够解释交换数据的含义</li>
      <li>会话层：会话层提供了数据交换的定界和同步功能，包括了建立检 查点和恢复方案的方法</li>
      <li>运输层
        <ul>
          <li>端系统间通信</li>
          <li>可靠传输 或 单块传输</li>
          <li>连接建立, 维持, 释放</li>
        </ul>
      </li>
      <li>网络层
        <ul>
          <li>分组在多个网络或链路上传输</li>
          <li>编址, 路由, 转发, 拥塞控制</li>
          <li>连接建立, 维持, 拆除</li>
        </ul>
      </li>
      <li>数据链路层
        <ul>
          <li>链路层帧</li>
          <li>媒体访问控制, 差错检测和重传, 流量控制</li>
          <li>连接激活, 维持和失活</li>
        </ul>
      </li>
      <li>物理层
        <ul>
          <li>链路上的比特流</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="封装">封装</h3>

<ul>
  <li>封装: 分组 = 首部字段 + 有效载荷字段
    <ul>
      <li>应用层报文</li>
      <li>运输层报文段: 运输层首部(应用交付信息, 差错检测信息) + (分段的)应用层报文</li>
      <li>网络层数据报: 网络层首部(源目的地址等) + 运输层报文段</li>
      <li>链路层帧: 链路层首部 + 网络层数据报</li>
    </ul>
  </li>
</ul>

<h2 id="面对攻击的网络">面对攻击的网络</h2>

<ul>
  <li>攻击个人电脑
    <ul>
      <li>恶意软件
        <ul>
          <li>大多数都是自我复制的</li>
          <li>病毒: 需要某种形式的用户交互来感染用户设备</li>
          <li>蠕虫: 无需任何明显用户交互就能进入设备</li>
          <li>木马: 伪装成无害程序, 吸引用户点击</li>
          <li>后门: 绕过授权验证</li>
          <li>广告软件: 访问弹出广告</li>
          <li>间谍软件: 收集用户的输入, 记录用户活动</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>攻击服务器和网络基础设施
    <ul>
      <li>拒绝服务攻击DoS
        <ul>
          <li>使得服务不能由合法用户使用</li>
          <li>弱点攻击: 针对易受攻击的程序或操作系统, 引发停止运行或崩溃</li>
          <li>带宽洪泛: 大量发送分组到目标, 使链路拥塞</li>
          <li>连接洪泛: 创建大量半开或全开的TCP连接, 耗尽资源</li>
        </ul>
      </li>
      <li>分布式DoS(DDoS)
        <ul>
          <li>攻击者控制多个源</li>
          <li>僵尸网路: 攻击者用恶意软件控制大量计算机, 作为DDoS的源头等</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>嗅探分组
    <ul>
      <li>分组嗅探器: 记录每个流经的分组副本的被动接收机</li>
      <li>防范: 加密</li>
    </ul>
  </li>
  <li>伪装
    <ul>
      <li>IP欺骗: 将具有虚假源地址的分组注入因特网</li>
      <li>重放攻击</li>
      <li>中间人攻击</li>
      <li>连接劫持</li>
      <li>解决方案: 加密, 数字签名, MAC</li>
    </ul>
  </li>
</ul>

<h1 id="第三章">第三章</h1>

<h2 id="多路复用与多路分解">多路复用与多路分解</h2>

<ul>
  <li>多路分解: 将运输层报文段中的数据, 交付到正确的套接字的工作</li>
  <li>多路复用: 从套接字中收集数据, 加首部生成报文段, 将报文段传递到网络层</li>
  <li>套接字
    <ul>
      <li>具有唯一标识符</li>
      <li>报文段具有特殊字段(源端口号16bit, 目的端口号16bit), 指示需要交付到的套接字</li>
      <li>周知端口号: 0~1023</li>
    </ul>
  </li>
</ul>

<h3 id="无连接的多路复用与多路分解">无连接的多路复用与多路分解</h3>

<ul>
  <li>UDP套接字由二元组进行标识: 目的IP : 目的端口号</li>
  <li>源端口号: 回复时使用</li>
</ul>

<h3 id="面向连接的多路复用与多路分解">面向连接的多路复用与多路分解</h3>

<ul>
  <li>TCP套接字由四元组进行标识: 源IP : 源端口号 : 目的IP : 目的端口号</li>
  <li>不同来源的报文到达同一端口可区分, HTTP服务器</li>
</ul>

<h2 id="无连接运输udp">无连接运输UDP</h2>

<ul>
  <li>仅提供复用分解, 差错检测</li>
  <li>无连接: 发送报文段之前, 没有握手</li>
  <li>优点: 首部短, 时间灵活, 无连接建立, 无连接状态</li>
  <li>无拥塞控制, 可以由应用层构建可靠传输</li>
</ul>

<h3 id="报文段结构">报文段结构</h3>

<table>
  <thead>
    <tr>
      <th>源端口号</th>
      <th>目的端口号</th>
      <th>长度（首部+数据）</th>
      <th>检验和</th>
      <th>应用数据（报文）</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16 bit</td>
      <td>16 bit</td>
      <td>16 bit</td>
      <td>16 bit</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>UDP变长数据段</li>
  <li>检验和计算: UDP报文段 + IP首部的部分字段()</li>
</ul>

<h3 id="udp检验和">UDP检验和</h3>

<ul>
  <li>计算方法
    <ul>
      <li>报文段分为16bit字, 相加求和</li>
      <li>最高位进位回卷, 加到最低位</li>
      <li>取反码</li>
    </ul>
  </li>
  <li>检验方法: 接收方做前两步, 得到全1, 则没问题</li>
  <li>能检测, 不能纠错, 端到端差错控制</li>
</ul>

<h2 id="面向连接的运输tcp">面向连接的运输TCP</h2>

<ul>
  <li>提供差错检测, 重传, 累积确认, 定时器, 序号和确认号的首部字段</li>
  <li>全双工</li>
</ul>

<h3 id="tcp连接">TCP连接</h3>

<ul>
  <li>三次握手
    <ul>
      <li>客户发送</li>
      <li>服务端发送</li>
      <li>客户发送</li>
    </ul>
  </li>
  <li>MSS最大报文段长度(其实是应用层数据的最大长度): 根据 MTU(链路层)最大传输单元确定, 典型值1460字节（1500-40TCP/IP首部）</li>
</ul>

<h3 id="tcp报文段结构">TCP报文段结构</h3>

<table>
  <thead>
    <tr>
      <th>源端口号</th>
      <th>目的端口号</th>
      <th>序号</th>
      <th>确认号</th>
      <th>（第一堆）</th>
      <th>接收窗口</th>
      <th>因特网校验和 -紧急数据指针</th>
      <th>选项</th>
      <th>数据</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>16bit</td>
      <td>16bit</td>
      <td>32bit</td>
      <td>16bit</td>
      <td>16bit</td>
      <td>16bit</td>
      <td>16bit + 16bit</td>
      <td>0bit+</td>
      <td>-</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>第一堆里面有: 首部长度4bit(以字为单位, 1=4字节) + 保留未用6bit + (URG ACK PSH RST SYN FIN)标志字段6bit</p>
  </li>
  <li>
    <p>SYN FIN RST 用于连接建立和拆除, PSH代表必须立即将数据交给上层, URG与紧急数据指表示指向位置是紧急数据的最后一个字节, 需要通知上层</p>
  </li>
  <li>
    <p>序号和确认号</p>

    <ul>
      <li>
        <p>序号: 是该报文段的首字节的字节流编号</p>

        <blockquote>
          <p>单纯的ACK不包含数据字节, 因此不引发编号增加</p>
        </blockquote>
      </li>
      <li>
        <p>确认号: 表示这一序号之前的字节均被正确接收, 它和其后的未接收</p>

        <blockquote>
          <p>一个报文可以同时有确认号和序号, 是捎带ACK</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h3 id="往返时间的估计与超时">往返时间的估计与超时</h3>

<ul>
  <li>
    <p>估计往返时间</p>

    <ul>
      <li>
        <p>SampleRTT: 某一报文被发出(交给IP)到其确认被接收的时间量(一个来回)</p>

        <blockquote>
          <p>重传的报文不进行测量</p>
        </blockquote>
      </li>
      <li>
        <p>EstimatedRTT: 初始为第一个测得的SampleRTT, 之后根据下式更新 
\(\textrm{EstimatedRTT} = (1-\alpha)\cdot\textrm{EstimatedRTT} + \alpha \cdot \textrm{SampleRTT}\)</p>

        <blockquote>
          <p>指数移动加权平均</p>
        </blockquote>
      </li>
      <li>
        <p>DevRTT: RTT的偏差, 是Sample和Estimated的差的绝对值, 也用指数移动加权平均 
\(\textrm{DevRTT} = (1-\beta)\cdot\textrm{DevRTT} + \beta \cdot |\textrm{SampleRTT}-\textrm{EstimatedRTT}|\)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>设置和管理重传超时间隔</p>

    <ul>
      <li>重传间隔
        <ul>
          <li>默认初始值为1s</li>
          <li>超时后, 设为先前值的2倍</li>
          <li>若有新的EstimatedRTT, 立刻据下式更新 
\(\textrm{TimeInterval} = \textrm{EstimatedRTT} + 4\cdot \textrm{DevRTT}\)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="可靠数据传输">可靠数据传输</h3>

<ul>
  <li>
    <p>累积ACK</p>

    <ul>
      <li>ACK中的数字, 表示其之前的字节均被接收</li>
    </ul>
  </li>
  <li>
    <p>重传</p>

    <ul>
      <li>规则: 一个报文到达重传间隔, 仍未收到ACK(ACK&gt;SEQ+LEN), 则重传</li>
      <li>超时间隔加倍: 重传过后, 下一次的定时将会加倍;</li>
      <li>推算超时间隔: 若收到ACK或得到上层应用数据, 则又改为使用$\textrm{TimeInterval}$计算</li>
    </ul>
  </li>
  <li>
    <p>快速重传</p>

    <ul>
      <li>ACK生成策略
        <ul>
          <li>具有所期望序号的按序报文段到达。所有在期望序号及以前的数据都已经被确认：延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下  一个按序报文段在这个时间间隔内没有到达，则发送一个ACK</li>
          <li>具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输：立即发送单个累积ACK,以确认两个按序报文段</li>
          <li>比期望序号大的失序报文段到达。检测出间隔：立即发送冗余ACK，指示下一个期待字节的序号（其为间隔的低端 的序号）</li>
          <li>能部分或完全填充接收数据间隔的报文 段到达：倘若该报文段起始于间隔的低端，则立即发送ACK</li>
        </ul>
      </li>
      <li>收到3个冗余ACK, 则进行快速重传, 假定被ACK的报文后的报文全部丢失</li>
    </ul>
  </li>
  <li>
    <p>回退N步还是选择重传</p>

    <ul>
      <li>
        <p>第n个报文重传, 若之后的报文被缓存, 且其ACK及时到达, 那么后续可以不用重传</p>

        <blockquote>
          <p>这意味着TCP不是单纯的GBN, 而含有一部分SN</p>
        </blockquote>
      </li>
    </ul>
  </li>
</ul>

<h3 id="流量控制">流量控制</h3>

<ul>
  <li>
    <p>接收窗口</p>

    <ul>
      <li>
        <p>接收方跟踪</p>

        <ul>
          <li>
            <p>应用读取的最后一个字节的编号: LastByteRead</p>
          </li>
          <li>
            <p>接收到的最后一个字节的编号: LastByteRcvd</p>
          </li>
          <li>
            <p>接收缓存大小: RcvBuffer</p>
          </li>
          <li>
            <p>接收窗口大小: rwnd = RcvBuffer-(LastByteRcvd-LastByteRead)</p>

            <blockquote>
              <p>也就是缓存余量</p>
            </blockquote>
          </li>
          <li>
            <p>接收方将rwnd放入发给发送方的报文中</p>
          </li>
        </ul>
      </li>
      <li>
        <p>发送方跟踪</p>

        <ul>
          <li>
            <p>发送的最后一个字节的编号: LastByteSent</p>
          </li>
          <li>
            <p>被确认的最后一个字节的编号: LastByteAcked</p>
          </li>
          <li>
            <p>从接收到的报文中得到的rwnd</p>
          </li>
          <li>
            <p>需要始终保证 LastByteSent - LastByteAcked &lt;= rwnd</p>
          </li>
          <li>
            <p>若出现rwnd=0, 则需要继续发送含有一字节数据的报文</p>

            <blockquote>
              <p>为了防止接收方无数据要发, 引发发送端阻塞. 这个一字节的报文总会被ACK, 有机会获得一个非0的rwnd值</p>
            </blockquote>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="tcp连接管理">TCP连接管理</h3>

<ul>
  <li>建立: 三次握手</li>
</ul>

<table>
  <thead>
    <tr>
      <th>通信</th>
      <th>SYN</th>
      <th>是否有ACK</th>
      <th>ACK</th>
      <th>SEQ</th>
      <th>数据</th>
      <th>操作</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>客户-&gt;服务</td>
      <td>+</td>
      <td> </td>
      <td> </td>
      <td>client_isn</td>
      <td> </td>
      <td>客户端随机选择起始序号</td>
    </tr>
    <tr>
      <td>服务-&gt;客户</td>
      <td>+</td>
      <td>+</td>
      <td>client_isn+1</td>
      <td>server_isn</td>
      <td> </td>
      <td>服务器分配资源, 随机选择起始序号</td>
    </tr>
    <tr>
      <td>客户-&gt;服务</td>
      <td> </td>
      <td>+</td>
      <td>server_isn+1</td>
      <td>client_isn+1</td>
      <td>可携带</td>
      <td>客户端分配资源</td>
    </tr>
  </tbody>
</table>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20220102152227074.png" alt="image-20220102152227074" /></p>

<ul>
  <li>终止(以客户终止为例)</li>
</ul>

<table>
  <thead>
    <tr>
      <th>通信</th>
      <th>FIN</th>
      <th>SEQ</th>
      <th>是否有ACK</th>
      <th>ACK</th>
      <th>操作</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>客户-&gt;服务</td>
      <td>+</td>
      <td>client_isn</td>
      <td> </td>
      <td>server_isn</td>
      <td>客户发送FIN</td>
    </tr>
    <tr>
      <td>服务-&gt;客户</td>
      <td> </td>
      <td>server_isn</td>
      <td>+</td>
      <td>client_isn+1</td>
      <td>服务器ACK这个FIN, 之后还可以发数据(len)</td>
    </tr>
    <tr>
      <td>服务-&gt;客户</td>
      <td>+</td>
      <td>server_isn+len</td>
      <td> </td>
      <td>client_isn+1</td>
      <td>服务器发送FIN, 收到客户端的ACK后关闭, 释放资源</td>
    </tr>
    <tr>
      <td>客户-&gt;服务</td>
      <td> </td>
      <td>client_isn+1</td>
      <td>+</td>
      <td>server_isn+len+1</td>
      <td>客户端ACK这个FIN, 定时等待之后关闭, 释放资源</td>
    </tr>
  </tbody>
</table>

<p><img src="C:\Users\赵超懿\AppData\Roaming\Typora\typora-user-images\image-20220102152429848.png" alt="image-20220102152429848" /></p>

<ul>
  <li>防范SYN洪泛攻击
    <ul>
      <li>第二步的server_isn使用散列函数, 用源地址, 目的地址和端口号, 和一个只有服务器知道的散列函数</li>
      <li>第二步不分配资源</li>
      <li>第三步根据ACK里面的seq, 可以验证这个ACK是由先前的某个SYN生成的, 于是分配资源建立连接</li>
    </ul>
  </li>
  <li>拒绝通信
    <ul>
      <li>发送RST(RST标志位1)</li>
    </ul>
  </li>
</ul>

<h2 id="拥塞控制原理">拥塞控制原理</h2>

<ul>
  <li>一堆废话, 我只关心TCP</li>
</ul>

<h2 id="tcp拥塞控制">TCP拥塞控制</h2>

<ul>
  <li>
    <p>拥塞窗口cwnd</p>

    <ul>
      <li>对发送进行限制: LastByteSent - LastByteAcked &lt;= min(rwnd, cwnd)</li>
    </ul>
  </li>
  <li>
    <p>窗口与速率的关系: B = S(发出的包数量)/RTT(往返时间)</p>
  </li>
  <li>
    <p>TCP拥塞控制算法</p>

    <ul>
      <li>
        <p>总结</p>

        <ul>
          <li>ssthresh(慢启动阈值)变化: 丢包事件: ssthresh = cwnd / 2</li>
          <li>cwnd变化: 状态初始值
            <ul>
              <li>进入慢启动: cwnd = 1</li>
              <li>进入拥塞避免: cwnd = ssthresh</li>
              <li>进入快速恢复: cwnd = ssthresh + 3</li>
            </ul>
          </li>
          <li>cwnd变化: 增长方式
            <ul>
              <li>慢启动: 每个ACK, +1, 相当于每轮乘二</li>
              <li>拥塞避免: 每轮 +1</li>
              <li>快速恢复: 每个冗余ACK +1</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>慢启动</p>

        <ul>
          <li>初始: cwnd = 1 (MSS)</li>
          <li>加倍: 每一轮, cwnd加倍</li>
          <li>结束
            <ul>
              <li>超时, 取cwnd = 1, ssthresh = cwnd/2,重新慢启动</li>
              <li>到达ssthresh, 进入拥塞避免模式</li>
              <li>3个冗余ACK, ssthresh = cwnd/2, cwnd = cwnd/2+3, 快速重传后，进入快速恢复</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>拥塞避免</p>

        <ul>
          <li>线性增加: 每一轮, cwnd+1</li>
          <li>结束
            <ul>
              <li>超时, 取cwnd = 1, ssthresh = cwnd/2, 相当于慢启动，进入慢启动</li>
              <li>3个冗余ACK, ssthresh = cwnd/2, cwnd = cwnd/2+3, 进入快速恢复</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>快速恢复</p>

        <ul>
          <li>接下来收到的冗余ACK, cwnd都加1(之前的3个冗余ACK已经加过3, 至少加3)</li>
          <li>结束
            <ul>
              <li>收到期待的ACK（当对丢失报文段的一个ACK到达时）, 将cwnd = ssthresh, 进入拥塞避免</li>
              <li>超时, ssthresh = cwnd/2, cwnd = 1</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        <p>TCP拥塞控制: 回顾</p>

        <ul>
          <li>
            <p>TCP Tahoe: 没有快速恢复, 3个ACK也进入慢启动</p>
          </li>
          <li>
            <p>TCP Reno: 上文的方案</p>

            <blockquote>
              <p>加3根据协议不同, 看具体情况做<br />
慢启动: 其实是收到的每个ACK都加1, 因为ACK数等于发送数, 相当于翻倍</p>
            </blockquote>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>需要拥塞控制的原因: 浪费带宽</p>

    <ul>
      <li>速率接近容量 -&gt; 队列满 + 大排队时延</li>
      <li>大时延 -&gt; 不必要的超时重传</li>
      <li>队列满 -&gt; 丢包 -&gt; 浪费上游流量</li>
      <li>丢包 -&gt; 重传代价</li>
    </ul>
  </li>
</ul>

<h3 id="公平性">公平性</h3>

<ul>
  <li>TCP AIMD
    <ul>
      <li>相同的RTT: 公平, 最终会达到平均分配带宽</li>
      <li>RTT不同: RTT小的更快扩大窗口, 将得到更多带宽, 最终似乎与RTT成反比</li>
    </ul>
  </li>
  <li>UDP参与
    <ul>
      <li>UDP没有公平可言, 抢占资源</li>
      <li>UDP将挤压TCP资源</li>
    </ul>
  </li>
  <li>并行TCP
    <ul>
      <li>一个应用使用多个TCP连接, 就获得了多倍其应得的带宽</li>
    </ul>
  </li>
</ul>

<h3 id="网络辅助拥塞控制">网络辅助拥塞控制</h3>

<ul>
  <li>IP首部设置ECN(2比特, 4状态), 送到接收主机</li>
  <li>接收主机在TCP ACK中设置ECE, 发到发送主机</li>
  <li>发送主机减半cwnd, 并在下一个报文头中设置CWD, 发到接收主机</li>
</ul>

<h1 id="第四章">第四章</h1>

<h2 id="路由器工作原理">路由器工作原理</h2>

<ul>
  <li>输入端口
    <ul>
      <li>线路端接: 物理线路接入</li>
      <li>数据链路处理: 协议, 拆封</li>
      <li>查找转发排队: 查找转发表, 存帧排队</li>
    </ul>
  </li>
  <li>交换结构
    <ul>
      <li>经内存交换</li>
      <li>经总线交换</li>
      <li>经互连网络交换(纵横式)</li>
    </ul>
  </li>
  <li>输出端口: 排队, 数据链路处理, 线路端接</li>
  <li>路由选择处理器: 执行控制平面功能, 维护路由选择表和链路状态, 计算转发表
    <ul>
      <li>基于目的地转发: 仅考虑目的地</li>
      <li>通用转发: 考虑更多因素</li>
    </ul>
  </li>
</ul>

<h3 id="输入端口处理和基于目的地转发">输入端口处理和基于目的地转发</h3>

<ul>
  <li>转发表在输入端口有副本, 在输入端口本地做出转发决策</li>
  <li>前缀匹配
    <ul>
      <li>转发表不存储所有目的地址, 而是根据最长前缀匹配确定转发</li>
      <li>使用DRAM, SRAM, TCAM(三态内容可寻址存储器), 纳秒级</li>
    </ul>
  </li>
  <li>其他动作
    <ul>
      <li>出现物理层和链路层处理</li>
      <li>检查版本号, 检验和, 寿命, 重写后两个</li>
      <li>更新网络管理信息(如 计数器)</li>
    </ul>
  </li>
</ul>

<h3 id="交换">交换</h3>

<ul>
  <li>经内存交换: 输入卡处理地址查找和分组存储, 所有输入共享内存</li>
  <li>经总线交换
    <ul>
      <li>输入端口为分组计划一个交换机内部标签(首部)</li>
      <li>与首部匹配的输出端口存分组, 并去除标签</li>
    </ul>
  </li>
  <li>经互连网络交换
    <ul>
      <li>优点: 可以并行</li>
      <li>纵横式, N纵N横N*N交叉点</li>
      <li>非阻塞: 到不同输出端的分组不会互相阻塞</li>
    </ul>
  </li>
  <li>更复杂(去数据通信笔记看)
    <ul>
      <li>三级非阻塞网络</li>
    </ul>
  </li>
</ul>

<h3 id="输出端口处理">输出端口处理</h3>

<ul>
  <li>输出缓存, 数据链路处理(协议, 封装), 线路端接</li>
</ul>

<h3 id="何处出现排队">何处出现排队</h3>

<ul>
  <li>丢包: 没有缓存可以用来存储到达的分组</li>
  <li>输入排队
    <ul>
      <li>交换结构不足以使所有到达分组无时延地通过它传送</li>
      <li>HOL阻塞(线路前部阻塞): 被线路前部的一个分组阻塞, 例如两个分组发往一个目的地</li>
    </ul>
  </li>
  <li>输出排队
    <ul>
      <li>没有足够的内存存储到达的分组</li>
      <li>主动队列管理AQM
        <ul>
          <li>弃尾: 丢弃到达的分组</li>
          <li>也可以删除正在排队的部分分组</li>
          <li>向发送方提供阻塞信号</li>
        </ul>
      </li>
      <li>随机早期检测RED</li>
      <li>缓存大小: $B=\textrm{RTT}\cdot C/\sqrt{N}$, $C$为链路容量, $N$链路上的TCP流数量, $\textrm{RTT}$平均往返时延</li>
    </ul>
  </li>
</ul>

<h3 id="分组调度">分组调度</h3>

<ul>
  <li>先进先出FIFO 先来先服务FCFS
    <ul>
      <li>维护一个队列, 来了进入队尾, 队首挨个处理</li>
    </ul>
  </li>
  <li>优先权排队
    <ul>
      <li>每个优先权类有自己的队列, 各自FIFO</li>
      <li>不同优先级, 高的队列空了才处理低的</li>
      <li>非抢占: 已经开始的传输不会被打断</li>
    </ul>
  </li>
  <li>循环排队规则
    <ul>
      <li>多个队列, 不分优先级, 轮流提供服务</li>
      <li>保持工作排队规则: 有任何类的分组在等待, 则不允许链路保持空闲</li>
    </ul>
  </li>
  <li>加权公平排队
    <ul>
      <li>在循环排队的基础上加上优先级</li>
      <li>每一循环, 每个类得到多次服务, 次数与权重成正比</li>
    </ul>
  </li>
</ul>

<h2 id="网际协议">网际协议</h2>

<h3 id="ipv4数据报格式">IPv4数据报格式</h3>

<ul>
  <li>
    <p>数据报格式</p>

    <table>
      <tbody>
        <tr>
          <td>版本 4</td>
          <td>首部长度 4</td>
          <td>服务类型 8</td>
          <td>数据报长度16</td>
        </tr>
        <tr>
          <td>标识16</td>
          <td>标志 3</td>
          <td>片偏移13</td>
          <td> </td>
        </tr>
        <tr>
          <td>寿命 8</td>
          <td>上层协议 8</td>
          <td>首部检验和16</td>
          <td> </td>
        </tr>
        <tr>
          <td>(NoNAT)源地址32</td>
          <td> </td>
          <td> </td>
          <td> </td>
        </tr>
        <tr>
          <td>(NoNAT)目的地址32</td>
          <td> </td>
          <td> </td>
          <td> </td>
        </tr>
        <tr>
          <td>选项(可选)</td>
          <td> </td>
          <td> </td>
          <td> </td>
        </tr>
        <tr>
          <td>数据</td>
          <td> </td>
          <td> </td>
          <td> </td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>服务类型: 优先级(3bit), 可靠性(1bit, 一般/高), 时延(1bit, 一般/低), 吞吐量(1bit, 一般/高)</li>
      <li>标识, 标志, 片偏移: 与IPv4分片有关</li>
      <li>选项: 长度不定, 默认首部长度为20字节, 可变</li>
      <li>数据报长度: 首部加数据的长度, 字节为单位</li>
      <li>寿命: 经过一个路由器, 减1, 为0丢弃</li>
      <li>协议: 到达目的地才有用, 6-TCP, 17-UDP, 类似端口号</li>
    </ul>
  </li>
</ul>

<h3 id="ipv4数据报分片">IPv4数据报分片</h3>

<ul>
  <li>原因: 链路层最大传输单元MTU, 限制IP数据报的长度</li>
  <li>对数据报分片, 并设置标识等
    <ul>
      <li>标识: 每个数据报+1, 一个数据报的各个分片相同</li>
      <li>标志: 最后一个为0, 其他是1</li>
      <li>片偏移: 以64bit为单位</li>
    </ul>
  </li>
</ul>

<h3 id="ipv4编址">IPv4编址</h3>

<ul>
  <li>接口: 主机与物理线路的边界</li>
  <li>点分十进制记法: 192.168.0.255, 就这样的, 每个8位当作十进制数, 点分开</li>
  <li>地址分类:
    <ul>
      <li>A: 0开头/8</li>
      <li>B: 10开头/16</li>
      <li>C: 110开头/24</li>
    </ul>
  </li>
  <li>子网(IP网络): CIDR无类别域间路由选择
    <ul>
      <li>子网掩码: xxx.xxx.xxx.xxx/yy, yy为子网掩码,</li>
      <li>网络前缀: 地址的前yy位</li>
      <li>子网内的地址: 剩下的位数</li>
      <li>另一种表示: 前yy位为1, 剩下为0, 用点分十进制写出来</li>
      <li>路由聚合/路由摘要: 一个组织共享相同前缀</li>
    </ul>
  </li>
  <li>主机得到地址的过程
    <ul>
      <li>获取一块地址
        <ul>
          <li>来自ISP, ISP来自ICANN</li>
          <li>管理员划分这些地址给子网</li>
        </ul>
      </li>
      <li>获取主机地址: DHCP
        <ul>
          <li>所有的目的地址都是 255.255.255.255</li>
          <li>DHCP服务器发现: 新到达的主机发送DHCP发现报文
            <ul>
              <li>UDP目的端口67的报文</li>
              <li>目的: 255.255.255.255</li>
              <li>内容: 事务ID</li>
            </ul>
          </li>
          <li>DHCP服务器提供: 服务器的相应
            <ul>
              <li>UDP目的端口68（其它端口也行）的报文</li>
              <li>源: DHCP服务器地址</li>
              <li>内容
                <ul>
                  <li>事务ID, 推荐IP地址, 掩码, 地址租期</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>DHCP请求: 主机选择一个服务器, 相应
            <ul>
              <li>UDP端口67的报文</li>
              <li>源: 0.0.0.0</li>
              <li>内容: 回显配置信息, 事务ID+1</li>
            </ul>
          </li>
          <li>DHCP ACK: 确认配置
            <ul>
              <li>UDP端口68的报文</li>
              <li>源: DHCP服务器地址</li>
              <li>内容: 证实参数, 事务ID+1</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="网络地址转换nat">网络地址转换NAT</h3>

<ul>
  <li>NAT路由器: 它和它背后的网路对外界是一台单一的设备</li>
  <li>允许内部外部通信, 使用不同的地址</li>
  <li>NAT路由器将重写IP地址和端口号字段</li>
  <li>NAT转换表
    <ul>
      <li>内部地址:端口 - 外部地址:端口</li>
    </ul>
  </li>
  <li>NAT穿越: 解决内网服务器周知端口问题</li>
  <li>UPnP: 通用即插即用协议, 解决NAT自动配置</li>
  <li>跨越网络层和传输层</li>
</ul>

<h3 id="ipv6">IPv6</h3>

<ul>
  <li>
    <p>数据报格式</p>

    <table>
      <tbody>
        <tr>
          <td>版本 4</td>
          <td>流量类型 8</td>
          <td>流量标签 20</td>
        </tr>
        <tr>
          <td>有效载荷长度 16</td>
          <td>下一个首部 8</td>
          <td>寿命 8</td>
        </tr>
        <tr>
          <td>源地址 128</td>
          <td> </td>
          <td> </td>
        </tr>
        <tr>
          <td>目的地址 128</td>
          <td> </td>
          <td> </td>
        </tr>
        <tr>
          <td>数据</td>
          <td> </td>
          <td> </td>
        </tr>
      </tbody>
    </table>

    <ul>
      <li>首部定长40字节</li>
      <li>版本: 6</li>
      <li>流量类型: 与IP的服务类型字段类似</li>
      <li>流标签: 识别数据报的流, 用于优先权等</li>
      <li>有效载荷长度: 给出数据段的长度, 不含头部</li>
      <li>下一个首部 = 上层协议类型, 与IPv4的协议类型同值</li>
    </ul>
  </li>
  <li>
    <p>与IPv4的不同</p>

    <ul>
      <li>IPv6不允许由路由器进行分片, 因此没有分片3字段</li>
      <li>首部检验和: 运输层和数据链路层进行过检验, 因此丢掉</li>
      <li>选项: 不是标准IP的一部分了, 可能出现在”下一个首部”指定的地方</li>
    </ul>
  </li>
  <li>
    <p>从IPv4到IPv6</p>

    <ul>
      <li>隧道: IPv6数据报放入IPv4的有效载荷字段中, 上层协议41</li>
    </ul>
  </li>
</ul>

<h1 id="第五章">第五章</h1>

<h2 id="路由选择算法">路由选择算法</h2>

<ul>
  <li>路由选择算法: 从发送方到接收方, 确定一条通过路由器网络的好的路径</li>
  <li>图, 节点, 路径, 最低开销路径, 最短路径</li>
  <li>分类1
    <ul>
      <li>集中式路由选择算法(链路状态算法): 完整, 全局的网络知识, 计算源到目的的最低开销路径</li>
      <li>分散式路由选择算法(距离向量算法): 迭代, 分布式地计算出最低开销路径</li>
    </ul>
  </li>
  <li>分类2
    <ul>
      <li>静态路由选择算法: 变化很慢, 人工配置</li>
      <li>动态路由选择算法: 随着网络流量负载变化或拓扑发生变化而改变路由选择路径</li>
    </ul>
  </li>
  <li>分类3
    <ul>
      <li>负载敏感: 链路开销反映拥塞水平</li>
      <li>负载迟钝: 反之</li>
    </ul>
  </li>
</ul>

<h3 id="链路状态路由选择算法">链路状态路由选择算法</h3>

<ul>
  <li>算法流程
    <ul>
      <li>$u$源, $D(v)$从源到$v$的距离, $p(v)$到$v$的最短路上的下一个节点</li>
      <li>首先$D(v)$正无穷, 若有边设为边的开销</li>
      <li>每一轮, 找出$D(v)$中最小的一个$v$, 进行如下操作
        <ul>
          <li>用这个$D(v)$更新$v$的所有邻点的开销, 值为$D(v)$加边开销</li>
        </ul>
      </li>
      <li>直到不再变化</li>
    </ul>
  </li>
  <li>复杂性: $O(n^2)$</li>
  <li>出现的问题
    <ul>
      <li>同时运行LS算法的路由器</li>
      <li>链路选择的震荡, 由于一侧拥塞, 都选择另一侧, 而恰好使得这一侧也拥塞, 不断往返</li>
      <li>解决: 随机化发送链路通告的时间</li>
    </ul>
  </li>
</ul>

<h3 id="距离向量路由选择算法">距离向量路由选择算法</h3>

<ul>
  <li>算法流程: 对于每个节点
    <ul>
      <li>更新距离向量估计值, 当直接相连的链路开销发生变化, 或从邻居接收到距离向量的更新</li>
      <li>更新规则: 取最小值, 对所有$D_v(y)+c(x,v)$以及原有的距离, $v$是$x$的邻居</li>
    </ul>
  </li>
  <li>路由选择环路
    <ul>
      <li>无穷计数: 有环路的情况下, 链路代价的增加, 将会反复震荡, 长时间后才能达到稳定</li>
      <li>毒性逆转: 如果z通过y路由选择到x, 则z将通告y, z到x的距离是无穷大</li>
      <li>涉及到3个或更多节点的环路还是不能解决无穷计数</li>
    </ul>
  </li>
</ul>

<h2 id="算法比较">算法比较</h2>

<ul>
  <li>报文复杂性
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>LS: $O(</td>
              <td>N</td>
              <td> </td>
              <td>E</td>
              <td>)$</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>DV: 仅在新的链路开销导致与该链路相连节点的最低开销路径发生改变, 才传播开销</li>
    </ul>
  </li>
  <li>收敛速度
    <ul>
      <li>LS: 收敛块</li>
      <li>DV: 较慢, 还有无穷计数</li>
    </ul>
  </li>
  <li>健壮性
    <ul>
      <li>LS: 节点分别计算自己的最短路径, 一定程度健壮性</li>
      <li>DV: 一个节点的错误计算值, 扩散到整个网络</li>
    </ul>
  </li>
</ul>

<h2 id="因特网中自治系统内部的路由选择ospf">因特网中自治系统内部的路由选择OSPF</h2>

<ul>
  <li>自治系统AS
    <ul>
      <li>由处在相同管理控制下的路由器组成</li>
      <li>具有 自治系统内部路由选择协议</li>
      <li>具有 独有的AS编号 ASN</li>
    </ul>
  </li>
</ul>

<h3 id="开放最短路优先ospf">开放最短路优先OSPF</h3>

<ul>
  <li>是一种链路状态协议: 洪泛状态信息 + Dijkstra算法</li>
  <li>各个链路的开销: 管理员进行配置</li>
  <li>路由选择信息: 向全部路由器广播</li>
  <li>广播条件: 有链路状态发生变化 / 至少每30min一次</li>
  <li>报文: 直接由IP承担, 上层协议的值为89, 自己实现可靠传输和链路状态广播</li>
  <li>其他功能: 检查链路运行(发送OSPF HELLO), 获得相邻路由的链路状态数据库</li>
  <li>优点
    <ul>
      <li>安全: 鉴别报文防止伪造(使用口令或MD5), 序号防范重放攻击</li>
      <li>多条相同开销的路径: 允许使用多条路径</li>
      <li>单播与多播: MOSPF使用现有的链路数据库, 链路状态广播机制增加新型链路状态通告</li>
      <li>AS内层次结构: OSPF自治系统内部也可以配置多个区域, 运行自己的OSPF算法</li>
    </ul>
  </li>
</ul>

<h2 id="isp之间的路由选择bgp">ISP之间的路由选择BGP</h2>

<ul>
  <li>自治系统间路由选择协议</li>
  <li>边界网关协议: BGP</li>
</ul>

<h3 id="bgp的作用">BGP的作用</h3>

<ul>
  <li>BGP中, 分组不是路由到特定的地址, 而是路由到CIDR化的前缀</li>
  <li>协议提供的手段
    <ul>
      <li>从邻居AS获得前缀的可达性信息: 允许子网广播自己的存在</li>
      <li>确定到该前缀的”最好的”路由: 本地运行BGP路由选择过程, 基于策略和可达性信息</li>
    </ul>
  </li>
</ul>

<h3 id="通告bgp路由信息">通告BGP路由信息</h3>

<ul>
  <li>网关路由器: AS边缘的路由器, 直接连接到其他AS中的路由器</li>
  <li>内部路由器: 只连接了同一AS内的路由器</li>
  <li>BGP连接
    <ul>
      <li>在端口179的半永久TCP连接</li>
      <li>eBGP: 跨越AS的BGP连接</li>
      <li>iBGP: 相同的AS内的两台路由器的连接</li>
    </ul>
  </li>
  <li>传递可达信息: 不断重复 AS内广播, 网关传递到其他AS 的过程</li>
</ul>

<h3 id="确定最好的路由">确定最好的路由</h3>

<ul>
  <li>BGP属性: 路由器通告前缀时, 会在前缀中包括BGP属性
    <ul>
      <li>AS-PATH属性
        <ul>
          <li>每当前缀通过(离开)一个AS, (网关路由器)就在AS-PATH属性末尾, 加上自己的ASN</li>
          <li>若其中已有自己的ASN, 则拒绝该通告, 以防止环路</li>
          <li>于是, 接到这个通告的路由器, AS-PATH从头到尾恰为到达目标需要经过的AS的顺序</li>
        </ul>
      </li>
      <li>NEXT-HOP属性
        <ul>
          <li>是该AS-PATH起始路由器接口的IP地址, 也就是连接AS1, AS2的子网中, AS2网关路由器的地址</li>
        </ul>
      </li>
      <li>目的前缀属性</li>
      <li>更多</li>
    </ul>
  </li>
  <li>热土豆(烫手山芋)路由选择
    <ul>
      <li>不考虑AS-PATH, 只关注NEXT-HOP</li>
      <li>用内部路由协议确定, 所有的NEXT-HOP中, 开销最小的一个</li>
      <li>目的是尽快将分组送出AS, 如同烫手山芋</li>
    </ul>
  </li>
  <li>路由器选择算法
    <ul>
      <li>依次使用规则, 直到只剩一个
        <ul>
          <li>选择本地偏好最高的
            <ul>
              <li>路由被指派本地偏好(是BGP属性之一), 可由该路由器设置或学习到, 取决于网络管理员</li>
            </ul>
          </li>
          <li>选择最短AS-PATH的路由, 使用DV确定路径, 距离测度使用AS跳的跳数</li>
          <li>使用热土豆路由选择</li>
          <li>使用BGP标识选择</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="ip任播">IP任播</h3>

<ul>
  <li>访问某任播地址的请求, 到达一系列主机中的一个</li>
  <li>CDN
    <ul>
      <li>多台服务器, 相同IP地址, 都用BGP通告各自的IP地址</li>
      <li>路由器将认为收到的多个通告, 是到达同一服务器的不同路径(其实是不同的服务器, 只是配置为相同的服务)</li>
      <li>客户请求时, 路由器将路由到”较近”的CDN服务器</li>
    </ul>
  </li>
  <li>DNS
    <ul>
      <li>根服务器13个地址, 每个地址有许多镜像</li>
      <li>类似CDN, 可以让DNS请求到达”最近的”镜像</li>
    </ul>
  </li>
</ul>

<h3 id="路由选择策略">路由选择策略</h3>

<ul>
  <li>选择的路由通告策略
    <ul>
      <li>ISP协商等, 确定BGP通告规则, 拒绝某些通告, 尽管这些通告能够提供有效的路径</li>
      <li>例如BC直连, 另有BXC路线, X可以选择拒绝通告B和C自己能到达C或B, 以达到不转发BC流量的目的</li>
    </ul>
  </li>
</ul>

<h3 id="拼装在一起-在因特网中呈现">拼装在一起: 在因特网中呈现</h3>

<ul>
  <li>[木大警告] 这节不知道在讲什么玩意, 全是例子</li>
</ul>

<h2 id="因特网控制报文协议icmp">因特网控制报文协议ICMP</h2>

<ul>
  <li>ICMP在IP之上, 位于IP分组的有效载荷字段, 上层协议字段为1</li>
  <li>字段
    <ul>
      <li>类型</li>
      <li>编码</li>
      <li>引发该ICMP报文生成的IP数据报的首部, 及其前8字节</li>
    </ul>
  </li>
  <li>详细
    <ul>
      <li>0-0: PING回显</li>
      <li>3-[0~3]: 目的[网络/主机/协议/端口]不可达</li>
      <li>3-[6-7]: 目的[网络/主机]未知</li>
      <li>4-0: 源抑制</li>
      <li>8-0: PING请求</li>
      <li>9-0: 路由器通告</li>
      <li>10-0: 路由器发现</li>
      <li>11-0: TTL过期</li>
      <li>12-0: IP首部损坏</li>
    </ul>
  </li>
  <li>例子
    <ul>
      <li>PING: 类型8编码0, 回显: 类型0编码0</li>
      <li>ICMP源抑制: 网络层拥塞控制, 然而TCP有了, 废物一件</li>
      <li>TRACEROUTE
        <ul>
          <li>利用报文过期的ICMP的TTL过期报文(内含路由器的地址和名字)</li>
          <li>每个包的目的端口号都不可达, 使用ICMP的目的端口不可达报文, 确定探索结束</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>IPv6新的ICMPv6
    <ul>
      <li>分组太大</li>
      <li>未被承认的IPv6选项</li>
    </ul>
  </li>
</ul>

<h1 id="第六章">第六章</h1>

<h2 id="多路访问链路和协议">多路访问链路和协议</h2>

<ul>
  <li>广播链路: 多点, 一个信道</li>
  <li>碰撞: 多个结点同时发送</li>
</ul>

<h3 id="信道划分协议">信道划分协议</h3>

<ul>
  <li>时分复用TDM
    <ul>
      <li>时隙slot, 每轮每结点一个时隙</li>
      <li>速率: R/N, 负载不均衡时浪费, 统计时分复用解决, 有额外开销</li>
    </ul>
  </li>
  <li>频分复用FDM
    <ul>
      <li>分频率, 一人一频</li>
      <li>速率: R/N, 负载不均衡时浪费</li>
    </ul>
  </li>
  <li>码分多址CDMA
    <ul>
      <li>每结点一个编码, 1电平为此编码, 0为编码取反</li>
      <li>速率: R, 可同时发送(每个结点的编码必须线性不相关), 抗干扰</li>
    </ul>
  </li>
</ul>

<h3 id="随机接入协议">随机接入协议</h3>

<ul>
  <li>
    <p>时隙ALOHA</p>

    <ul>
      <li>有ACK</li>
      <li>前提: 每帧长L, 每时隙L/R, 结点同步, 且在时隙开始时才传输, 碰撞检测够快</li>
      <li>流程
        <ul>
          <li>发送: 结点在一个时隙开始发送帧
            <ul>
              <li>成功: 若没检测到碰撞, 则认为成功传输</li>
            </ul>
          </li>
          <li>失败: 检测到碰撞, 在之后的时隙中以概率p不断尝试重传, 直到没有碰撞</li>
        </ul>
      </li>
      <li>效率: 取p=1/N时最大化, 当N趋于无穷时, 效率为1/e</li>
    </ul>
  </li>
  <li>
    <p>ALOHA</p>

    <ul>
      <li>
        <p>有ACK</p>

        <blockquote>
          <p>除了不同步, 跟时隙ALOHA一样</p>
        </blockquote>
      </li>
      <li>
        <p>流程</p>

        <ul>
          <li>发送: 结点发送帧
            <ul>
              <li>成功: 若没检测到碰撞, 则认为成功传输</li>
            </ul>
          </li>
          <li>失败: 检测到碰撞, 立刻以概率p不断尝试重传, 直到没有碰撞</li>
        </ul>
      </li>
      <li>
        <p>效率: 取p=1/N时最大化, 当N趋于无穷时, 效率为1/2e(前后都可能有重叠)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>CSMA/CD</p>

    <ul>
      <li>无ACK</li>
      <li>不做同步</li>
      <li>流程
        <ul>
          <li>监听: 监听信道是否空闲, 空闲时才开始传输, 传输前得等96比特时间(最小帧间隔)</li>
          <li>传输: 传输时也不断监听是否有其他结点的信号能量
            <ul>
              <li>成功: 未发现其他能量, 认为发送成功</li>
            </ul>
          </li>
          <li>失败: 发现其他能量, 立刻停止; <strong>发送48bit干扰信号</strong></li>
          <li>等待(非持续): 等待一个随机时间, 回到”监听”重传</li>
          <li>回退(p持续): 之后的时间当中以概率p重传</li>
          <li>回退(1持续, 以太网): 使用二进制指数后退
            <ul>
              <li>经历过了k次碰撞, 就从[0,…,2^k-1]中选一个K值, 等待512K个比特时间</li>
              <li>k最大为10</li>
              <li>最多尝试16次发送</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>效率: 近似为 
\(\frac{1}{1+5d_{prop}/d_{trans}}\)</li>
      <li>最小帧长: 检测冲突的时长不超过端到端传播时延的2倍, 取这一值为最小帧长</li>
    </ul>
  </li>
</ul>

<h3 id="轮流协议">轮流协议</h3>

<ul>
  <li>轮询协议
    <ul>
      <li>流程: 每个从结点n
        <ul>
          <li>主节点发帧, 告诉从节点n能够发送的最大包数</li>
          <li>从节点发送不超过n帧</li>
          <li>主节点发现没有信号了, 继续轮询下一个从节点</li>
        </ul>
      </li>
      <li>缺点: 轮询时延(第一步耗时); 主节点损坏则信道无用</li>
    </ul>
  </li>
  <li>令牌传递协议
    <ul>
      <li>流程
        <ul>
          <li>收到令牌</li>
          <li>如果有帧要发, 则发送不超过最大数目的帧数</li>
          <li>传递令牌</li>
        </ul>
      </li>
      <li>缺点: 令牌传播时延, 令牌丢失, 单点故障则信道崩溃</li>
    </ul>
  </li>
</ul>

<h2 id="交换局域网">交换局域网</h2>

<h3 id="链路层寻址和arp">链路层寻址和ARP</h3>

<ul>
  <li>媒体访问控制 MAC地址
    <ul>
      <li>长度: 6字节</li>
      <li>与适配器(NIC等)绑定</li>
      <li>广播地址: 全1, 即12个F</li>
      <li>每个主机都检查MAC是否与自己相同, 相同则接收</li>
    </ul>
  </li>
  <li>地址解析协议 ARP协议
    <ul>
      <li>子网内解析</li>
      <li>每台主机或路由器存有ARP表, 保存了其知晓的MAC-IP对应关系, 每个条目有过期时间</li>
      <li>流程
        <ul>
          <li>若有表项, 直接构造包并发送</li>
          <li>若无, 向适配器发送ARP分组(内容: 发送和接收的IP地址, 目的MAC: 广播地址)</li>
          <li>每个主机都收到, 若IP相同, 则响应ARP分组, 用标准链路层帧回复</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>发送数据报到子网以外
    <ul>
      <li>路由器每个端口均有MAC和IP</li>
      <li>路由器将相应ARP, 主机获得的此IP的MAC地址是路由器这一端口的MAC</li>
    </ul>
  </li>
</ul>

<h3 id="以太网">以太网</h3>

<ul>
  <li>以太网帧结构
    <ul>
      <li>帧字段
        <ul>
          <li>前同步码: 8字节: 前7个字节都是10101010, 同步时钟并唤醒适配器; 最后一个是10101011, “11”警告适配器数据到来</li>
          <li>目的MAC地址: 6字节: 与自己的MAC相同才会接收</li>
          <li>源MAC地址: 6字节</li>
          <li>类型字段: 2字节: 允许以太网复用多种网络层协议</li>
          <li>数据: 46-1500: 承载IP数据报, 超长将分片</li>
          <li>CRC: 4字节: 适配器丢弃校验出错的帧</li>
        </ul>
      </li>
      <li>无连接服务: 不事先握手</li>
      <li>不可靠服务: 成功无ACK, 失败无REJ</li>
    </ul>
  </li>
  <li>以太网技术
    <ul>
      <li>命名: [速率]BASE[距离 或 介质], T指铜双绞线, FX/SX/BX指光纤</li>
      <li>10Mbps: 10BASE[%d], 距离, 使用同轴电缆</li>
      <li>100Mbps: 100BASE-TX/T4/T2双绞线, -FX/SX/BX光纤</li>
      <li>1000Mbps: 1000BASE-T等, 又名802.3z, 双绞线, 兼容旧标准, 点对点(交换机)信道全双工, 另有广播(集线器)</li>
      <li>10Gbps: 10GBASE-T</li>
    </ul>
  </li>
</ul>

<h3 id="链路层交换机">链路层交换机</h3>

<ul>
  <li>交换机转发和过滤
    <ul>
      <li>过滤: 决定帧应该发到某个接口还是将其丢弃</li>
      <li>转发: 决定帧去往哪个接口
        <ul>
          <li>流程: 借助交换机表(MAC - 接口 - 时间)
            <ul>
              <li>没找到目的MAC, 向源以外的所有端口广播</li>
              <li>找到MAC, 与源端口匹配, 则丢弃</li>
              <li>找到MAC, 与另一端口匹配, 转发到这一端口(进入端口的缓存)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>自学习
    <ul>
      <li>流程
        <ul>
          <li>初始: 交换表为空</li>
          <li>学习: 收到帧, 则将[源MAC地址 - 到达的接口 - 当前时间]存入交换表</li>
          <li>老化: 一段时间后未收到这一地址作为源的帧, 则此表项移除</li>
        </ul>
      </li>
      <li>即插即用设备: 无需进行配置</li>
      <li>双工: 每个接口可同时发送和接收</li>
    </ul>
  </li>
  <li>链路层交换机的性质
    <ul>
      <li>消除碰撞: 星型拓扑, 没有因碰撞而浪费的带宽</li>
      <li>异质链路: 链路彼此隔离, 允许不同速率, 新旧混用</li>
      <li>管理: 检测异常适配器并断开之, 等</li>
    </ul>
  </li>
  <li>交换机与路由器
    <ul>
      <li>交换机
        <ul>
          <li>优: 即插即用, 分组过滤, 高速率</li>
          <li>缺: 拓扑限制为树形, 不提供广播风暴的保护</li>
        </ul>
      </li>
      <li>路由器
        <ul>
          <li>优: 拓扑灵活, 提供防火墙保护</li>
          <li>缺: 需要配置, 处理延迟大</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="网桥">网桥</h3>

<ul>
  <li>功能: 读取A网(总线)的所有帧, 在B(总线)上重发每个帧; B-&gt;A同理</li>
  <li>特点: 不更改帧, 原样转发; 带缓存; 路由寻址能力(基于MAC, 只转发需要转发的帧)</li>
  <li>协议体系
    <ul>
      <li>层次: 数据链路层 - MAC层</li>
      <li>链接模式
        <ol>
          <li><code class="language-plaintext highlighter-rouge">局域网 - 网桥 - 局域网</code>, 原样转发</li>
          <li><code class="language-plaintext highlighter-rouge">局域网 - 网桥 - [网络或链路] - 网桥 - 局域网</code>, 需要适当封装, 但原始MAC帧不修改</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>固定路由选择
    <ul>
      <li>每对点均有一条选定的路由, 跳数最少, 仅在拓扑变化时改变(生成树算法)</li>
    </ul>
  </li>
  <li>生成树方法
    <ul>
      <li>帧转发
        <ul>
          <li>x收到帧</li>
          <li>检查目的地址: 若在某一端口的列表中, 且非阻塞, 发送; 不在任何列表, 则x除以外的端口全部转发</li>
        </ul>
      </li>
      <li>地址探索: 同交换机
        <ul>
          <li>收到帧, 则帧源地址MAC与此端口关联, 加入此端口数据库</li>
          <li>数据库项带计时器, 超时删除</li>
        </ul>
      </li>
      <li>最小生成树算法: Prim
        <ul>
          <li>Prim算法流程
            <ul>
              <li>选取起始点(根网桥), 加入集合S</li>
              <li>对于S中所有点(网桥), 在他们所有邻居里面找离S中点最短的距离, 把这个邻居加入S, 这条边(网桥间的最短距离)加入生成树</li>
              <li>直到所有点都加入S, 边集合构成生成树</li>
            </ul>
          </li>
          <li>网桥阻塞规则
            <ul>
              <li>选择根网桥: ID最小的网桥</li>
              <li>为每个网桥选择root port: 到根网桥最低开销的端口</li>
              <li>为每个LAN指定网桥: 拥有到根网桥最低开销路径的, 与这个LAN相连的网桥</li>
              <li>Designated port: 这个指定网桥与这个LAN相连的端口</li>
              <li>Designated port 和 root port 不阻塞, 别的都阻塞</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="虚拟局域网">虚拟局域网</h3>

<ul>
  <li>树形交换局域网的缺陷
    <ul>
      <li>缺乏流量隔离: 单播能够隔离, 但广播不行; 缺乏安全隐私的隔离</li>
      <li>交换机无效使用: 为了分组造成交换机端口的浪费</li>
      <li>管理用户: 用户在分组间移动, 则需要改变物理布线, 连接到不同交换机</li>
    </ul>
  </li>
  <li>VLAN: 单一的物理交换机定义多个虚拟局域网, 广播流量仅到达同一分组的端口
    <ul>
      <li>跨VLAN需要路由器</li>
      <li>VLAN划分: 端口 或 MAC</li>
      <li>VLAN干线连接
        <ul>
          <li>干线接口: VLAN交换机之间交换帧</li>
          <li>帧格式802.1Q: 以太网帧的源地址和类型之间, 加入VLAN标志</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="第七章">第七章</h1>

<h2 id="80211-体系结构">802.11 体系结构</h2>

<ul>
  <li>接入点AP： 中央基站</li>
  <li>基本服务集BSS: 1AP + 若干站点(其NIC有唯一MAC)</li>
  <li>基础设施无线LAN: AP和将AP连接到路由器的有线以太网</li>
  <li>信道与关联
    <ul>
      <li>服务集标识符SSID: 热点名(单字/双字)</li>
      <li>信道: 一共11个, 1 6 11是三个不重叠信道</li>
      <li>关联: 站点选择一个AP, 仅通过它接入因特网
        <ul>
          <li>信标帧: AP周期性广播发送, 包含SSID和MAC</li>
          <li>被动扫描: 站点等待信标帧</li>
          <li>主动扫描: 站点广播探测帧, AP回复探测响应帧</li>
          <li>关联流程: 类似DHCP
            <ul>
              <li>关联请求帧 -&gt; 关联响应帧 -&gt; (第二次握手, 与想关联的AP)</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="csmaca-80211-mac协议">CSMA/CA: 802.11 MAC协议</h2>

<ul>
  <li>带碰撞避免的CSMA: CSMA/CA
    <ul>
      <li>载波侦听</li>
      <li>碰撞避免</li>
      <li>使用链路层ARQ: 确认/重传, 有ACK</li>
    </ul>
  </li>
  <li>不适用碰撞检测的原因
    <ul>
      <li>接收信号的强度远小于发送信号的强度, 检测碰撞代价大</li>
      <li>由于隐藏终端, 衰减问题, 无法检测所有的碰撞</li>
    </ul>
  </li>
  <li>链路层确认方案
    <ul>
      <li>目的接到帧, 且通过了CRC检验, 则等待”短帧间间隔SIFS”, 发回确认帧</li>
      <li>发送站点在给定时间内未收到确认, 将会假定发生错误, 并重传该帧</li>
      <li>多次重传失败, 将放弃发送并丢弃该帧</li>
    </ul>
  </li>
  <li>CSMA/CA流程
    <ul>
      <li>监听到信道空闲, 则在”分布式帧间间隔DIFS”的短时间后发送</li>
      <li>否则, 选取一个随机回退值, 并在侦听信道空闲时递减该值, 若信道忙, 则不变</li>
      <li>当值为0时, 发送整个帧</li>
      <li>如果收到确认, 则该帧已被正确接收
        <ul>
          <li>如果此时需要发下一帧, 直接从第二步开始</li>
          <li>如果没有确认, 则进入第二步的回退, 并从更大的范围选取随机值</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>处理隐藏终端
    <ul>
      <li>隐藏终端: AP与节点A B均相互可见, 但由于信号衰减, AB之间互相接收不到对方的信号, 无从进行载波侦听</li>
      <li>请求发送(RTS)帧, 短: 站点广播, 指示传输DATA帧和ACK需要的总时间</li>
      <li>允许发送(CTS)帧, 短: AP广播, 给发送方明确地许可, 并让其他站点知道不要发送
        <ul>
          <li>收到CTS且不是自己发送RTS的站点, 将在其中的时间段内, 抑制发送</li>
        </ul>
      </li>
      <li>效果
        <ul>
          <li>解决隐藏终端, 长DATA只会在预约后才被传输</li>
          <li>发生RTS和CTS的碰撞, 因为他们很短, 仅持续很短时间</li>
        </ul>
      </li>
      <li>实际
        <ul>
          <li>RTS门限值, 大于此的数据才会预约</li>
          <li>许多站点的RTS门限大于帧长, 默认不使用RTS/CTS</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>点对点网络
    <ul>
      <li>定向天线, 没其他站点, 相当于是AP与站点的点对点</li>
    </ul>
  </li>
</ul>

<h1 id="第八章-网络安全">第八章 网络安全</h1>

<ul>
  <li>安全通信要求
    <ul>
      <li>机密性：加密报文</li>
      <li>报文完整性：不会被篡改，或识别出篡改</li>
      <li>端点鉴别：确认两方身份</li>
      <li>运行安全性</li>
    </ul>
  </li>
  <li>密钥
    <ul>
      <li>对称密钥
        <ul>
          <li>攻击方式
            <ul>
              <li>唯密文攻击：入侵者只能截获密文</li>
              <li>已知明文攻击：入侵者知道明文和密文的匹配</li>
              <li>选择明文攻击：能够选择某一明文报文并得到改明文报文对应的密文形式</li>
            </ul>
          </li>
          <li>单码代替密码：凯撒密码</li>
          <li>多码代替密码：不同位置出现的相同字母可能以不同的方式加密</li>
          <li>块密码
            <ul>
              <li>要加密的报文被处理为k比特的块，kbit块明文被映射为k比特块的密文</li>
              <li>如：DES，3DES，AES</li>
            </ul>
          </li>
          <li>流密码</li>
        </ul>
      </li>
      <li>公开密钥加密
        <ul>
          <li>RSA
            <ul>
              <li>$n=pq,z=\phi(n)=(p-1)(q-1)$</li>
              <li>选择$e&lt;n,gcd(e,z)=1$,$ed\mod{z}=1$</li>
              <li>公钥$K_B^+(n,e)$，私钥$K_B^-(n,d)$</li>
              <li>$K_B^+(m)=m^e\mod{n},K_B^-(m)=m^d\mod{n}$.</li>
            </ul>
          </li>
          <li>会话密钥
            <ul>
              <li>用RSA传输用于加密大量传输信息的密钥</li>
            </ul>
          </li>
          <li>报文完整性和数字签名
            <ul>
              <li>密码散列函数：MD5、SHA-1等</li>
              <li>报文鉴别码：报文附加H(m+s),s仅二者已知</li>
              <li>数字签名：私钥签名</li>
              <li>公钥认证：CA</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>端点鉴别
    <ul>
      <li>ap4.0：
        <ul>
          <li>A-&gt;B:   “我是A”</li>
          <li>B-&gt;A: 选一个不重数R，给A</li>
          <li>A-&gt;B:  $K_{A-B}(R)$.</li>
          <li>B验证</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>TCP：SSL
    <ul>
      <li>握手
        <ul>
          <li>客户发送它支持的密码算法的列表，连同一个客户的不重数</li>
          <li>从该列表中，服务器选择一种对称算法（例如AES）、一种公钥算法（例如具有 特定密钥长度的RSA）和一种MAC算法。它把它的选择以及证书和一个服务器不重数返 回给客户</li>
          <li>客户验证该证书，提取服务器的公钥，生成一个前主密钥（Pe Master Secret, PMS）,用服务器的公钥加密该PMS,并将加密的PMS发送给服务器。</li>
          <li>使用相同的密钥导岀函数（就像SSL标准定义的那样），客户和服务器独立地从 PMS和不重数中计算出主密钥（Master Secret, MS）O然后该MS被切片以生成两个密码和 两个MAC密钥。此外，当选择的对称密码应用于CBC （例如3DES或AES）,则两个初始 化向量（Initialization Vector, IV）也从该MS获得，这两个IV分别用于该连接的两端。自 此以后，客户和服务器之间发送的所有报文均被加密和鉴别（使用MAC）</li>
          <li>客户发送所有握手报文的一个MAC</li>
          <li>服务器发送所有握手报文的一个MAC</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="第九章">第九章</h1>

<h2 id="流式存储视频">流式存储视频</h2>

<ul>
  <li>UDP流、HTTP流、适应性HTTP流</li>
  <li>与客户缓存有关</li>
</ul>

<h2 id="提供多种类型的服务">提供多种类型的服务</h2>

<ul>
  <li>监管: 漏桶
    <ul>
      <li>监管准则
        <ul>
          <li>平均速率: 长时间速率存在最大值 - 漏桶的令牌产生速率</li>
          <li>峰值速率: 短时间速率存在最大值 - (将桶容量定为1, 此时能够限制峰值速率)</li>
          <li>突发长度: 极短时间(趋近0)发送的分组数量存在最大值 - 漏桶的高度</li>
        </ul>
      </li>
      <li>漏桶描述
        <ul>
          <li>分组首先进入令牌等待队列</li>
          <li>在漏桶处取得令牌的分组将被发送</li>
          <li>桶高度不超过b</li>
          <li>每秒生成r个令牌加入桶</li>
        </ul>
      </li>
      <li>效果
        <ul>
          <li>平均速率: r + b/t, 时间足够长, 该值为r</li>
          <li>突发长度: b</li>
          <li>峰值速率: 在已有的一个漏桶后, 串联一个高度为1的桶, 其速率r’可限制峰值速率</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
:ET