I"<ol id="markdown-toc">
  <li><a href="#运算符重载与仿函数" id="markdown-toc-运算符重载与仿函数">运算符()重载与仿函数</a></li>
  <li><a href="#unordered_map等的hash_function" id="markdown-toc-unordered_map等的hash_function">unordered_map等的hash_function</a></li>
  <li><a href="#c函数" id="markdown-toc-c函数">C++函数</a>    <ol>
      <li><a href="#引用" id="markdown-toc-引用">引用</a></li>
      <li><a href="#默认参数" id="markdown-toc-默认参数">默认参数</a></li>
      <li><a href="#函数重载" id="markdown-toc-函数重载">函数重载</a></li>
      <li><a href="#模板" id="markdown-toc-模板">模板</a>        <ol>
          <li><a href="#显式具体化" id="markdown-toc-显式具体化">显式具体化</a></li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h2 id="运算符重载与仿函数">运算符()重载与仿函数</h2>

<p>运算符 ()</p>

<p>在stl queue等容器中，需要重载比较运算符()而不是 &lt;</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">cmp</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span><span class="n">triple</span> <span class="n">e1</span><span class="p">,</span><span class="n">triple</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">e1</span><span class="p">.</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">e2</span><span class="p">.</span><span class="n">dist</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">triple</span><span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">triple</span><span class="o">&gt;</span><span class="p">,</span><span class="n">cmp</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>
</code></pre></div></div>

<p>cmp中的()运算符重载是仿函数</p>

<p>既能想普通函数一样传入给定数量的参数，还能存储或者处理更多我们需要的有用信息</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ShorterThan</span> <span class="p">{</span>
    <span class="nl">public:</span>
        <span class="k">explicit</span> <span class="n">ShorterThan</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxLength</span><span class="p">)</span> <span class="o">:</span> <span class="n">length</span><span class="p">(</span><span class="n">maxLength</span><span class="p">)</span> <span class="p">{}</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="nl">private:</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">count_if</span><span class="p">(</span><span class="n">myVector</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myVector</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ShorterThan</span><span class="p">(</span><span class="n">length</span><span class="p">))</span>
<span class="c1">//count_if规定了第三个参数只能接受一个参数，但要使得方便修改，利用仿函数即可</span>
<span class="err">}</span>
</code></pre></div></div>

<h2 id="unordered_map等的hash_function">unordered_map等的hash_function</h2>

<pre><code class="language-C++">static size_t hash(const pair&lt;int,int&gt; &amp; a) {
    return a.first * 3005 + a.second;
}
unordered_map&lt;edge,int,size_t(*)(const pair&lt;int,int&gt; &amp;)&gt;es(n,hash);

unordered_map(size_type __n,
        const hasher&amp; __hf = hasher(),
        const key_equal&amp; __eql = key_equal(),
        const allocator_type&amp; __a = allocator_type())
: _M_h(__n, __hf, __eql, __a)
{ }
</code></pre>

<p>在上述中使用哈希表需要传递hash function，从声明中知有size和hasher，key_equal()使用==操作符，pair已经有重载</p>

<p>除了上述的直接构建实例(注意static，成员函数指针和静态函数指针不同)，还可以使用前面提到的仿函数</p>

<h2 id="c函数">C++函数</h2>

<h3 id="引用">引用</h3>

<p>可以多层函数嵌套对对象进行修改，但是需要注意避免返回函数终止时不再存在的内存单元引用</p>

<p>同时可以进行赋值</p>

<pre><code class="language-C++">type &amp; function(type &amp; arg)
function(arg) = newarg
</code></pre>

<p>当返回是引用时则可以这样，否则不行。或者返回使用const</p>

<pre><code class="language-C++">const type &amp; function(type &amp; arg)
function(arg) = newarg (此时则不允许这样)
</code></pre>

<p>什么时候在函数调用时创建临时变量：</p>

<p>当实参与引用参数不匹配，C++将生成临时变量。目前当参数为const时：（1）实参的类型正确，但不是左值（可被引用的数据对象）（2）类型不正确，但可以转换为正确的类型</p>

<h3 id="默认参数">默认参数</h3>

<pre><code class="language-C++">int function(int tk = 1,int m = 2,int n = 3)
</code></pre>

<p>有默认参数的右侧的参数也必须都有默认参数</p>

<h3 id="函数重载">函数重载</h3>

<p>函数重载的关键是特征标——函数的参数列表，而不是函数的返回类型。因此函数重载返回类型可以不同。</p>

<h3 id="模板">模板</h3>

<p>模板同样可以重载</p>

<h4 id="显式具体化">显式具体化</h4>

<p>函数有多个原型，则编译器在选择原型时，优先选择非模板版本，显式具体化优先于模板</p>

<pre><code class="language-C++">void swap(job &amp;, job &amp;);

template &lt;&gt; void swap&lt;job&gt;(job &amp;,job &amp;);//显式具体化

template &lt;typename T&gt;
void swap(T &amp;,T &amp;);
</code></pre>

<p>显式具体化与显式实例化不同</p>

<pre><code class="language-C++">template void swap&lt;int&gt;(int,int);      //显式实例化
//使用模板生成一个swap的实例

template &lt;&gt; void swap&lt;int&gt; (int ,int ) //显式具体化
template &lt;&gt; void swap (int ,int )      //显式具体化
template &lt;&gt;表示不要使用swap模板来生成一个使用int类型的实例
</code></pre>

:ET